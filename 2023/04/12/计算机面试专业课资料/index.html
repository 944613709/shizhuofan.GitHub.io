

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/shizhuofan.GitHub.io/img/fluid.png">
  <link rel="icon" href="/shizhuofan.GitHub.io/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="面试资料数据结构*O(n)的大O是什么意思？什么是时间复杂度? ★★★O(n)这个大O表示的是最坏情况下的时间复杂度，时间复杂度是指执行算法所需要的计算工作量，对程序规模得一个描述。 *线性存储结构和链式存储结构的优点★★★线性存储结构地址空间连接，可随机访问，但是顺序存储的缺点是删除，插入操作需要花费很多时间在移动元素上 链式存储结构不要求逻辑上相邻的元素在物理位置上是相邻，但也同时失去了顺序表">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2023/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9D%A2%E8%AF%95%E4%B8%93%E4%B8%9A%E8%AF%BE%E8%B5%84%E6%96%99/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="面试资料数据结构*O(n)的大O是什么意思？什么是时间复杂度? ★★★O(n)这个大O表示的是最坏情况下的时间复杂度，时间复杂度是指执行算法所需要的计算工作量，对程序规模得一个描述。 *线性存储结构和链式存储结构的优点★★★线性存储结构地址空间连接，可随机访问，但是顺序存储的缺点是删除，插入操作需要花费很多时间在移动元素上 链式存储结构不要求逻辑上相邻的元素在物理位置上是相邻，但也同时失去了顺序表">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-04-12T07:59:13.122Z">
<meta property="article:modified_time" content="2023-04-12T07:59:15.421Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/shizhuofan.GitHub.io/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/shizhuofan.GitHub.io/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/shizhuofan.GitHub.io/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoursite.com","root":"/shizhuofan.GitHub.io/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/shizhuofan.GitHub.io/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/shizhuofan.GitHub.io/js/utils.js" ></script>
  <script  src="/shizhuofan.GitHub.io/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/shizhuofan.GitHub.io/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/shizhuofan.GitHub.io/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/shizhuofan.GitHub.io/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/shizhuofan.GitHub.io/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/shizhuofan.GitHub.io/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/shizhuofan.GitHub.io/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/shizhuofan.GitHub.io/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-12 15:59" pubdate>
          2023年4月12日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          45k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          374 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none"></h1>
            
            
              <div class="markdown-body">
                
                <h1 id="面试资料"><a href="#面试资料" class="headerlink" title="面试资料"></a>面试资料</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="O-n-的大O是什么意思？什么是时间复杂度-★★★"><a href="#O-n-的大O是什么意思？什么是时间复杂度-★★★" class="headerlink" title="*O(n)的大O是什么意思？什么是时间复杂度? ★★★"></a>*O(n)的大O是什么意思？什么是时间复杂度? ★★★</h3><p>O(n)这个大O表示的是最坏情况下的时间复杂度，时间复杂度是指执行算法所需要的计算工作量，对程序规模得一个描述。</p>
<h3 id="线性存储结构和链式存储结构的优点★★★"><a href="#线性存储结构和链式存储结构的优点★★★" class="headerlink" title="*线性存储结构和链式存储结构的优点★★★"></a>*线性存储结构和链式存储结构的优点★★★</h3><p>线性存储结构地址空间连接，可随机访问，但是顺序存储的缺点是删除，插入操作需要花费很多时间在移动元素上</p>
<p>链式存储结构不要求逻辑上相邻的元素在物理位置上是相邻，但也同时失去了顺序表可随机存取的优点，但方便插入与删除</p>
<h3 id="解释一下顺序存储与链式存储★★★"><a href="#解释一下顺序存储与链式存储★★★" class="headerlink" title="*解释一下顺序存储与链式存储★★★"></a>*解释一下顺序存储与链式存储★★★</h3><p>顺序存储结构吧逻辑上相邻的元素存放到物理位置上相邻的存储单元中，数据元素之间的逻辑关系由存储单元的邻接位置关系来体现。</p>
<p>链接存储方法不要求逻辑上相邻的元素在物理位置上也相邻，元素之间的逻辑关系由附加的指针指示。</p>
<p>参考：《数据结构 殷人昆 第二版》第6页</p>
<h3 id="头指针和头结点的区别？★★"><a href="#头指针和头结点的区别？★★" class="headerlink" title="*头指针和头结点的区别？★★"></a>*头指针和头结点的区别？★★</h3><p>以单链表为例，</p>
<p>头指针就是指向链表第一个结点的指针，链表的第一个结点的地址可以通过链表的头指针找到，对单链表中任一元素的访问必须首先根据头指针找到第一个结点。</p>
<p>参考：《数据结构 殷人昆 第二版》第53页</p>
<p>而头结点是一个附加结点，头结点的data域可以不存储任何信息，也可以存放特殊标志或表长，只要表存在就必须至少有一个头结点。头结点的存在可以优化单链表的增删操作，使得对于空表或者在非空表第一个结点之前插入不用作为特殊情况专门处理，而是使用通用方法。</p>
<p>参考：《数据结构 殷人昆 第二版》第59页</p>
<h3 id="栈和队列的区别和内存结构★★★"><a href="#栈和队列的区别和内存结构★★★" class="headerlink" title="*栈和队列的区别和内存结构★★★"></a>*栈和队列的区别和内存结构★★★</h3><p>栈的定义是只允许在表的末端进行插入和删除的线性表，允许插入和删除的一端叫做栈顶，不允许插入和删除的一端叫做栈底。</p>
<p>栈的存储结构通常分为基于数组的存储表示和顺序存储结构和基于链表的链式存储结构，</p>
<p>顺序栈的内存结构：存放栈中元素的数组、栈顶指针、最大容纳元素个数</p>
<p>链式栈的内存结构：栈顶指针</p>
<p>参考：《数据结构 殷人昆 第二版》第89页</p>
<p>队列的定义是：只允许在表的一端插入，在另一端删除的线性表。允许插入元素的一端称为队尾，允许删除的一端称为队首。</p>
<p>队列的存储结构通常分为基于数组的存储表示和基于链表的存储表示。</p>
<p>顺序存储结构利用一个一维数组作为存储结构，并设置头指针和尾指针两个指针来指示队首和队尾的位置。</p>
<p>链式队列由队首指针和队尾指针构成。</p>
<h3 id="有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？★★"><a href="#有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？★★" class="headerlink" title="有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？★★"></a>有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？★★</h3><p>(p-f+n)%n</p>
<h3 id="如何区分循环队列是队空还是队满？★★★"><a href="#如何区分循环队列是队空还是队满？★★★" class="headerlink" title="如何区分循环队列是队空还是队满？★★★"></a>如何区分循环队列是队空还是队满？★★★</h3><p>front表示队头指针（指向队列内首元素）</p>
<p>rear表示队尾指针（指向队列内尾元素的下一个位置）</p>
<p>m表示队列的容量（包括那个留空的位置）</p>
<p><strong>队空：front&#x3D;rear</strong></p>
<p><strong></strong></p>
<p><strong>队满：front&#x3D;(rear+1)%m</strong></p>


<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiansheshouzuo/article/details/86572825?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164171302716780261911139%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164171302716780261911139&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2%5C~all%5C~sobaiduend%5C~default-2-86572825.pc_search_result_control_group&utm_term=%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA%E5%92%8C%E9%98%9F%E6%BB%A1&spm=1018.2226.3001.4187">https://blog.csdn.net/tiansheshouzuo/article/details/86572825?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164171302716780261911139%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164171302716780261911139&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2\~all\~sobaiduend\~default-2-86572825.pc_search_result_control_group&amp;utm_term=%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA%E5%92%8C%E9%98%9F%E6%BB%A1&amp;spm=1018.2226.3001.4187</a></p>
<h3 id="堆、大顶堆、小顶堆实现及应用-★★"><a href="#堆、大顶堆、小顶堆实现及应用-★★" class="headerlink" title="堆、大顶堆、小顶堆实现及应用 ★★"></a>堆、大顶堆、小顶堆实现及应用 ★★</h3><h3 id="哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？★★★★"><a href="#哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？★★★★" class="headerlink" title="哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？★★★★"></a>哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？★★★★</h3><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/tutorial/93/e7dc954667634630b6c1e93ac87dd271">https://www.nowcoder.com/tutorial/93/e7dc954667634630b6c1e93ac87dd271</a></p>
<h3 id="判断链表是否有环（非常重要！）★★★★★★★"><a href="#判断链表是否有环（非常重要！）★★★★★★★" class="headerlink" title="*判断链表是否有环（非常重要！）★★★★★★★"></a>*判断链表是否有环（非常重要！）★★★★★★★</h3><p>快慢指针：从头开始设置两个指针，快指针每次走2步，慢指针每次走1步，如果快指针先碰到尾，则无环，否则两个指针之后一定会重合，则有环。（leetcode原题)</p>
<h3 id="平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造★★★"><a href="#平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造★★★" class="headerlink" title="*平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造★★★"></a>*平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造★★★</h3><p>完全二叉树的每一个节点都与高度为k的满二叉树的1-n编号一一对应。</p>
<p>具体参考：《数据结构 殷人昆 第二版》220页</p>
<p>二叉搜索树和二叉排序树是一个东西。</p>
<p>二叉排序树每一个节点都是用于排序的关键码，左子树所有节点关键码都小于根节点的关键码，右子树的所有关键码都大于根节点的关键码，其中，左右子树都是二叉树。对一棵二叉排序树进行中序遍历就可以得到关键码从小到大的排列。</p>
<p>二叉排序树的构造方法主要执行插入操作，进行插入之前必须先检查是否该节点的关键码已经在树中存在，也就是要先查找，假如查找成功，不执行任何操作，假如搜索不成功，就在搜索停止的地方添加新元素。</p>
<p>具体参考：《数据结构 殷人昆 第二版》309页</p>
<p>平衡二叉树是一种二叉搜索树，它的左右子树高度差的绝对值不超过1。构造一棵平衡二叉树仍然是通过插入节点的方式，每插入一个结点，都应该检查平衡因子，并通过旋转操作使之平衡化。</p>
<p>具体参考：《数据结构 殷人昆 第二版》321页</p>
<h3 id="如何由遍历序列构造一颗二叉树？-x2F-已知先序序列和后序序列能否重现二叉树？（笔试经常考）★★★"><a href="#如何由遍历序列构造一颗二叉树？-x2F-已知先序序列和后序序列能否重现二叉树？（笔试经常考）★★★" class="headerlink" title="*如何由遍历序列构造一颗二叉树？&#x2F;已知先序序列和后序序列能否重现二叉树？（笔试经常考）★★★"></a>*如何由遍历序列构造一颗二叉树？&#x2F;已知先序序列和后序序列能否重现二叉树？（笔试经常考）★★★</h3><p>若是中序和先序或者中序和后序，则可。</p>
<p>首先先序中我们可以锁定当前第一个点为根，中序中找到这个点，去把子树分割成左子树和右子树两个部分，再依次递归下去即可</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<p>先序和中序不能重现一颗唯一的二叉树。但有可能找出满足此的二叉树。</p>
<h3 id="B树是什么-在数据库中有什么应用？（B数和B-树的区别）★★★"><a href="#B树是什么-在数据库中有什么应用？（B数和B-树的区别）★★★" class="headerlink" title="*B树是什么?在数据库中有什么应用？（B数和B+树的区别）★★★"></a>*B树是什么?在数据库中有什么应用？（B数和B+树的区别）★★★</h3><p>在数据库查询中，以树存储数据。树有多少层，就意味着要读多少次磁盘IO。所以树的高度越矮，就意味着查询数据时，需要读IO的次数就越少。（众所周知，读IO是一件费事的操作）当数据量大的时候，用AVL树存的话，就算AVL是平衡树，但是也扛不住数据量大，数据量大，AVL树的树高肯定很高，那么读取数据的IO次数也会多。B树的一个结点可以装多个值，读取时，是把整个结点读到内存，然后在内存中，对结点的值进行处理，在内存中处理速度肯定比磁盘快。所以只要树的高度低，IO少，就能够提升查询效率，这是B树的好处之一。</p>
<p>B树的缺点是：不利于范围查找(区间查找)，如果要找 0~100的索引值，那么B树需要多次从根结点开始逐个查找。</p>
<p>B+树和B树最大的不同是：B+树内部有两种结点，一种是索引结点，一种是叶子结点。B+树的索引结点并不会保存记录，只用于索引，所有的数据都保存在B+树的叶子结点中。而B树则是所有结点都会保存数据。</p>
<p>B+树的叶子结点都会被连成一条链表。叶子本身按索引值的大小从小到大进行排序。即这条链表是 从小到大的。因此可以直接通过遍历链表实现范围查找。</p>
<p>参考CSDN：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chai471793/article/details/99563704">https://blog.csdn.net/chai471793/article/details/99563704</a></p>
<h3 id="红黑树原理是什么？建立过程？★★★"><a href="#红黑树原理是什么？建立过程？★★★" class="headerlink" title="红黑树原理是什么？建立过程？★★★"></a>红黑树原理是什么？建立过程？★★★</h3><h3 id="二分搜索和单纯的线性搜索的区别-x2F-时间复杂度★★★"><a href="#二分搜索和单纯的线性搜索的区别-x2F-时间复杂度★★★" class="headerlink" title="二分搜索和单纯的线性搜索的区别&#x2F;时间复杂度★★★"></a>二分搜索和单纯的线性搜索的区别&#x2F;时间复杂度★★★</h3><h3 id="插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）★★★★★★"><a href="#插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）★★★★★★" class="headerlink" title="*插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）★★★★★★"></a>*插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）★★★★★★</h3>

<p>基本思想参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/onepixel/articles/7674659.html">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>
<p>冒泡排序最坏情况：如4,3,2,1升序排序，需要比较 3+2+1&#x3D;6&#x3D;4*3&#x2F;2 次</p>
<p>快速排序最坏情况：已经排好顺序的（包括升序、降序、所有元素都一样）</p>
<h3 id="最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？★★★★★★★"><a href="#最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？★★★★★★★" class="headerlink" title="*最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？★★★★★★★"></a>*最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？★★★★★★★</h3><p>最小生成树:<strong>普利姆、克鲁斯卡尔</strong></p>
<p>最短路：<strong>迪杰斯特拉、弗洛依德，单源负权边时是</strong>Bellman Ford算法</p>
<p>迪杰斯特拉，克鲁斯卡尔，普利姆是贪心。</p>
<p>floyd是动态规划，也就是枚举中间点，i-j的距离可以被优化成经过中间点k,i-k-j</p>
<p>堆优化的迪杰斯特拉，克鲁斯卡尔，普利姆均为O(nlogn)</p>
<p>普通dji是O(n^2)</p>
<p>floyd为O(n^3)</p>
<h3 id="邻接表和邻接矩阵（如何存储大数据）★"><a href="#邻接表和邻接矩阵（如何存储大数据）★" class="headerlink" title="邻接表和邻接矩阵（如何存储大数据）★"></a>邻接表和邻接矩阵（如何存储大数据）★</h3><h3 id="介绍一下深度优先搜索和广度优先搜索是如何实现的？★★★"><a href="#介绍一下深度优先搜索和广度优先搜索是如何实现的？★★★" class="headerlink" title="介绍一下深度优先搜索和广度优先搜索是如何实现的？★★★"></a>介绍一下深度优先搜索和广度优先搜索是如何实现的？★★★</h3><h3 id="介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）★★★"><a href="#介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）★★★" class="headerlink" title="介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）★★★"></a>介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）★★★</h3><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="OSI和TCP-x2F-IP模型各个层之间的协议和功能★★★★★★"><a href="#OSI和TCP-x2F-IP模型各个层之间的协议和功能★★★★★★" class="headerlink" title="OSI和TCP&#x2F;IP模型各个层之间的协议和功能★★★★★★"></a>OSI和TCP&#x2F;IP模型各个层之间的协议和功能★★★★★★</h3>

<h3 id="计算机网络为什么要分层？优点？-★★★"><a href="#计算机网络为什么要分层？优点？-★★★" class="headerlink" title="*计算机网络为什么要分层？优点？ ★★★"></a>*计算机网络为什么要分层？优点？ ★★★</h3><p>1.各层之间是独立的。某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间的接口所提供的服务。由于每一层只实现一种相对独立的功能，因而可将一个难以处理的复杂问题分解为若干个较容易处理的更小一些的问题。这样，整个问题的复杂程度就下降了。</p>
<p>2.灵活性好。当任何一层发生变化时（例如由于技术的变化），只要层间接口关系保持不变，则在这层以上或以下各层均不受影响。此外，对某一层提供的服务还可进行修改。</p>
<p>3.当某层提供的服务不再需要时，甚至可以将这层取消。</p>
<p>4.结构上可分割开。各层都可以采用最合适的技术来实现。</p>
<p>5.易于实现和维护。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统已被分解为若干个相对独立的子系统。</p>
<p>6.能促进标准化工作。因为每一层的功能及其所提供的服务都已有了精确的说明。</p>
<h3 id="简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？★★"><a href="#简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？★★" class="headerlink" title="简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？★★"></a>简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？★★</h3><h3 id="协议三要素？（语法、语义、时序）★★"><a href="#协议三要素？（语法、语义、时序）★★" class="headerlink" title="协议三要素？（语法、语义、时序）★★"></a>协议三要素？（语法、语义、时序）★★</h3><h3 id="香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？"><a href="#香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？" class="headerlink" title="香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？"></a>香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？</h3><h3 id="简述一下CSMA-x2F-CD协议★★★★"><a href="#简述一下CSMA-x2F-CD协议★★★★" class="headerlink" title="*简述一下CSMA&#x2F;CD协议★★★★"></a>*简述一下CSMA&#x2F;CD协议★★★★</h3><p>先听后发，边发边听，冲突停发，随机延迟后重发（截断二进制指数退避算法）</p>
<p><strong>CSMA协议(载波侦听多路访问)（Carrier Sense Multiple Access)</strong></p>
<p><strong>非持续式：</strong></p>
<p>经侦听，如果介质空闲，开始发送</p>
<p>如果介质忙，则等待一个随机分布的时间，然后重复步骤1</p>
<p>优点：等待一个随机时间可以减少再次碰撞冲突的可能性</p>
<p>缺点：如果在这个随机时间内介质上没有数据传送，则会发生浪费</p>
<p><strong>1-持续式：</strong></p>
<p>经侦听，如介质空闲，开始发送</p>
<p>如介质忙，持续侦听，一旦空闲立即发送</p>
<p>如果发生冲突，等待一个随机分布的时间再重复步骤1</p>
<p>优点：持续式的延迟时间要少于非持续式</p>
<p>缺点：如果两个以上的站等待发送，一旦介质空闲就一定会发生冲突</p>
<p><strong>p-持续式：</strong></p>
<p>经侦听，如介质空闲，那么以p的概率发送，以(1–p)的概率延迟一个时间单元发送</p>
<p>如介质忙，持续侦听，一旦空闲重复步骤1</p>
<p>如果发送已推迟一个时间单元，再重复步骤1</p>
<p><strong>CSMA&#x2F;CD协议（Collision Detection:碰撞检测）</strong></p>
<p>载波侦听多路访问／碰撞检测(Carrier Sense Multiple Access with Collision Detection,</p>
<p>CSMA&#x2F;CD)</p>
<p>协议是CSMA 协议的改进方案。”载波帧听”就是发送前先侦听，即每个站在发送数据之前先要检测</p>
<p>一下总线上是否有其他站点正在发送数据，若有则暂时不发送数据，等待信道变为空闲时再发</p>
<p>送。”碰撞检测”就是边发送边侦听，即适配器边发送数据边检测信道上信号电压的变化情况，以</p>
<p>便判断自己在发送数据时其他站点是否也在发送数据。工作流程可简单概括为“先听后发，边听边</p>
<p>发（区别于CSMA 协议），冲突停发，随机重发”。</p>
<ol>
<li>适配器从其父结点获得一个网络层数据报，准备一个以太网帧，并把该帧放到适配器缓冲区</li>
</ol>
<p>中。</p>
<ol start="2">
<li>如果适配器侦听到信道空闲，那么它开始传输该帧。如果适配器侦听到信道忙，那么它将等待</li>
</ol>
<p>直至侦听到没有信号能量，然后开始传输该帧。3) 在传输过程中，适配器检测来自其他适配器的信号能量。如果这个适配器传输了整个帧，而没</p>
<p>有检测到来自其他适配器的信号能量，那么这个适配器完成该帧的传输。否则，适配器就须停止</p>
<p>传输它的帧，取而代之传输一个48 比特的拥塞信号。</p>
<ol start="4">
<li>在中止（即传输拥塞信号）后，适配器采用截断二进制指数退避算法等待一段随机时间</li>
</ol>
<p>后返回到步骤2) 。</p>
<h3 id="TCP和UDP的异同点★★★★★★"><a href="#TCP和UDP的异同点★★★★★★" class="headerlink" title="*TCP和UDP的异同点★★★★★★"></a>*TCP和UDP的异同点★★★★★★</h3><p>TCP和UDP的相同点：</p>
<p>TCP和UDP都是在网络层，都是传输层协议，都能都是保护网络层的传输，双方的通信都需要开放端口。</p>
<p>TCP和UDP的不同点：</p>
<ol>
<li><p>TCP的传输是可靠传输。</p>
<p>UDP的传输是不可靠传输。</p>
</li>
</ol>
<p>2. TCP是基于连接的协议，在正式收发数据前，必须和对方建立可靠的连接。</p>
<p>UDP是和TCP相对应的协议，它是面向非连接的协议，它不与对方建立连接，而是直接把数据包发送出去</p>
<p>3. TCP是一种可靠的通信服务，负载相对而言比较大，TCP采用套接字（socket）或者端口（port）来建立通信。</p>
<p>UDP是一种不可靠的网络服务，负载比较小。</p>
<p>4. TCP和UDP结构不同，TCP包括序号、确认信号、数据偏移、控制标志（通常说的URG、ACK、PSH、RST、SYN、FIN）、窗口、校验和、紧急指针、选项等信息。</p>
<p>UDP包含长度和校验和信息。</p>
<p>5. TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。</p>
<p>UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。</p>
<p>6. TCP在发送数据包前在通信双方有一个三次握手机制，确保双方准备好，在传输数据包期间，TCP会根据链路中数据流量的大小来调节传送的速率，传输时如果发现有丢包，会有严格的重传机制，故而传输速度很慢。</p>
<p>UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。</p>
<p>7. TCP支持全双工和并发的TCP连接，提供确认、重传与拥塞控制。</p>
<p>UDP适用于哪些系统对性能的要求高于数据完整性的要求，需要“简短快捷”的数据交换、需要多播和广播的应用环境。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/quiet_girl/article/details/50599777">https://blog.csdn.net/quiet_girl/article/details/50599777</a></p>
<h3 id="TCP的三次握手四次挥手过程？为什么会采用三次握手，若采用二次握手可以吗？★★★★★"><a href="#TCP的三次握手四次挥手过程？为什么会采用三次握手，若采用二次握手可以吗？★★★★★" class="headerlink" title="*TCP的三次握手四次挥手过程？为什么会采用三次握手，若采用二次握手可以吗？★★★★★"></a>*TCP的三次握手四次挥手过程？为什么会采用三次握手，若采用二次握手可以吗？★★★★★</h3><p>四次挥手:<a target="_blank" rel="noopener" href="https://blog.csdn.net/guoweimelon/article/details/50879302">https://blog.csdn.net/guoweimelon/article/details/50879302</a></p>
<p>三次握手:<a target="_blank" rel="noopener" href="https://blog.csdn.net/guoweimelon/article/details/50878730">https://blog.csdn.net/guoweimelon/article/details/50878730</a></p>
<p>如果二次握手：</p>
<p>先假如出现了一种异常情况，即A发出的第一个连接请求报文段因为在某些网络节点上滞留了。由于超时重传，于是A又向B发起请求并成功建立了连接，在传输完数据之后，AB同之间释放了连接。</p>
<p>而在A和B已经释放连接之后，那个在网络上滞留的报文段又达到了B。这时候，B接收到报文以为是A发起的新的一次建立连接的请求，于是就向A发出确认建立连接报文段。而A此时并没有发起建立连接的请求，于是不予理睬。但是B以为新的连接已经建立，一直等待A发送数据，于是B的许多资源就浪费了。</p>
<h3 id="介绍下TCP和UDP协议的特点、头部结构★★★★★"><a href="#介绍下TCP和UDP协议的特点、头部结构★★★★★" class="headerlink" title="介绍下TCP和UDP协议的特点、头部结构★★★★★"></a>介绍下TCP和UDP协议的特点、头部结构★★★★★</h3><h3 id="简述下TCP建立连接的过程-TCP如何保证可靠传输？★★★★★★"><a href="#简述下TCP建立连接的过程-TCP如何保证可靠传输？★★★★★★" class="headerlink" title="*简述下TCP建立连接的过程,TCP如何保证可靠传输？★★★★★★"></a>*简述下TCP建立连接的过程,TCP如何保证可靠传输？★★★★★★</h3><p>TCP协议保证数据传输可靠性的方式主要有：</p>
<ul>
<li>校验和</li>
<li>序列号</li>
<li>确认应答</li>
<li>超时重传</li>
<li>连接管理</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuchenxia8/article/details/80428157?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164024563516780274155503%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164024563516780274155503&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2%5C~all%5C~sobaiduend%5C~default-1-80428157.pc_search_insert_es_download&utm_term=TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93&spm=1018.2226.3001.4187">https://blog.csdn.net/liuchenxia8/article/details/80428157?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164024563516780274155503%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164024563516780274155503&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2\~all\~sobaiduend\~default-1-80428157.pc_search_insert_es_download&amp;utm_term=TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93&amp;spm=1018.2226.3001.4187</a></p>
<h3 id="在TCP拥塞控制中，什么是慢开始、拥塞避免、快重传和快恢复算法？★★★★"><a href="#在TCP拥塞控制中，什么是慢开始、拥塞避免、快重传和快恢复算法？★★★★" class="headerlink" title="*在TCP拥塞控制中，什么是慢开始、拥塞避免、快重传和快恢复算法？★★★★"></a>*在TCP拥塞控制中，什么是慢开始、拥塞避免、快重传和快恢复算法？★★★★</h3><p>我们在开始假定:</p>
<p>1:数据是单方向传递,另一个窗口只发送确认.</p>
<p>2:接收方的缓存足够大,因此发送方的大小的大小由网络的拥塞程度来决定.</p>
<p>一:慢开始算法和拥塞避免算法</p>
<p>发送方会维持一个拥塞窗口,刚开始的拥塞窗口和发送窗口相等,一般开始均设置1,然后我们每收到一个确认,就让拥塞窗口大小变为原来的两倍,接着发送分组也是原来的两倍,以此类推,当窗口值等于16(慢开始门限),然后我们开始采用”加法增大”的策略,即不在以2倍的方式增加,而是转变为每次加1的方式.直到网络拥塞.我们开始采用”拥塞避免”算法:让新的慢开始门限值变为发生拥塞时候的值的一半,将拥塞窗口置为1,然后让它再次重复,这时一瞬间会将网络中的数据量大量降低.</p>
<p>二:快重传和快恢复算法</p>
<p>快重传可以提高网络的吞吐量而快恢复算法相当于拥塞避免算法的后半恢复部分的优化.</p>
<p>假设以下情况:如果在发送方设置的超时定时器到时间还没有收到确认,那么有一种可能是网络发生堵塞,这种情况下,tcp会将拥塞窗口置为一,新的门限值变为发生阻塞时的一半并且开始执行慢开始算法.当我们使用快重传的时候,要求接收方接收到一个失序的报文段后就立即发出 重复确认,(目的是让对方早知道有报文段没有到达)</p>
<p>假设发送方发送了M1–M4四个分组,接收方收到了M1和M2,以及M4,这些分组.</p>
<p>现在接收方不能确认M4,因为M3没有收到,此时接收方可以什么都不干,也可以发送对M2的确认,但是快重传算法要求这样做:</p>
<p>接收方应该及时发送对M2的重复确认,这样可以让发送方知道M3并没有被传过来,发送方还会试着发送M5,M6,接收方收到之后,我们会继续发送对M2的确认,这样一共发了好几个对M2的确认,按照规定,只要发送方收到三个重复确认,就立即重传对方未收到的报文段M3.这样可以避免阻塞,并且提高我们网络的吞吐量.</p>
<p>快恢复算法与快重传算法配合使用</p>
<p>当发送方收到三个连续确认时,就执行”乘法减小”算法,把”慢开始门限”减半,注意接下来不会执行慢开始算法.</p>
<p>由于此时没有发送网络阻塞(要是发生阻塞的话就不会连续收到4个确认),因此此时不执行慢开始算法,并不会将拥塞窗口的值置为1,而是将它置为慢开始门限的一半.然后再实行拥塞避免算法,每次收到确认之后+1.</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_21112393/article/details/50810053?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%9C%A8TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%85%A2%E5%BC%80%E5%A7%8B%E3%80%81%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E3%80%81%E5%BF%AB%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E6%81%A2%E5%A4%8D%E7%AE%97&utm_medium=distribute.pc_search_result.none-task-blog-2%5C~all%5C~sobaiduweb%5C~default-0-50810053.pc_search_result_control_group&spm=1018.2226.3001.4187">https://blog.csdn.net/sinat_21112393/article/details/50810053?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%9C%A8TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%85%A2%E5%BC%80%E5%A7%8B%E3%80%81%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E3%80%81%E5%BF%AB%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E6%81%A2%E5%A4%8D%E7%AE%97&amp;utm_medium=distribute.pc_search_result.none-task-blog-2\~all\~sobaiduweb\~default-0-50810053.pc_search_result_control_group&amp;spm=1018.2226.3001.4187</a></p>
<h3 id="TCP的快速重传机制★★★★"><a href="#TCP的快速重传机制★★★★" class="headerlink" title="TCP的快速重传机制★★★★"></a>TCP的快速重传机制★★★★</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Shawei_/article/details/81775504?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2%5C~aggregatepage%5C~first_rank_ecpm_v1%5C~rank_v31_ecpm-3-81775504.pc_agg_new_rank&utm_term=tcp%E7%9A%84%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6&spm=1000.2123.3001.4430">https://blog.csdn.net/Shawei_/article/details/81775504?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2\~aggregatepage\~first_rank_ecpm_v1\~rank_v31_ecpm-3-81775504.pc_agg_new_rank&amp;utm_term=tcp%E7%9A%84%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6&amp;spm=1000.2123.3001.4430</a></p>
<h3 id="流量控制和拥塞是什么关系-★★★★"><a href="#流量控制和拥塞是什么关系-★★★★" class="headerlink" title="*流量控制和拥塞是什么关系? ★★★★"></a>*流量控制和拥塞是什么关系? ★★★★</h3><p>流量控制解决的是发送方和接收方速率不匹配的问题；拥塞控制解决的是避免网络资源被耗尽的问题。流量控制是通过滑动窗口来实现的；拥塞控制是通过拥塞窗口来实现的。</p>
<p>拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：慢开始、拥塞避免快重传、快恢复。</p>
<p>流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。</p>
<p><a target="_blank" rel="noopener" href="https://www.huaweicloud.com/articles/ba31660f82bbdd3a3e8615ec68d85bc3.html">https://www.huaweicloud.com/articles/ba31660f82bbdd3a3e8615ec68d85bc3.html</a></p>
<h3 id="两个服务器之间网络已经联通，却收不到彼此的UDP报文原因★★★★"><a href="#两个服务器之间网络已经联通，却收不到彼此的UDP报文原因★★★★" class="headerlink" title="*两个服务器之间网络已经联通，却收不到彼此的UDP报文原因★★★★"></a>*两个服务器之间网络已经联通，却收不到彼此的UDP报文原因★★★★</h3><p>可能的原因很多，比如设置了acl（访问控制列表），禁用了某些端口，网络拥塞，丢包等</p>
<p>主要丢包原因</p>
<p><strong>1、接收端处理时间过长导致丢包</strong>：调用recv方法接收端收到数据后，处理数据花了一些时间，处理完后再次调用recv方法，在这二次调用间隔里,发过来的包可能丢失。对于这种情况可以修改接收端，将包接收后存入一个缓冲区，然后迅速返回继续recv。</p>
<p><strong>2、发送的包巨大丢包</strong>：虽然send方法会帮你做大包切割成小包发送的事情，但包太大也不行。例如超过50K的一个udp包，不切割直接通过send方法发送也会导致这个包丢失。这种情况需要切割成小包再逐个send。</p>
<p><strong>3、发送的包较大，超过接受者缓存导致丢包</strong>：包超过mtu size数倍，几个大的udp包可能会超过接收者的缓冲，导致丢包。这种情况可以设置socket接收缓冲。以前遇到过这种问题，我把接收缓冲设置成64K就解决了。</p>
<p>int nRecvBuf&#x3D;32*1024;&#x2F;&#x2F;设置为32K</p>
<p>setsockopt(s,SOL_SOCKET,SO_RCVBUF,(const char*)&amp;nRecvBuf,sizeof(int));</p>
<p><strong>4、发送的包频率太快</strong>：虽然每个包的大小都小于mtu size 但是频率太快，例如40多个mut size的包连续发送中间不sleep，也有可能导致丢包。这种情况也有时可以通过设置socket接收缓冲解决，但有时解决不了。所以在发送频率过快的时候还是考虑sleep一下吧。</p>
<p><strong>5、局域网内不丢包，公网上丢包</strong>。这个问题我也是通过切割小包并sleep发送解决的。如果流量太大，这个办法也不灵了。总之udp丢包总是会有的，如果出现了用我的方法解决不了，还有这个几个方法： 要么减小流量，要么换tcp协议传输，要么做丢包重传的工作。</p>
<h3 id="地址解析协议和RARP协议★★"><a href="#地址解析协议和RARP协议★★" class="headerlink" title="地址解析协议和RARP协议★★"></a>地址解析协议和RARP协议★★</h3><h3 id="网卡是什么？功能？★★★"><a href="#网卡是什么？功能？★★★" class="headerlink" title="*网卡是什么？功能？★★★"></a>*网卡是什么？功能？★★★</h3><p>网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p>
<p>网卡的作用：</p>
<p>网络是通过模拟信号将信息转化为电流传播的，网卡在这里面就充当了一个解码器的作用，将电信号重新转换文文字图像等就是网卡的责任。网卡的其他功能还有监控上传及下载流量，控制网速稳定的作用，它就相当于电脑的港口，所有信息上传到网络之前都要先到网卡这里走一遭。</p>
<p>每台电脑都有网卡，没有网卡无法上网。</p>
<h3 id="说下网络中的主机通信流程★★"><a href="#说下网络中的主机通信流程★★" class="headerlink" title="说下网络中的主机通信流程★★"></a>说下网络中的主机通信流程★★</h3><h3 id="一个主机将两个端口接到网络上是否会提升吞吐量？为什么？★★"><a href="#一个主机将两个端口接到网络上是否会提升吞吐量？为什么？★★" class="headerlink" title="一个主机将两个端口接到网络上是否会提升吞吐量？为什么？★★"></a>一个主机将两个端口接到网络上是否会提升吞吐量？为什么？★★</h3><h3 id="简述下DNS域名解析的过程。★★★★★"><a href="#简述下DNS域名解析的过程。★★★★★" class="headerlink" title="*简述下DNS域名解析的过程。★★★★★"></a>*简述下DNS域名解析的过程。★★★★★</h3><p>1、当客户机提出查询请求时，首先在本地计算机的缓存中查找。如果在本地无法获得查询信息，则将查询请求发给DNS服务器。</p>
<p>2、首先客户机将域名查询请求发送到本地DNS服务器,当本地DNS服务器接到查询后，首先在该服务器管理的区域的记录中查找，如果找到该记录，则利用此记录进行解析；如果没有区域信息可以满足查询要求，服务器在本地的缓存中查找。</p>
<p>3、如果本地服务器不能在本地找到客户机查询的信息，将客户机请求发送到根域名DNS服务器。</p>
<p>4、根域名服务器负责解析客户机请求的根域部分，它将包含下一级域名信息的DNS服务器地址返回给客户机的DNS服务器地址。</p>
<p>5、客户机的DNS服务器利用根域名服务器解析的地址访问下一级DNS服务器，得到再下一级域我的DNS服务器地址。</p>
<p>6、按照上述递归方法逐级接近查询目标，最后在有目标域名的DNS服务器上找到相应IP地址信息。</p>
<p>7、客户机的本地DNS服务器将递归查询结果返回客户机。</p>
<p>8、客户机利用从本地DNS服务器查询得到的IP访问目标主机，就完成了一个解析过程。</p>
<h3 id="点击网页一次HTTP请求过程？（在浏览器里输入一个网址，会发生什么）★★★"><a href="#点击网页一次HTTP请求过程？（在浏览器里输入一个网址，会发生什么）★★★" class="headerlink" title="*点击网页一次HTTP请求过程？（在浏览器里输入一个网址，会发生什么）★★★"></a>*点击网页一次HTTP请求过程？（在浏览器里输入一个网址，会发生什么）★★★</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21993785/article/details/81188253">https://blog.csdn.net/qq_21993785/article/details/81188253</a></p>
<h3 id="机器的ip地址和mac地址，他们有什么区别，有什么用途？★★"><a href="#机器的ip地址和mac地址，他们有什么区别，有什么用途？★★" class="headerlink" title="机器的ip地址和mac地址，他们有什么区别，有什么用途？★★"></a>机器的ip地址和mac地址，他们有什么区别，有什么用途？★★</h3><h3 id="HTTP状态码及其含义★★★★-HTTP和HTTPS的区别★★★★"><a href="#HTTP状态码及其含义★★★★-HTTP和HTTPS的区别★★★★" class="headerlink" title="*HTTP状态码及其含义★★★★ HTTP和HTTPS的区别★★★★"></a>*HTTP状态码及其含义★★★★ HTTP和HTTPS的区别★★★★</h3><p>状态码含义:<a target="_blank" rel="noopener" href="https://blog.csdn.net/whl826661099/article/details/98606745">https://blog.csdn.net/whl826661099/article/details/98606745</a></p>
<p>区别:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wqhwe/p/5407468.html">https://www.cnblogs.com/wqhwe/p/5407468.html</a></p>
<h3 id="DHCP的作用？★★"><a href="#DHCP的作用？★★" class="headerlink" title="DHCP的作用？★★"></a>DHCP的作用？★★</h3><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/DHCP/218195?fr=aladdin">https://baike.baidu.com/item/DHCP/218195?fr=aladdin</a></p>
<h3 id="能不能直接在应用层把数据交给网络层★★★"><a href="#能不能直接在应用层把数据交给网络层★★★" class="headerlink" title="*能不能直接在应用层把数据交给网络层★★★"></a>*能不能直接在应用层把数据交给网络层★★★</h3><p>在应用层数据的呈现形式是声音、图形、文字等具体的信息，而网络通信信道所能传输的是电信号（一般是数字信号），以上信息无法直接通过信道传输，所以，必须将数据转化成二进制传输。</p>
<p>不完整回答（从传输层目的层面）：</p>
<p><strong>传输层</strong>为<strong>运行在不同主机上的进程之间</strong>提供了逻辑通信,而<strong>网络层</strong>则提供了<strong>主机之间</strong>的逻辑通信。</p>
<p>传输层向上提供可靠的和不可靠的逻辑通信信道</p>
<p>TCP 和 UDP 都用<strong>端口号</strong>来识别应用层实体,一边准确地把信息交给上层对应的协议(进程)。</p>
<h3 id="了解Socket吗？什么是socket？★★★★"><a href="#了解Socket吗？什么是socket？★★★★" class="headerlink" title="*了解Socket吗？什么是socket？★★★★"></a>*了解Socket吗？什么是socket？★★★★</h3>

<h3 id="简述一下Cookie-和-Session的区别★★★"><a href="#简述一下Cookie-和-Session的区别★★★" class="headerlink" title="*简述一下Cookie 和 Session的区别★★★"></a>*简述一下Cookie 和 Session的区别★★★</h3><p>区别：</p>
<p>1、数据存放位置不同：</p>
<p>cookie数据存放在客户的浏览器上，session数据放在服务器上。</p>
<p>2、安全程度不同：</p>
<p>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。</p>
<p>3、性能使用程度不同：</p>
<p>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。</p>
<p>4、数据存储大小不同：</p>
<p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，而session则存储与服务端，浏览器对其没有限制。</p>


<p>5、会话机制不同</p>
<p>session会话机制：session会话机制是一种服务器端机制，它使用类似于哈希表（可能还有哈希表）的结构来保存信息。</p>
<p>cookies会话机制：cookie是服务器存储在本地计算机上的小块文本，并随每个请求发送到同一服务器。 Web服务器使用HTTP标头将cookie发送到客户端。在客户端终端，浏览器解析cookie并将其保存为本地文件，该文件自动将来自同一服务器的任何请求绑定到这些cookie。</p>
<h3 id="https-www-cnblogs-com-zyf-zhaoyafei-p-4716297-htmlhttps-www-cnblogs-com-zyf-zhaoyafei-p-4716297-html-https-www-cnblogs-com-zyf-zhaoyafei-p-4716297-html计算机网络之面试常考"><a href="#https-www-cnblogs-com-zyf-zhaoyafei-p-4716297-htmlhttps-www-cnblogs-com-zyf-zhaoyafei-p-4716297-html-https-www-cnblogs-com-zyf-zhaoyafei-p-4716297-html计算机网络之面试常考" class="headerlink" title="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.htmlhttps://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html计算机网络之面试常考"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html</a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html</a> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html</a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">计算机网络之面试常考</a></h3><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="操作系统的特点？功能？★"><a href="#操作系统的特点？功能？★" class="headerlink" title="*操作系统的特点？功能？★"></a>*操作系统的特点？功能？★</h3><p>操作系统特点：</p>
<p>操作系统的四个基本特征是并发,共享,异步,虚拟。而每个操作系统又有其独特的特征，如我们常用的linux系统有开放性;多用户多任务;设备的独立性;强大的网络功能和网络可靠性等特点。</p>
<p>操作系统的功能：</p>
<p>管理计算机系统的全部软、硬件资源 , 合理组织计算机的工作流程 , 以达到充分发挥计算机资源的效率 , 为用户提供友好界面</p>
<h3 id="中断和系统调用的区别★★★"><a href="#中断和系统调用的区别★★★" class="headerlink" title="*中断和系统调用的区别★★★"></a>*中断和系统调用的区别★★★</h3><p><a target="_blank" rel="noopener" href="http://www.cppblog.com/chxzwj/archive/2011/11/03/159575.html">http://www.cppblog.com/chxzwj/archive/2011/11/03/159575.html</a><a target="_blank" rel="noopener" href="http://www.cppblog.com/chxzwj/archive/2011/11/03/159575.html">中断和系统调用的区别</a></p>
<p>中断分两种，硬中断和软中断；硬中断是实实在在的硬件发出的中断，cpu检测到发生中断后，保护现场，查找中断向量地址，执行中断服务程序，之后，重新选择进程进行调度。软中断是由指令执行过程中发出的中断，但是并没有中断向量表，而是有对应的散转表，查找对应的中断号，转中断服务程序，之后的和硬中断相同。</p>
<p><strong>系统调用是软中断的一种。</strong></p>
<p>无论如何，发生中断时，要从目态转向管态。</p>
<h3 id="进程、线程的概念以及区别？进程间的通信方式？★★★★★★"><a href="#进程、线程的概念以及区别？进程间的通信方式？★★★★★★" class="headerlink" title="*进程、线程的概念以及区别？进程间的通信方式？★★★★★★"></a>*进程、线程的概念以及区别？进程间的通信方式？★★★★★★</h3><p><strong>一、进程与线程的区别</strong></p>
<p>进程是具有一定功能的程序，是系统进行资源分配调度的一个独立单位。</p>
<p>线程是进程的一个实体，是CPU调度分配的基本单位，线程之间基本上不拥有系统资源。</p>
<p>一个程序至少有一个进程，一个进程至少有一个线程，资源分配给进程，同一个进程下所有线程共享该进程的资源。</p>
<p><strong>二、线程哪些资源共享？哪些资源不共享？</strong></p>
<p>共享：堆、全局变量、静态变量、文件等共用资源</p>
<p>独享：栈、寄存器</p>
<p>进程间的通信方式:<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaohong_bo/article/details/89552188">https://blog.csdn.net/zhaohong_bo/article/details/89552188</a></p>
<h3 id="进程有哪几种状态，状态之间的转换、进程调度策略？★★★★"><a href="#进程有哪几种状态，状态之间的转换、进程调度策略？★★★★" class="headerlink" title="*进程有哪几种状态，状态之间的转换、进程调度策略？★★★★"></a>*进程有哪几种状态，状态之间的转换、进程调度策略？★★★★</h3><p>进程的三种状态</p>
<p><strong>就绪（Ready）状态</strong></p>
<p>进程已分配到除CPU以外的所有必要资源，只要获得处理机便可立即执行。</p>
<p><strong>执行（Running）状态</strong></p>
<p>进程已获得处理机，其程序正在处理机上执行。</p>
<p><strong>阻塞（Blocked）状态</strong></p>
<p>正在执行的程序，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的原因可能是等待I&#x2F;O完成、申请缓冲区不能满足、等待信号等。</p>


<p><strong>Q1：为什么在转换图中没有就绪到阻塞和阻塞到执行的转换方向？</strong></p>
<p>就绪状态进程没有占有处理机，即不经过执行，其状态就不会改变；阻塞状态进程唤醒后要先进入到就绪队列，才会被调度程序选中，进行执行状态</p>
<p><strong>1.先来先服务调度算法：</strong>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p>
<p><strong>2.短作业(进程)优先调度算法：</strong>短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</p>
<p><strong>3.高优先权优先调度算法：</strong>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。</p>
<p><strong>3.1) 非抢占式优先权算法：</strong>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p>
<p><strong>3.2) 抢占式优先权调度算法：</strong>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi&gt;Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p>
<p><strong>4、高响应比优先调度算法：</strong>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</p>


<p>在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。</p>
<p><strong>5、时间片轮转法：</strong>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。</p>
<p><strong>6、多级反馈队列调度算法：</strong>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。</p>
<p><strong>(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。</strong>第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。</p>
<p><strong>(2)当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。</strong>当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。</p>
<p><strong>(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；</strong>仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</p>
<ol>
<li><strong>*读写者问题是用进程实现的还是线程实现的？文件系统中文件是如何组织的？</strong></li>
</ol>
<p>读写者问题是用进程实现的还是线程实现的？文件系统中文件是如何组织的？</p>
<p>（不作为回答内容：这题网上没答案吧，我看读者写者进程、线程实现都可以，根据武老师上课说，我们第二章之后讲的都以进程作为例子，推测是进程）</p>
<p>读写者问题实现：</p>
<p>读写者问题是经典进程同步问题，是用进程实现的。</p>
<p>如何组织：</p>
<p>文件组织是指文件的构造方式。文件用户按照自己的使用要求，把构成文件的元素组织起来，文件的这种结构叫文件逻辑结构。</p>
<p>文件的逻辑组织 文件的逻辑组织通常分为两种形式，即有结构文件（记录文件）和无结构文件（字符流文件）。1）有结构文件又称作记录式文件，它在逻辑上可被看成一组连续记录的集合，即文件是由若干个相关的记录组成。每个记录是一组相关的数据集合，用于描述一个对象某个方面的属性。记录式文件按其记录的长度是否相同又可分为：定长记录文件和变长记录文件两种。（1）定长记录文件：指文件中所有记录的长度都相同。文件的长度可用记录的数目来表示。定长记录处理方便，开销小，被广泛用于数据处理中。（2）变长记录文件：指文件中各记录的长度不相同。在处理之前每个记录的长度是已知的。2）无结构文件无结构文件是指文件内部不再划分记录，它是由一组相关信息组成的有序字符流，即流式文件，其长度直接按字节计算。如大量的源程序、可执行程序、库函数等采用的文件形式是无结构文件形式。在UNIX系统中，所有的普通文件都被看做是流式文件，系统不对文件进行格式处理。 ●常用的记录式结构有：连续结构、多重结构、转置结构和顺序结构。 ●常用的存取方法有顺序存取法、随机存取法（直接存取法）和按键存取法。 文件的物理组织 ●常用的文件物理结构有连续文件、串联文件和索引文件。 1）连续文件连续文件（又称做顺序文件）是基于磁带设备的最简单的物理文件结构，它是把一个逻辑上连续的文件信息存放在连续编号的物理块（或物理记录）中。连续文件的优点是在顺序存取时速度较快，常用于存放系统文件，如操作系统文件、编译程序文件和其它由系统提供的实用程序文件，因为这类文件往往被从头至尾依次存取。但连续文件也存在如下缺点：</p>
<p>（1）要求建立文件时就确定它的长度，依此来分配相应的存储空间，这往往很难实现。</p>
<p>（2）不便于文件的动态扩充。</p>
<p>（3）可能出现外部碎片，就是在存储介质上存在很多空闲块，但它们都不连续，无法被连续的文件使用，从而造成浪费。 2）串联文件为克服连续文件的缺点，可把一个逻辑上连续的文件分散存放在不同的物理块中，这些物理块不要求连续，也不必规则排列。为了使系统能找到下一个逻辑块所在的物理块，可在各物理块中设立一个指针（称为连接字），它指示该文件的下一个物理块。串连文件克服了连续文件的缺点，但它又带来新的问题：</p>
<p>（1）一般仅适于对信息的顺序访问，而不利于对文件的随机存取。</p>
<p>（2）每个物理块上增加一个连接字，为信息管理添加了一些麻烦。 FAT格式通过把文件分配表（FAT，File Allocation Table ）放在一个内存表格中的方式加以克服串联文件的缺点。 3）索引文件 索引文件是实现非连续分配的另一种方案：系统为每个文件建立一个索引表。其中的表项指出存放该文件的各个物理块号，而整个索引表由文件说明项指出。这种结构除了具备串连文件的优点之外，还克服了它的缺点。它可以方便地进行随机存取。但是这种组织形式需要增加索引表带来的空间开销。如果这些表格仅放在盘上，那么在存取文件时首先得取出索引表，然后才能查表、得到物理块号。这样就至少增加了一次访盘操作，从而降低了存取文件的速度，加重了 I&#x2F;O负担。一种改进办法是同时把索引表部分或全部地放人内存。这是以内存空间为代价来换取存取速度的改善。 树型目录结构树型目录结构可能是目录结构中，考的比较多的，考的也简单。</p>
<h3 id="什么是死锁？死锁产生的四个必要条件？如何预防死锁？★★★★★★"><a href="#什么是死锁？死锁产生的四个必要条件？如何预防死锁？★★★★★★" class="headerlink" title="*什么是死锁？死锁产生的四个必要条件？如何预防死锁？★★★★★★"></a>*什么是死锁？死锁产生的四个必要条件？如何预防死锁？★★★★★★</h3><p><strong>一、什么是死锁</strong></p>
<p>死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p>
<p><strong>二、产生死锁的原因：</strong></p>
<p>1、竞争不可抢占型资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</p>
<p>2、竞争可消耗型资源（可消耗型资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</p>
<p>3、进程推进顺序不当（若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。</p>
<p>当P1运行到P1，Request时，将因R2已被P2占用而阻塞；当P2运行到P2：Request时，也将因R1已被P1占用而阻塞，于是发生进程死锁）</p>
<p><strong>三、死锁产生的四个必要条件</strong></p>
<p>1、互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</p>
<p>2、请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>3、不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</p>
<p>4、环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</p>
<p><strong>四、如何预防死锁</strong></p>
<p>1、资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</p>
<p>2、允许程序获得运行初期条件的所有资源后开始运行，过程中逐步释放给自己的已用毕的资源，然后再请求新的资源（破坏请保持条件）</p>
<p>3、可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</p>
<p>4、资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hd12370/article/details/82814348">https://blog.csdn.net/hd12370/article/details/82814348</a></p>
<h3 id="哲学家进餐有哪些实现方式？★★★★"><a href="#哲学家进餐有哪些实现方式？★★★★" class="headerlink" title="*哲学家进餐有哪些实现方式？★★★★"></a>*哲学家进餐有哪些实现方式？★★★★</h3><p>哲学家进餐问题的核心是保证至少有一位哲学家能拿到两只筷子就餐后释放筷子。</p>
<p>（1）最多只允许n-1个哲学家拿起筷子就餐。</p>
<p>（2）资源分级算法,奇数号哲学家先拿左手边的筷子，偶数号的哲学家先拿右手边的筷子。</p>
<p>（3）设立规则，当一位哲学家拿起一只筷子时，另一个筷子无法得到，则放下刚刚拿起的筷子.</p>
<p>(4 ) 服务生算法,一次只允许一名哲学家进餐，等到这名哲学家进餐完毕后才允许其他哲学家进餐。</p>
<h3 id="简述下银行家算法★★★★"><a href="#简述下银行家算法★★★★" class="headerlink" title="*简述下银行家算法★★★★"></a>*简述下银行家算法★★★★</h3><p>银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。</p>
<p>银行家算法中的数据结构</p>
<p>为了实现银行家算法，必须设置以下四个数据结构:</p>
<p>（1）可利用资源向量Available:其初始值是系统中所配置的该类全部可用资源的数目。</p>
<p>（2）最大需求矩阵Max:它定义了系统中n个进程中的每一个进程对m类资源的最大需求。</p>
<p>（3）分配矩阵Allocation:它定义了系统中每一类资源当前已分配给每一个进程的资源数。</p>
<p>（4）需求矩阵Need：用一表示每一个进程尚需的各类资源数。</p>
<p>银行家算法检查的步骤</p>
<p>Request(i)是进程P(i)的请求向量。如果Requst(i)[j] &#x3D; K,表示进程P(i)需要K个R(j)类型的资源。</p>
<p>（1）如果Request(i)[j] &lt;&#x3D; Need[i,j],便转向步骤2,否则出错；</p>
<p>（2）如果Request(i)[j] &lt;&#x3D; Available[j],便转向步骤3，否则出错；</p>
<p>（3）系统试探着把资源分配给进程P,并修改下面数据结构中的数值:</p>
<p>(非常重要)</p>
<p>Available[j] &#x3D; Avaliable[j] - Request(i)[j];</p>
<p>Allocation[i,j] &#x3D; Allocation[i,j] + Request(i)[j];</p>
<p>Need[i,j] &#x3D; Need[i,j] - Request(i)[j];</p>
<p>（4）执行**安全性算法*,检查此次资源分配后系统是否处于安全状态*。安全则分配，否则分配作废。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34649947/article/details/70224868">https://blog.csdn.net/qq_34649947/article/details/70224868</a></p>
<h3 id="介绍下几种常见的进程调度算法及其流程（FCFS，SJF，剩余短作业优先，优先级调度，轮转法，多级反馈队列等等）★★★★★★"><a href="#介绍下几种常见的进程调度算法及其流程（FCFS，SJF，剩余短作业优先，优先级调度，轮转法，多级反馈队列等等）★★★★★★" class="headerlink" title="介绍下几种常见的进程调度算法及其流程（FCFS，SJF，剩余短作业优先，优先级调度，轮转法，多级反馈队列等等）★★★★★★"></a>介绍下几种常见的进程调度算法及其流程（FCFS，SJF，剩余短作业优先，优先级调度，轮转法，多级反馈队列等等）★★★★★★</h3><h3 id="分页的作用，好处？和分段有什么区别？★★★"><a href="#分页的作用，好处？和分段有什么区别？★★★" class="headerlink" title="*分页的作用，好处？和分段有什么区别？★★★"></a>*分页的作用，好处？和分段有什么区别？★★★</h3><p>（1）页是信息的物理单位，分页是为了实现非连续分配，以便解决内存碎片问题，或者说分页是由于系统管理的需要。段是信息的逻辑单位，它含有一组意义相对完整的信息，分段的目的是为了更好地实现共享，满足用户的需要。</p>
<p>（2）页的大小固定且由系统确定，将逻辑地址划分为页号和页内地址是由机器硬件实现的，而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时根据信息的性质来划分。</p>
<p>（3）分页的作业地址空间是一维的；分段的地址空间是二维的。</p>
<h3 id="内存分配有哪些机制？（JVM的内存管理及垃圾回收算法）★★★"><a href="#内存分配有哪些机制？（JVM的内存管理及垃圾回收算法）★★★" class="headerlink" title="内存分配有哪些机制？（JVM的内存管理及垃圾回收算法）★★★"></a>内存分配有哪些机制？（JVM的内存管理及垃圾回收算法）★★★</h3><ol>
<li><strong>*什么是虚拟内存？什么是共享内存？</strong>★★★</li>
</ol>
<p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。</p>
<p>共享内存是最快速的进程间通信机制。操作系统在几个进程的地址空间上映射一段内存，然后这几个进程可以在不需要调用操作系统函数的情况下在那段内存上进行读&#x2F;写操作</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhanyd/article/details/102987669">https://blog.csdn.net/zhanyd/article/details/102987669</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_a9cdad020102wxzw.html">http://blog.sina.com.cn/s/blog_a9cdad020102wxzw.html</a></p>
<h3 id="有哪些页面置换算法？★★★★"><a href="#有哪些页面置换算法？★★★★" class="headerlink" title="*有哪些页面置换算法？★★★★"></a>*有哪些页面置换算法？★★★★</h3><ol>
<li>最佳置换算法(OPT):每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</li>
<li>先进先出置换算法（FIFO）:每次选择淘汰的页面是最早进入内存的页面。</li>
<li>最近最久未使用置换算法:每次淘汰的页面是最近最久未使用的页面</li>
<li>时钟置换算法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某个页被访问时，其访问位置1.当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，暂不换出，将访问位改为0，继续检查下一个页面，若第一轮扫描中所有的页面都是1，则将这些页面的访问位一次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）。</li>
<li>改进型时钟置换算法：</li>
</ol>
<p>第一轮：从当前位置开始扫描第一个的页用于替换，本轮扫描不修改任何标志位。</p>
<p>第二轮：若第一轮扫描失败，则重新扫描，查找第一个的页用于替换。本轮将所有扫描的过的页访问位设为0。</p>
<p>第三轮：若第二轮扫描失败，则重新扫描，查找第一个的页用于替换。本轮扫描不修改任何标志位。</p>
<p>第四轮：若第三轮扫描失败，则重新扫描，查找第一个的页用于替换。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/18285ecffbfb">https://www.jianshu.com/p/18285ecffbfb</a></p>
<h3 id="说一说操作系统中缓冲区溢出怎么处理★★★"><a href="#说一说操作系统中缓冲区溢出怎么处理★★★" class="headerlink" title="*说一说操作系统中缓冲区溢出怎么处理★★★"></a>*说一说操作系统中缓冲区溢出怎么处理★★★</h3><p><strong>缓冲区溢出</strong></p>
<p>当计算机程序向缓冲区内填充的数据位数超过了缓冲区本身的容量。溢出的数据覆盖在合法数据上</p>
<p>理想情况是，程序检查数据长度并且不允许输入超过缓冲区长度的字符串。但是绝大多数程序都会假设数据长度总是与所分配的存储空间相匹配，这就为缓冲区溢出埋下隐患。操作系统所使用的缓冲区又被称为堆栈，在各个操作进程之间，指令被临时存储在堆栈当中，堆栈也会出现缓冲区溢出。</p>
<p><strong>上溢</strong></p>
<p>当一个超长的数据进入到缓冲区时，超出部分被写入上级缓冲区，</p>
<p>上级缓冲区存放的可能是数据、上一条指令的指针，或者是其他程序的输出内容</p>
<p>，这些内容都被覆盖或者破坏掉。可见一小部分数据或者一套指令的溢出就可能导致一个程序或者操作系统崩溃。</p>
<p><strong>下溢</strong></p>
<p>当一个超长的数据进入到缓冲区时，超出部分被写入下级缓冲区，</p>
<p>下级缓冲区存放的是下一条指令的指针，或者是其他程序的输出内容。</p>
<p>缓冲区攻击的日渐泛滥，微软并未任其张扬，陆陆续续推出了各种保存措施。其中重要的有GS，SafeSeh，ASLR，DEP等，接下来我们针对这些措施进行原理分析：</p>
<p><strong>①.GS保护原理：</strong></p>
<p>通过VC++编译器在函数前后添加额外的处理代码，前部分用于由伪随机数生成的cookie并放入.data节段，当本地变量初始化，就会向栈中插入cookie，它位于局部变量和返回地址之间在缓冲区溢出利用时，如果将恶意代码从局部变量覆盖到返回地址，那么自然就会覆写cookie，当检测到与原始cookie不同时，就会触发异常，最后终止进程。</p>
<p><strong>②.SafeSeh保护</strong></p>
<p>为了防止SEH节点被攻击者恶意利用，微软在．net编译器中加入&#x2F;sdeseh编译选项引入SafeSEH技术。编译器在编译时将PE文件所有合法的异常处理例程的地址解析出来制成一张表，放在PE文件的数据块(LQAJ)一C0N—FIG)中，并使用shareuser内存中的一个随机数加密，用于匹配检查。</p>
<p>如果该PE文件不支持safesEH，则表的地址为0。当PE文件被系统加载后，表中的内容被加密保存到ntdl1．dll模块的某个数据区。在PE文件运行期间，如果发生异常需要调用异常处理例程，系统会逐个检查该例程在表中是否有记录：如果没有则说明该例程非法，进而不执行该异常例程。</p>
<p><strong>③.ASLR保护</strong></p>
<p>ASLR（地址空间布局随机化）技术的主要功能是通过对系统关键地址的随机化，防止攻击者在堆栈溢出后利用固定的地址定位到恶意代码并加以运行。</p>
<p><strong>④.DEP保护</strong></p>
<p>数据执行保护 (DEP) 是一套软硬件技术，能够在内存上执行额外检查以防止在不可运行的内存区域上执行代码</p>
<p>这些保护机制的出现，一度使得攻击难度大大增加，但攻击者们也不是吃素的，他们也在研究绕过这些保护的办法。所谓千里之堤溃于蚁穴，对于上面的保护，攻击者只要找到了它们的一个弱点，便可以突破所有防线，实现攻击。攻击与防护，不断在对抗，可以预见，在未来一段时间，这种游戏还将持续上演。</p>
<p>但是，现在的漏洞门槛比十年前高了N倍，笔者在实际中也常常遇到有漏洞却不能利用的情况。但是也不要灰心，老的技术被淘汰，新的技术又会出来，本属正常，但像缓冲区溢出这种经典的东西，无论什么时候，都值得我们学习。</p>
<h3 id="磁盘调度算法以及磁盘空间存储管理？★★★★"><a href="#磁盘调度算法以及磁盘空间存储管理？★★★★" class="headerlink" title="*磁盘调度算法以及磁盘空间存储管理？★★★★"></a>*磁盘调度算法以及磁盘空间存储管理？★★★★</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lishanleilixin/article/details/89709194">https://blog.csdn.net/lishanleilixin/article/details/89709194</a></p>
<h3 id="文件系统中文件是如何组织的？★★"><a href="#文件系统中文件是如何组织的？★★" class="headerlink" title="*文件系统中文件是如何组织的？★★"></a>*文件系统中文件是如何组织的？★★</h3><p>文件的逻辑组织 文件的逻辑组织通常分为两种形式，即有结构文件（记录文件）和无结构文件（字符流文件）。1）有结构文件又称作记录式文件，它在逻辑上可被看成一组连续记录的集合，即文件是由若干个相关的记录组成。每个记录是一组相关的数据集合，用于描述一个对象某个方面的属性。记录式文件按其记录的长度是否相同又可分为：定长记录文件和变长记录文件两种。（1）定长记录文件：指文件中所有记录的长度都相同。文件的长度可用记录的数目来表示。定长记录处理方便，开销小，被广泛用于数据处理中。（2）变长记录文件：指文件中各记录的长度不相同。在处理之前每个记录的长度是已知的。2）无结构文件无结构文件是指文件内部不再划分记录，它是由一组相关信息组成的有序字符流，即流式文件，其长度直接按字节计算。如大量的源程序、可执行程序、库函数等采用的文件形式是无结构文件形式。在UNIX系统中，所有的普通文件都被看做是流式文件，系统不对文件进行格式处理。 ●常用的记录式结构有：连续结构、多重结构、转置结构和顺序结构。 ●常用的存取方法有顺序存取法、随机存取法（直接存取法）和按键存取法。 文件的物理组织 ●常用的文件物理结构有连续文件、串联文件和索引文件。 1）连续文件连续文件（又称做顺序文件）是基于磁带设备的最简单的物理文件结构，它是把一个逻辑上连续的文件信息存放在连续编号的物理块（或物理记录）中。连续文件的优点是在顺序存取时速度较快，常用于存放系统文件，如操作系统文件、编译程序文件和其它由系统提供的实用程序文件，因为这类文件往往被从头至尾依次存取。但连续文件也存在如下缺点：</p>
<p>（1）要求建立文件时就确定它的长度，依此来分配相应的存储空间，这往往很难实现。</p>
<p>（2）不便于文件的动态扩充。</p>
<p>（3）可能出现外部碎片，就是在存储介质上存在很多空闲块，但它们都不连续，无法被连续的文件使用，从而造成浪费。 2）串联文件为克服连续文件的缺点，可把一个逻辑上连续的文件分散存放在不同的物理块中，这些物理块不要求连续，也不必规则排列。为了使系统能找到下一个逻辑块所在的物理块，可在各物理块中设立一个指针（称为连接字），它指示该文件的下一个物理块。串连文件克服了连续文件的缺点，但它又带来新的问题：</p>
<p>（1）一般仅适于对信息的顺序访问，而不利于对文件的随机存取。</p>
<p>（2）每个物理块上增加一个连接字，为信息管理添加了一些麻烦。 FAT格式通过把文件分配表（FAT，File Allocation Table ）放在一个内存表格中的方式加以克服串联文件的缺点。 3）索引文件 索引文件是实现非连续分配的另一种方案：系统为每个文件建立一个索引表。其中的表项指出存放该文件的各个物理块号，而整个索引表由文件说明项指出。这种结构除了具备串连文件的优点之外，还克服了它的缺点。它可以方便地进行随机存取。但是这种组织形式需要增加索引表带来的空间开销。如果这些表格仅放在盘上，那么在存取文件时首先得取出索引表，然后才能查表、得到物理块号。这样就至少增加了一次访盘操作，从而降低了存取文件的速度，加重了 I&#x2F;O负担。一种改进办法是同时把索引表部分或全部地放人内存。这是以内存空间为代价来换取存取速度的改善。 树型目录结构树型目录结构可能是目录结构中，考的比较多的，考的也简单。</p>
<p>原文链接 <a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/1946134093877936908.html">https://zhidao.baidu.com/question/1946134093877936908.html</a></p>
<h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><h3 id="冯诺依曼机的体系结构★★★★★"><a href="#冯诺依曼机的体系结构★★★★★" class="headerlink" title="*冯诺依曼机的体系结构★★★★★"></a>*冯诺依曼机的体系结构★★★★★</h3>

<p>主要由五大部件组成</p>
<p>1.存储器用来存放数据和程序</p>
<p>2.运算器主要运行算数运算和逻辑运算，并将中间结果暂存到运算器中</p>
<p>3.控制器主要用来控制和指挥程序和数据的输入运行，以及处理运算结果</p>
<p>4.输入设备用来将人们熟悉的信息形式转换为机器能够识别的信息形式，常见的有键盘，鼠标等</p>
<p>5.输出设备可以将机器运算结果转换为人们熟悉的信息形式，如打印机输出，显示器输出等</p>
<h3 id="衡量计算机性能指标★★★★"><a href="#衡量计算机性能指标★★★★" class="headerlink" title="*衡量计算机性能指标★★★★"></a>*衡量计算机性能指标★★★★</h3><p>1、<strong>吞吐量</strong>：表征一台计算机在某一时间间隔内能够处理的信息量，单位是字节&#x2F;秒。</p>
<p>2、<strong>响应时间</strong>：表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量，例如微秒（10-6S）、纳秒（10-9S）。</p>
<p>3、<strong>利用率</strong>：表示在给定的时间间隔内，系统被实际使用的时间所占的比率，一般用百分比表示。</p>
<p>4、<strong>处理机字长</strong>：指处理机运算器中一次能够完成二进制数运算的位数。当前处理机的字长有8位、16位、32位、64位。字长越长，表示计算的精度越高。</p>
<p>5、<strong>总线宽度</strong>：一般指CPU中运算器与存储器之间进行互连的内部总线二进制位数。</p>
<p>6、<strong>存储器容量</strong>：存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示。 其中K&#x3D;210，M&#x3D;220，G&#x3D;230，T&#x3D;240， B&#x3D;8位（1个字节）。</p>
<p>7、<strong>存储器带宽</strong>：存储器的速度指标，单位时间内从存储器读出的二进制数信息量，一般用字节数&#x2F;秒表示。</p>
<p>8、<strong>主频&#x2F;时钟周期</strong>：CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率（f）叫CPU的主频。度量单位是MHz、GHz。 主频的倒数称为CPU时钟周期（T），即T&#x3D;1&#x2F;f，度量单位是微秒、纳秒。</p>
<p>9、<strong>CPU执行时间</strong>：表示CPU执行一段程序所占用的CPU时间，可用下式计算： CPU执行时间 ＝ CPU时钟周期数 × CPU时钟周期长 CPI：表示每条指令周期数，即执行一条指令所需的平均时钟周期数。 用下式计算：</p>
<p>MIPS:每秒百万条数据。MIPS是单位时间内的执行指令数，所以MIPS值越高说明机器速度越快。 MFLOPS是基于操作而非指令的，只能用来衡量机器浮点操作的性能，而不能体现机器的整体性能。</p>
<h3 id="原码、反码、补码★★★"><a href="#原码、反码、补码★★★" class="headerlink" title="原码、反码、补码★★★"></a>原码、反码、补码★★★</h3><p>在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念.</p>
<p><strong>1、机器数</strong></p>
<p>一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.</p>
<p>比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。</p>
<p>那么，这里的 00000011 和 10000011 就是机器数。</p>
<p><strong>2、真值</strong></p>
<p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。</p>
<p>所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p>
<p>例：0000 0001的真值 &#x3D; +000 0001 &#x3D; +1，1000 0001的真值 &#x3D; –000 0001 &#x3D; –1</p>
<p><strong>3. 原码</strong></p>
<p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p>
<p>[+1]原 &#x3D; 0000 0001 [-1]原 &#x3D; 1000 0001</p>
<p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p>
<p>[1111 1111 , 0111 1111]&#x3D;&#x3D;&gt;[-127 , 127]</p>
<p><strong>4. 反码</strong></p>
<p>反码的表示方法是:</p>
<ul>
<li>正数的反码是其本身</li>
<li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</li>
</ul>
<p>[+1] &#x3D; [00000001]原 &#x3D; [00000001]反 [-1] &#x3D; [10000001]原 &#x3D; [11111110]反</p>
<p><strong>5. 补码</strong></p>
<p>补码的表示方法是:</p>
<ul>
<li>正数的补码就是其本身</li>
<li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</li>
</ul>
<p>[+1] &#x3D; [00000001]原 &#x3D; [00000001]反 &#x3D; [00000001]补 [-1] &#x3D; [10000001]原 &#x3D; [11111110]反 &#x3D; [11111111]补</p>
<h3 id="奇偶校验、汉明码校验，循环冗余校验★★"><a href="#奇偶校验、汉明码校验，循环冗余校验★★" class="headerlink" title="*奇偶校验、汉明码校验，循环冗余校验★★"></a>*奇偶校验、汉明码校验，循环冗余校验★★</h3><p><strong>奇偶校验：</strong></p>
<p>奇偶校验有两种校验规则：</p>
<ul>
<li>奇校验：使完整编码（有效位和校验位）中的”1”的个数为奇数个；</li>
<li>偶校验：使完整编码（有效位和校验位）中的”1”的个数为偶数个</li>
</ul>
<p>直接举例：</p>
<table>
<thead>
<tr>
<th>待编有效信息</th>
<th>奇校验码</th>
<th>偶校验码</th>
</tr>
</thead>
<tbody><tr>
<td>10111010</td>
<td>101110100</td>
<td>101110101</td>
</tr>
<tr>
<td>11010010</td>
<td>110100101</td>
<td>110100100</td>
</tr>
</tbody></table>
<p>因此，如果是奇校验，当待编有效信息的”1”为奇数个，在最后添0，偶数个添1，偶校验相反。</p>
<p>1.奇偶校验实际上就是对我们DnDn-1…D0进行异或运算（两两相同为0，不同为1），最后偶校验生成0，奇校验生成1，正确，反之错误。</p>
<p>上面表格，第一个我们使用奇校验，第二个使用偶校验。</p>
<p>第一个奇校验：1⊕0⊕1⊕1⊕1⊕0⊕1⊕0⊕0&#x3D;1</p>
<p>第二个偶校验：1⊕1⊕0⊕1⊕0⊕0⊕1⊕0⊕0&#x3D;0</p>
<p>2.如果第一个数据传输过去，变成111110100，很明显地D7变成了1，这时候再进行奇偶校验</p>
<p>1⊕1⊕1⊕1⊕1⊕0⊕1⊕0⊕0&#x3D;0</p>
<p>这样我们就能判断数据中出现了错误。</p>
<p><strong>汉明码校验：</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhang175gl/article/details/88637223">https://blog.csdn.net/zhang175gl/article/details/88637223</a></p>
<p><strong>循环冗余校验：</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liyuanbhu/article/details/7882789">https://blog.csdn.net/liyuanbhu/article/details/7882789</a></p>
<h3 id="存储器的分类（RAM、DAM的区别）★★"><a href="#存储器的分类（RAM、DAM的区别）★★" class="headerlink" title="存储器的分类（RAM、DAM的区别）★★"></a>存储器的分类（RAM、DAM的区别）★★</h3>

<p>常见存储器分类图示</p>
<p>RAM：随机存取存储器是与CPU直接交换数据的内部存储器。它可以随时读写，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储媒介。当电源关闭时RAM不能保留数据。如果需要保存数据，就必须把它们写入一个长期的存储设备中（例如硬盘）。RAM和ROM相比，两者的最大区别是RAM在断电以后保存在上面的数据会自动消失，而ROM不会自动消失，可以长时间断电保存。</p>
<p>ROM：只读存储器。ROM所存数据，一般是装入整机前事先写好的，整机工作过程中只能读出，而不像随机存储器那样能快速地、方便地加以改写。ROM所存数据稳定，断电后所存数据也不会改变。</p>
<p>RAM可以分为SRAM（静态随机存储器）和DRAM（动态随机存储器）。</p>
<p>SRAM它是一种具有静止存取功能的内存，不需要刷新电路即能保存它内部存储的数据。优点是速度快，不必配合内存刷新电路，可提高整体的工作效率。缺点是集成度低，功耗较大，相同的容量体积较大，而且价格较高，少量用于关键性系统以提高效率。</p>
<p>DRAM是最为常见的系统内存。DRAM只能将数据保持很短的时间。为了保持数据，DRAM使用电容存储，所以必须隔一段时间刷新（refresh）一次，如果存储单元没有被刷新，存储的信息就会丢失。</p>
<p>SDRAM（同步动态随机存取存储器），是在DRAM的基础上发展而来，为DRAM的一种，同步是指Memory工作需要同步时钟，内部命令的发送与数据的传输都以时钟为基准；动态是指存储阵列需要不断的刷新来保证数据不丢失；随机是指数据不是线性依次存储，而是由指定地址进行数据读写。</p>
<p>DDR SDRAM又是在SDRAM的基础上发展而来，这种改进型的DRAM和SDRAM是基本一样的，不同之处在于它可以在一个时钟读写两次数据，这样就使得数据传输速度加倍了。这是目前电脑中用得最多的内存，而且它有着成本优势。</p>
<h3 id="段页式虚拟内存★★★"><a href="#段页式虚拟内存★★★" class="headerlink" title="段页式虚拟内存★★★"></a>段页式虚拟内存★★★</h3><h3 id="cpu一个指令周期的流程是什么？★★★★★"><a href="#cpu一个指令周期的流程是什么？★★★★★" class="headerlink" title="cpu一个指令周期的流程是什么？★★★★★"></a>cpu一个指令周期的流程是什么？★★★★★</h3>

<h3 id="总线通讯的四种方式★★"><a href="#总线通讯的四种方式★★" class="headerlink" title="总线通讯的四种方式★★"></a>总线通讯的四种方式★★</h3><h2 id="https-blog-csdn-net-yuanyuan320-article-details-110244550编译原理"><a href="#https-blog-csdn-net-yuanyuan320-article-details-110244550编译原理" class="headerlink" title="https://blog.csdn.net/yuanyuan320/article/details/110244550编译原理"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuanyuan320/article/details/110244550%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86">https://blog.csdn.net/yuanyuan320/article/details/110244550编译原理</a></h2><h3 id="写出编译的过程；求first和follow集合★★★"><a href="#写出编译的过程；求first和follow集合★★★" class="headerlink" title="写出编译的过程；求first和follow集合★★★"></a>写出编译的过程；求first和follow集合★★★</h3><h3 id="上下文无关文法的特点★★★★"><a href="#上下文无关文法的特点★★★★" class="headerlink" title="上下文无关文法的特点★★★★"></a>上下文无关文法的特点★★★★</h3><h3 id="编译原理中的0、1、2、3型文法及其关系。★★★★★"><a href="#编译原理中的0、1、2、3型文法及其关系。★★★★★" class="headerlink" title="编译原理中的0、1、2、3型文法及其关系。★★★★★"></a>编译原理中的0、1、2、3型文法及其关系。★★★★★</h3><p>0型或短语文法：</p>
<p>产生式形如：α-&gt;β</p>
<p>其中：α、β属于字符串的闭包区间内且α至少包含有一个非终结符；</p>
<p>解释：左边有非终结符，右边有终结符。</p>
<p>举例：A-&gt;ab， A-&gt;Cb， A-&gt;b</p>
<p>0型文法是这几个文法中，限制最少的一个，一般见到的文法都可看做0型文法。0型文法的能力相当于图灵机（Turing）。</p>
<p>1型文法：又称为上下文有关文法：</p>
<p>产生式形如：α-&gt;β</p>
<p>其中：α-&gt;β均满足|α|&lt;&#x3D;|β|, 除了α-&gt;ε外；</p>
<p>解释：式子左边可以有多个字符，但必须有一个非终结符；式子右边可以有多个字符，可以是终结符，也可以是非终结符，但必须是有限个字符且左边长度必须小于右边</p>
<p>举例：A-&gt;B，A-&gt;Bba ，Bb-&gt;A，</p>
<p>2型文法：又称为上下文无关文法：</p>
<p>产生式形如： A -&gt;β</p>
<p>解释：式子左边必须是非终结符，然而一个终结符一个非终结符的组合不是一个非终结符，如Ab不是一个非终结符，但是两个非终结符的组合就是一个非终结符了，如AB就是行了；式子右边可以有多个字符，可以是终结符，也可以是非终结符，但必须是有限个字符</p>
<p>举例：AB-&gt;abc，B-&gt;ab</p>
<p>3型文法：又称为正规文法（正规文法又包括左线性文法和右线性文法）：</p>
<p>右线性文法：</p>
<p>产生式形如： A -&gt;αB 或 A -&gt;α</p>
<p>解释：式子左边只能有一个字符，而且必须是非终结符；式子右边最多有二个字符。如果有二个字符必须是（终结符+非终结符）的格式，如果是一个字符，那么必须是终结符。</p>
<p>举例：B-&gt;aB</p>
<p>左线性文法：</p>
<p>产生式形如： A -&gt;Bα 或 A -&gt;α</p>
<p>解释：式子左边只能有一个字符，而且必须是非终结符；式子右边最多有二个字符。如果有二个字符必须是（非终结符+终结符）的格式，如果是一个字符，那么必须是终结符。</p>
<p>举例：B-&gt;Ba</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/MillionSong/article/details/105672676">https://blog.csdn.net/MillionSong/article/details/105672676</a></p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="一二三范式★★★★★"><a href="#一二三范式★★★★★" class="headerlink" title="*一二三范式★★★★★"></a>*一二三范式★★★★★</h3><p><strong>第一范式 (1NF)</strong></p>
<p>属性不可分。即数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体</p>
<p>中的某个属性不能有多个值或者不能有重复的属性。</p>
<p><strong>第二范式 (2NF)</strong></p>
<p>每个非主属性完全函数依赖于键码。可以通过分解来满足 2NF。</p>
<p><strong>第三范式 (3NF)</strong></p>
<p>非主属性不传递函数依赖于键码。简而言之，第三范式就是属性不依赖于其它非主属性。</p>
<h3 id="SQL查询语句★★"><a href="#SQL查询语句★★" class="headerlink" title="SQL查询语句★★"></a>SQL查询语句★★</h3><h3 id="数据库有什么类型的数据库、关系型数据库的特点★★★★"><a href="#数据库有什么类型的数据库、关系型数据库的特点★★★★" class="headerlink" title="数据库有什么类型的数据库、关系型数据库的特点★★★★"></a>数据库有什么类型的数据库、关系型数据库的特点★★★★</h3><h3 id="数据库有几种锁？★★★"><a href="#数据库有几种锁？★★★" class="headerlink" title="数据库有几种锁？★★★"></a>数据库有几种锁？★★★</h3><p>共享（S)锁：多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S锁立即被释放。</p>
<p>排它（X)锁：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。</p>
<p>更新（U)锁：用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。</p>
<h3 id="数据库的三个完整性约束★★★★"><a href="#数据库的三个完整性约束★★★★" class="headerlink" title="数据库的三个完整性约束★★★★"></a>数据库的三个完整性约束★★★★</h3><p>实体完整性，参照完整性和用户自定义完整性约束。实体完整性规定表的每一行在表中是唯一的实体。</p>
<p>参照完整性指两个表的主关键字和外关键字的数据一致，保证表之间的数据一致性，防止数据丢失或无意义的数据在数据库中扩散。</p>
<p>用户自定义完整性是不同数据库根据应用环境不同，用户定义的一些特殊约束条件。</p>
<h3 id="事务与锁？什么是事物？什么事锁？事务的四个特性是什么？★★★★★"><a href="#事务与锁？什么是事物？什么事锁？事务的四个特性是什么？★★★★★" class="headerlink" title="*事务与锁？什么是事物？什么事锁？事务的四个特性是什么？★★★★★"></a>*事务与锁？什么是事物？什么事锁？事务的四个特性是什么？★★★★★</h3><p>什么是事务？</p>
<p>事务是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。</p>
<p>什么是锁？</p>
<p>锁是用于解决隔离性的一种机制。事务的隔离级别通过锁的机制来实现。</p>
<p>事物的四个特性（ACID）：</p>
<p>原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</p>
<p>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。</p>
<p>隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<p>持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p>
<p>链接：</p>
<p>1.<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37206355/article/details/105475028">https://blog.csdn.net/qq_37206355/article/details/105475028</a></p>
<p>2.<a target="_blank" rel="noopener" href="https://www.cnblogs.com/tjw-bk/p/13974795.html">https://www.cnblogs.com/tjw-bk/p/13974795.html</a></p>
<h3 id="存储过程是什么？触发器是什么？为什么要使用存储过程？★★★"><a href="#存储过程是什么？触发器是什么？为什么要使用存储过程？★★★" class="headerlink" title="存储过程是什么？触发器是什么？为什么要使用存储过程？★★★"></a>存储过程是什么？触发器是什么？为什么要使用存储过程？★★★</h3><p>存储过程（Stored Procedure）是在大型<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/215176">数据库系统</a>中，一组为了完成特定功能的SQL 语句集，它存储在数据库中，一次<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91/1258343">编译</a>后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。在数据量特别庞大的情况下利用存储过程能达到倍速的效率提升。</p>
<p>触发器（trigger）是SQL server 提供给<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%91%98/62748">程序员</a>和数据分析员来保证<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7/110071">数据完整性</a>的一种方法，它是与表事件相关的特殊的存储过程，它的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%89%A7%E8%A1%8C/3166225">执行</a>不是由程序调用，也不是手工启动，而是由事件来触发，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%AF%94%E5%A6%82">比如</a>当对一个表进行操作（ insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等。</p>
<p>存储过程处理比较复杂的业务时比较实用。 比如说，一个复杂的数据操作。如果你在前台处理的话。可能会涉及到多次数据库连接。但如果你用存储过程的话。就只有一次。从响应时间上来说有优势。 也就是说存储过程可以给我们带来运行效率提高的好处。 另外，程序容易出现 BUG 不稳定，而存储过程，只要数据库不出现问题，基本上是不会出现什么问题的。也就是说从安全上讲，使用了存储过程的系统更加稳定。</p>
<p>1.存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。 2.当对数据库进行复杂操作时(如对多个表进行 Update,Insert,Query,Delete 时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。这些操作，如果用程序来完成，就变成了一条条的 SQL 语句，可能要多次连接数据库。而换成存储，只需要连接一次数据库就可以了。 3.存储过程可以重复使用,可减少数据库开发人员的工作量。 4.安全性高,可设定只有某此用户才具有对指定存储过程的使用权。</p>
<p>存储过程的缺点 1：调试麻烦，但是用 PL&#x2F;SQL Developer 调试很方便！弥补这个缺点。 2：移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。 3：重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。 4：如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的。维护起来更加麻烦！</p>
<h3 id="数据库的ACID特性，事务回滚，如何解决数据的不一致？事务的ACID特性怎么保证？（REDO-x2F-UNDO机制）★★★"><a href="#数据库的ACID特性，事务回滚，如何解决数据的不一致？事务的ACID特性怎么保证？（REDO-x2F-UNDO机制）★★★" class="headerlink" title="数据库的ACID特性，事务回滚，如何解决数据的不一致？事务的ACID特性怎么保证？（REDO&#x2F;UNDO机制）★★★"></a>数据库的ACID特性，事务回滚，如何解决数据的不一致？事务的ACID特性怎么保证？（REDO&#x2F;UNDO机制）★★★</h3><h3 id="Mysql的存储引擎及区别★★★"><a href="#Mysql的存储引擎及区别★★★" class="headerlink" title="*Mysql的存储引擎及区别★★★"></a>*Mysql的存储引擎及区别★★★</h3><p>只要记住重要的几个引擎：InnoDB、MyISAM、Memory、Archive。不过其他的还有BLACKHOLE和CSV。</p>
<p>主要对比一下前两个和中间两个。</p>
<p>INNODB：</p>
<p>用于事务处理应用程序，支持外键和行级锁。如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包括很多更新和删除操作，那么InnoDB存储引擎是比较合适的。</p>
<p>InnoDB除了有效的降低由删除和更新导致的锁定，还可以确保事务的完整提交和回滚，</p>
<p>对于类似计费系统或者财务系统等对数据准确要求性比较高的系统都是合适的选择。</p>
<p>MyISAM：</p>
<p>如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那么可以选择这个存储引擎。</p>
<p>Memory：</p>
<p>将所有的数据保存在内存中，在需要快速定位记录和其他类似数据的环境下，可以提供极快的访问。Memory的缺陷是对表的大小有限制，虽然数据库因为异常终止的话数据可以正常恢复，但是一旦数据库关闭，存储在内存中的数据都会丢失。</p>
<p>ARCHIVE：</p>
<p>拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩。支持最基本的插入和查询两种功能。在MySQL 5.5开始支持索引。不支持事务。支持行级锁和专用的缓存区，所以可以实现高并发的插入。适合存储大量日志、历史数据。</p>
<p>是的，只有INNODB支持事务操作，INNODB也是MySQL的默认引擎，个人认为最重要的一个。</p>
<p>参考CSDN：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zgrgfr/article/details/74455547">https://blog.csdn.net/zgrgfr/article/details/74455547</a></p>
<ol>
<li><strong>如何优化数据库？提高查询的效率？</strong>★★★★★★</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xlgen157387/article/details/44156679">https://blog.csdn.net/xlgen157387/article/details/44156679</a></p>
<h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><h3 id="什么是软件工程？软件工程三要素？★★★"><a href="#什么是软件工程？软件工程三要素？★★★" class="headerlink" title="什么是软件工程？软件工程三要素？★★★"></a>什么是软件工程？软件工程三要素？★★★</h3><p>软件工程三要素包括：方法、工具和过程。</p>
<h3 id="软件生存周期？★"><a href="#软件生存周期？★" class="headerlink" title="软件生存周期？★"></a>软件生存周期？★</h3><h3 id="软件开发模型？★"><a href="#软件开发模型？★" class="headerlink" title="软件开发模型？★"></a>软件开发模型？★</h3><h3 id="黑盒测试和白盒测试有什么区别？★★★"><a href="#黑盒测试和白盒测试有什么区别？★★★" class="headerlink" title="*黑盒测试和白盒测试有什么区别？★★★"></a>*黑盒测试和白盒测试有什么区别？★★★</h3><p><strong>一、测试方式不同</strong></p>
<p>1、黑盒测试：功能测试，是通过测试来检测每个功能是否都能正常使用。</p>
<p>2、白盒测试：称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。</p>
<p><strong>二、测试目的不同</strong></p>
<p>1、黑盒测试：把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。</p>
<p>2、白盒测试：通过检查软件内部的逻辑结构，对软件中的逻辑路径进行覆盖测试。在程序不同地方设立检查点，检查程序的状态，以确定实际运行状态与预期状态是否一致。</p>
<p><strong>三、测试原则不同</strong></p>
<p>1、黑盒测试：以用户的角度，从输入数据与输出数据的对应关系出发进行测试的。很明显，如果外部特性本身设计有问题或规格说明的规定有误，用黑盒测试方法是发现不了的。</p>
<p>2、白盒测试：一个模块中的所有独立路径至少被测试一次。所有逻辑值均需测试true和false两种情况。</p>
<h3 id="敏捷开发和瀑布模型的区别★"><a href="#敏捷开发和瀑布模型的区别★" class="headerlink" title="敏捷开发和瀑布模型的区别★"></a>敏捷开发和瀑布模型的区别★</h3><h3 id="配置管理包括哪些活动★"><a href="#配置管理包括哪些活动★" class="headerlink" title="配置管理包括哪些活动★"></a>配置管理包括哪些活动★</h3><h3 id="持续集成及其特性★"><a href="#持续集成及其特性★" class="headerlink" title="持续集成及其特性★"></a>持续集成及其特性★</h3><h3 id="说一个你了解的设计模式？结合项目举个例子？★★★★★★"><a href="#说一个你了解的设计模式？结合项目举个例子？★★★★★★" class="headerlink" title="*说一个你了解的设计模式？结合项目举个例子？★★★★★★"></a>*说一个你了解的设计模式？结合项目举个例子？★★★★★★</h3><p><strong>总体来说设计模式分为三大类：</strong></p>
<p><strong>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</strong></p>
<p><strong>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</strong></p>
<p><strong>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</strong></p>
<p><strong>其实还有两类：并发型模式和线程池模式。</strong></p>
<h3 id="介绍下MVC模式★★★★"><a href="#介绍下MVC模式★★★★" class="headerlink" title="*介绍下MVC模式★★★★"></a>*介绍下MVC模式★★★★</h3><p>MVC 模式（Model–view–controller）是软件工程中的一种软件架构模式，它把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p>
<p>MVC 模式的目的是实现一种动态的程序设计，简化后续对程序的修改和扩展，并且使程序某一部分的重复利用成为可能。除此之外，MVC 模式通过对复杂度的简化，使程序的结构更加直观。软件系统在分离了自身的基本部分的同时，也赋予了各个基本部分应有的功能。专业人员可以通过自身的专长进行相关的分组：</p>
<p><strong>模型（Model）</strong>：程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)；</p>
<p><strong>控制器（Controller）</strong>：负责转发请求，对请求进行处理；</p>
<p><strong>视图（View）</strong>：界面设计人员进行图形界面设计。</p>
<p>具体：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liitdar/article/details/86685880">https://blog.csdn.net/liitdar/article/details/86685880</a></p>
<h2 id="算法分析与设计"><a href="#算法分析与设计" class="headerlink" title="算法分析与设计"></a>算法分析与设计</h2><h3 id="动态规划和分治、贪心相比有什么区别？各自的优缺点？"><a href="#动态规划和分治、贪心相比有什么区别？各自的优缺点？" class="headerlink" title="动态规划和分治、贪心相比有什么区别？各自的优缺点？"></a>动态规划和分治、贪心相比有什么区别？各自的优缺点？</h3><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="指针和引用的区别★★★★★"><a href="#指针和引用的区别★★★★★" class="headerlink" title="指针和引用的区别★★★★★"></a>指针和引用的区别★★★★★</h3><p>★相同点：</p>
<p>●都是地址的概念；</p>
<p>指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。</p>
<p>★不同点：</p>
<p>●指针是一个实体，而引用仅是个别名；</p>
<p>●引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；</p>
<p>●引用没有const，指针有const，const的指针不可变；</p>
<p>●引用不能为空，指针可以为空；</p>
<p>●“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；</p>
<p>●指针和引用的自增(++)运算意义不一样；</p>
<p>●引用是类型安全的，而指针不是 (引用比指针多了类型检查</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xdrt81y/article/details/18004129">https://blog.csdn.net/xdrt81y/article/details/18004129</a></p>
<h3 id="浅拷贝和深拷贝★★★"><a href="#浅拷贝和深拷贝★★★" class="headerlink" title="浅拷贝和深拷贝★★★"></a>浅拷贝和深拷贝★★★</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jiang7701037/article/details/98738487">https://blog.csdn.net/jiang7701037/article/details/98738487</a></p>
<h3 id="程序的编译执行过程★★★★★★"><a href="#程序的编译执行过程★★★★★★" class="headerlink" title="程序的编译执行过程★★★★★★"></a>程序的编译执行过程★★★★★★</h3><ol>
<li>第一步，预处理. 这一步处理 头文件、条件编译指令和宏定义。</li>
<li>第二步，编译. 将第一步产生的文件连同其他源文件一起编译成汇编代码。</li>
<li>第三步，汇编。将第二步产生的汇编源码转换为 object file.</li>
<li>第四步，链接. 将第三步产生的一些object file 链接成一个可执行的文件。</li>
</ol>
<h3 id="知道c-中的符号重载吗？★★★"><a href="#知道c-中的符号重载吗？★★★" class="headerlink" title="*知道c++中的符号重载吗？★★★"></a>*知道c++中的符号重载吗？★★★</h3><p>C++的预定义运算符的操作对象是基本的内置数据类型，对自定义数据类型，结构体或者类无法操作。符号重载可以可以自定义运算符的操作对象和运算规则，满足对自定义数据类型的需求。</p>
<p>实质上，运算符重载就是函数重载，语法形式如下：</p>
<p>&lt;返回类型说明符&gt; operator &lt;运算符符号&gt;(&lt;参数表&gt;)</p>
<p>{</p>
<p>&lt;函数体&gt;</p>
<p>}</p>
<p>函数重载的话，需要操作对象中至少有一个是用户自定义类型，避免导致重载之后出现歧义。出自之外，不能违背原本的语法规则，不能修改运算符的优先级，不能创建新的运算符等等，总之不能使得原有的运算规则出现错乱。</p>
<p>参考CSDN：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lishuzhai/article/details/50781753">https://blog.csdn.net/lishuzhai/article/details/50781753</a></p>
<h3 id="C-中如何实现多态？★★★"><a href="#C-中如何实现多态？★★★" class="headerlink" title="C++中如何实现多态？★★★"></a>C++中如何实现多态？★★★</h3><p>有一对继承关系的两个类，这两个类里面都有一个函数且名字、参数、返回值均相同，然后我们通过调用函数来实现不同类对象完成不同的事件。</p>
<p>多态的前提：</p>
<p>1. 调用函数的对象必须是指针或者引用。</p>
<p>2. 被调用的函数必须是虚函数，且完成了虚函数的重写</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39412582/article/details/81628254?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164171428616780265456117%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164171428616780265456117&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2%5C~blog%5C~first_rank_ecpm_v1%5C~hot_rank-3-81628254.nonecase&utm_term=C++%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81&spm=1018.2226.3001.4450">https://blog.csdn.net/qq_39412582/article/details/81628254?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164171428616780265456117%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=164171428616780265456117&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2\~blog\~first_rank_ecpm_v1\~hot_rank-3-81628254.nonecase&amp;utm_term=C%2B%2B%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81&amp;spm=1018.2226.3001.4450</a></p>
<h3 id="java和c-和c的区别（准备下英文）★★★★★★"><a href="#java和c-和c的区别（准备下英文）★★★★★★" class="headerlink" title="*java和c++和c的区别（准备下英文）★★★★★★"></a>*java和c++和c的区别（准备下英文）★★★★★★</h3><p>参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42482896/article/details/93380006">https://blog.csdn.net/weixin_42482896/article/details/93380006</a></p>
<p>百度翻译+人工润色：</p>
<p>1. Java不能在类之外的地方定义全局变量，只能在一个类中定义静态变量来实现一个全局变量。</p>
<p>C&#x2F;C++可以直接在类之外定义全局变量。</p>
<p>Java can’t define global variables outside a class, it can only define static variables in a class as a global variable.</p>
<p>2. Java不支持C&#x2F;C++的goto语句，而是通过try、catch来代替C&#x2F;C++的goto来处理异常时控制。</p>
<p>Java doesn’t support “goto” statements of C&#x2F;C++, but uses try&#x2F;catch syntax instead of “goto” for exception control.</p>
<p>3. C&#x2F;C++可以通过指针进行内存地址操作，例如通过指针对某内存地址进行显式类型转换，而这种操作访问私有成员破坏了安全性。</p>
<p>Java对指针进行完全的控制，不能在程序中进行任何指针操作，Java中的数组作为类实现，解决了关于数组的很多C&#x2F;C++难以检查的错误。</p>
<p>C&#x2F;C++ can operate memory address through pointer. For Example, C&#x2F;C++ makes explicitly conversion to a memory address by pointer, which destroys the security of the program because it accesses private members. Java Controls pointer completely, and can not operate any pointer in the program. The array in Java is implemented as a class, which solves many errors about array which are difficult to check in c&#x2F;c++.</p>
<p>4. 在C语言中通过malloc和free函数分配和释放内存；C++中可以通过new和delete进行内存的分配和释放。在Java中通过new运算符分配内存，进行对象实例化，而分配内存时随着程序运行动态分配，且Java能够进行自动管理和自动垃圾回收，防止内存资源产生的操作错误和浪费。</p>
<p>In C language, malloc function and free function are used to allocate and release memory; In C + +, memory can be allocated and released by new and delete keywords. In Java, the new operator is used to allocate memory and instantiate objects, and the allocated memory is dynamically allocated with the running of the program. Java can automatically manage memory and recycle garbage, so as to prevent memory operation errors and memory waste.</p>
<p>5. C&#x2F;C++对于不同的平台，数据类型的长度不同，代码不可移植。Java对数据类型总是分配固定长度位数，保证平台无关性。</p>
<p>The length of data type of C&#x2F;C++ is different in different platforms, so the code is not portable. Java always allocates a fixed number of bits to data type to ensure platform independence.</p>
<p>6. C++可以通过指针进行任意类型的转换，Java在进行类型转换时会进行类型相容性检查，防止不安全的转换。</p>
<p>C++ can do any type conversion by pointer. Java will check the type compatibility to prevent unsafe conversion.</p>
<p>7. C&#x2F;C++中用头文件声明类的原型及全局变量、库函数，在大的系统中难以维护这些文件。Java不支持头文件，所有类成员的类型和访问权限都封装在一个类中，运行时系统对访问会进行控制防止对私有成员的操作；导入其他类要使用import语句。</p>
<p>In C&#x2F;C++, header files are used to declare class prototypes, global variables and library functions, which are diffcult to maintain in large systems. Java does not support header files. The types and access rights of all class members are encapsulated in one class. When the program is running, the system will control the access to prevent the operation of private members.</p>
<p>8. C++中的结构体和联合体所有成员都是共有的，这有一定的安全问题。Java中没有结构体和联合体，一切内容都封装在类中。</p>
<p>All members of C++ structure and union are public, so there are some security problems. There is no structure or union in Java, everything is encapsulated in class.</p>
<p>9. C++支持宏定义，Java不支持宏定义，而是通过final来声明一个常量，实现宏定义中常量的定义。</p>
<p>C + + supports macro definition. Java does not support macro definition, but declares a constant through the final keyword to realize the definition of constant equivalent to macro definition.</p>
<h3 id="Java的垃圾回收算法★★★"><a href="#Java的垃圾回收算法★★★" class="headerlink" title="Java的垃圾回收算法★★★"></a>Java的垃圾回收算法★★★</h3><h3 id="Jvm的内存管理★★★"><a href="#Jvm的内存管理★★★" class="headerlink" title="Jvm的内存管理★★★"></a>Jvm的内存管理★★★</h3><h3 id="全局变量是好是坏？★★"><a href="#全局变量是好是坏？★★" class="headerlink" title="全局变量是好是坏？★★"></a>全局变量是好是坏？★★</h3><h2 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h2><h3 id="泰勒展开和傅立叶变换的概念以及他们在计算机领域中的应用★★★★★★"><a href="#泰勒展开和傅立叶变换的概念以及他们在计算机领域中的应用★★★★★★" class="headerlink" title="*泰勒展开和傅立叶变换的概念以及他们在计算机领域中的应用★★★★★★"></a>*泰勒展开和傅立叶变换的概念以及他们在计算机领域中的应用★★★★★★</h3><p>为了便于研究复杂的函数，用多项式来近似表达函数可以简单地进行计算，而泰勒多项式就是用多项式近似函数的一种方法，函数在某一点处展开为泰勒多项式就是泰勒展开。</p>
<p>泰勒多项式在计算机领域是数值分析的理论基础之一，数值微积分的很多定理和结论都是由泰勒展开推导得出。</p>
<p>参考《同济第七版 高等数学 上册》 第137页泰勒公式</p>
<p>傅里叶变换和其逆变换是一对互逆的运算，是用于对函数进行变换的工具。傅里叶变换可以将时域的非周期连续信号，转换为频域的非周期连续信号。</p>
<p>傅里叶变换的用途：在信号处理上，可以轻松地滤掉特定频率成分的波；在求解微分方程上，可以让微分和积分在频率中变为乘法和除法；在计算机科学中，作为DFT算法的理论基础。</p>
<p>感兴趣可以参考：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/19763358">https://zhuanlan.zhihu.com/p/19763358</a></p>
<h3 id="傅里叶变换和傅里叶级数的区别★★★"><a href="#傅里叶变换和傅里叶级数的区别★★★" class="headerlink" title="*傅里叶变换和傅里叶级数的区别★★★"></a>*傅里叶变换和傅里叶级数的区别★★★</h3><p>傅里叶级数是一个函数的近似表达，是将一个函数通过三角函数系进行表达的表达式。傅里叶级数仍然是一个函数。傅里叶级数拥有三角和复数两种表达形式。</p>
<p>而傅里叶变换是“函数的函数”，是一个对函数进行变换，使其拥有不同的特性，从时域转换到频域的工具。傅里叶变换是从傅里叶级数的复数形式推导而来。</p>
<p>参考百度百科词条：“傅里叶变换”</p>
<h3 id="函数零点和极值点怎么求？★★★★★"><a href="#函数零点和极值点怎么求？★★★★★" class="headerlink" title="*函数零点和极值点怎么求？★★★★★"></a>*函数零点和极值点怎么求？★★★★★</h3><p>函数的零点求法：</p>
<p>首先是，解析解：令函数值等于0，然后解方程得到零点。</p>
<p>对于过于复杂无法求方程解的情况，使用数值方法：二分法、牛顿迭代法</p>
<p>极值点：</p>
<p>对函数求导，然后令导函数等于0，按照上述方法求导函数的零点即可，对于所得零点判断解的两端导函数值的符号，</p>
<p>若两端同号，所得的解是驻点而不是极值点，</p>
<p>若两端异号，就是极值点。</p>
<h3 id="判断两个无穷集合的大小，单射满射和双射的概念？★★★"><a href="#判断两个无穷集合的大小，单射满射和双射的概念？★★★" class="headerlink" title="*判断两个无穷集合的大小，单射满射和双射的概念？★★★"></a>*判断两个无穷集合的大小，单射满射和双射的概念？★★★</h3><p>判断无穷集合的大小要引入“势”的概念，在谈论这个问题之前，需要先说说双射的概念。有穷集合和无穷集合相比的差别。</p>
<p>首先是，满射和单射。若A到B的函数满足“任一值域B中的一个值都存在定义域A中唯一的值与之对应”，这个函数就是单射的，若函数满足值域为集合B，就称函数时满射的。</p>
<p>接着是，若函数既是单射的又是满射的，就称作函数是双射的，这意味着函数的定义域为集合A，值域为集合B，且是单调函数。例如直线方程y&#x3D;kx+b，是集合R-&gt;R的双射函数，例如函数y&#x3D;tanx是(0,1)-&gt;R的双射函数。</p>
<p>参考《离散数学 屈婉玲》137页</p>
<p>无穷集合的大小通过集合的势来衡量，若是一个集合的势小于自然数集的势“阿列夫零”，它就是有穷集。假如两个集合之间能够建立一一映射，那就是等势的，例如整数集、偶数集、有理数集都和自然数集等势，也就是一样大小。而实数集和它任一子集都是等势的，且大于自然数集。且康托定理指出，一个集合的幂集都大于当前集合。</p>
<h3 id="欧氏距离及常见距离公式的缺点？★★★★★"><a href="#欧氏距离及常见距离公式的缺点？★★★★★" class="headerlink" title="*欧氏距离及常见距离公式的缺点？★★★★★"></a>*欧氏距离及常见距离公式的缺点？★★★★★</h3><p>欧氏距离也就是n维空间中两点之间的线段长度。</p>
<p>1 欧氏距离的缺点在于，会受到数据尺度的影响而产生偏斜，需要对数据进行归一化后使用。</p>
<p>2 余弦相似距离缺点在于只考虑了数据的方向，而没考虑向量的大小，受到数据尺度的影响较大。</p>
<p>3 曼哈顿距离就是街道距离，缺点在于不够直观，并且距离不是最短距离。</p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Datawhale/article/details/113787498">https://blog.csdn.net/Datawhale/article/details/113787498</a></p>
<h3 id="最大似然估计是什么？★★★★★"><a href="#最大似然估计是什么？★★★★★" class="headerlink" title="*最大似然估计是什么？★★★★★"></a>*最大似然估计是什么？★★★★★</h3><p>该方法的直观想法就是，取到了某一样本值，那么就表明取到这一样本的概率较大，因此认为取使得这一样本值的概率最大的参数值比较合理。</p>
<p>操作方法就是，固定样本的观察值，在参数的取值空间中挑选使得似然函数在该样本值下达到最大值的参数，作为参数的估计值。</p>
<p>《概统 浙大第四版》152页</p>
<h3 id="梯度方向导数与梯度下降？★★★★★"><a href="#梯度方向导数与梯度下降？★★★★★" class="headerlink" title="*梯度方向导数与梯度下降？★★★★★"></a>*梯度方向导数与梯度下降？★★★★★</h3><p>方向导数：各个坐标轴的偏导数组成的向量，和方向向量的内积</p>
<p>梯度：就是各个偏导数组成的向量</p>
<p>《同济第七版高等数学下册》103页</p>
<p>梯度下降法：从函数的任一点开始，沿着该店梯度反方向运动一段距离，再沿新位置的梯度反方向运行一段距离，如此迭代一直超着函数下坡最陡的方向运动，以此运动到函数的近似极小点。</p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25387613">https://zhuanlan.zhihu.com/p/25387613</a></p>
<h3 id="复合函数求导公式？给出函数让求？★★"><a href="#复合函数求导公式？给出函数让求？★★" class="headerlink" title="*复合函数求导公式？给出函数让求？★★"></a>*复合函数求导公式？给出函数让求？★★</h3><p>首先是，复合函数的概念，复合函数就是多个函数构成的函数，它的求导法则就是“链式法则”，如果某个函数由复合函数表示，则该复合函数的求导可以用构成复合函数的各个函数的导数的乘积表示。</p>
<h3 id="导数和偏导数的区别？★★"><a href="#导数和偏导数的区别？★★" class="headerlink" title="*导数和偏导数的区别？★★"></a>*导数和偏导数的区别？★★</h3><p>导数是针对一元函数的概念，即函数f对自变量x的导函数，又称导数、微商。</p>
<p>而偏导数是针对多元函数来讲的，多元函数对某一个自变量的导函数称作偏导数。</p>
<h3 id="可导、可微、连续、可积之间的关系（一元函数-二元函数）★★★"><a href="#可导、可微、连续、可积之间的关系（一元函数-二元函数）★★★" class="headerlink" title="*可导、可微、连续、可积之间的关系（一元函数+二元函数）★★★"></a>*可导、可微、连续、可积之间的关系（一元函数+二元函数）★★★</h3><p>一元函数：</p>
<p>可微和可导互为充分必要条件，可导比连续，连续不一定可导，</p>
<p>连续必可积，可积不一定连续</p>
<p>二元函数：</p>
<p>可微必连续，连续不一定可微</p>
<p>若连续则二重极限存在，反之不成立</p>
<p>连续必可积，可积不一定连续。</p>
<p>参考资料：《高等数学解题方法技巧归纳 毛纲源 下册》《数学分析 华师大 上册》截图：</p>


<p>《数学分析》 截图</p>


<h3 id="三个中值定理的区别、联系和物理意义（罗尔、拉格朗日、柯西）★★★"><a href="#三个中值定理的区别、联系和物理意义（罗尔、拉格朗日、柯西）★★★" class="headerlink" title="*三个中值定理的区别、联系和物理意义（罗尔、拉格朗日、柯西）★★★"></a>*三个中值定理的区别、联系和物理意义（罗尔、拉格朗日、柯西）★★★</h3><p>参考知乎：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/47436090">https://zhuanlan.zhihu.com/p/47436090</a></p>
<p>罗尔中值定理：函数f(x)在闭区间连续，开区间可导，区间端点函数值相等，必存在一点导数值为0</p>
<p>拉格朗日中值定理：函数f(x)在闭区间连续，开区间可导，必存在一点导数值等于端点连线的斜率。</p>
<p>罗尔中值定理：函数f(x)和g(x)在闭区间连续，开区间可导，且任意一点g(x)导数值不为0，必存在一点，f(x)导函数和g(x)导函数的比值，等于两函数区间端点函数值之差的比值。</p>
<p>区别在于，罗尔定理要求区间端点函数值相等，拉格朗日中值定理则不要求。柯西中值定理关系到两个函数</p>
<p>联系在于，柯西中值定理当g(x)&#x3D;x的时候，退化为拉格朗日中值定理，拉格朗日中值定理的区间端点函数值相等的时候，退化为罗尔中值定理。</p>
<p>物理意义在于，罗尔定理表明往复运动的始终必存在某一时刻速度为0。拉格朗日中值定理表明一段物体从一个地方移动到另一个地方的始终，中间必有一点加速度为0。柯西中值定理表明一段曲线运动的过程中，必有一点速度方向和位移方向相同。</p>
<h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><h3 id="矩阵的秩-满秩代表什么？不满秩呢？★★★★★"><a href="#矩阵的秩-满秩代表什么？不满秩呢？★★★★★" class="headerlink" title="*矩阵的秩,满秩代表什么？不满秩呢？★★★★★"></a>*矩阵的秩,满秩代表什么？不满秩呢？★★★★★</h3><p>参考资料：《线性代数 成立波》56页</p>
<p>矩阵A的不等于零的子式的最高阶数称作矩阵A的秩。</p>
<p>一个秩为n的矩阵满秩意味着存在一个n阶子式不为0.</p>
<p>不满秩的话，假设其秩为r，意味着所有大于r阶的子式都为0.</p>
<h3 id="什么是线性相关？什么是线性无关？★★★★★"><a href="#什么是线性相关？什么是线性无关？★★★★★" class="headerlink" title="*什么是线性相关？什么是线性无关？★★★★★"></a>*什么是线性相关？什么是线性无关？★★★★★</h3><p>对于线性空间中的n个向量，假如存在n个常数使得这n个常数与n个向量对应乘积加合等于0，则称这n个向量线性相关，如果不存在这样的n个常数，称之为线性无关。</p>
<p>参考资料：《线性代数 成立波》65页</p>
<h3 id="什么是向量空间？线性空间？★★★★-0703赵轲"><a href="#什么是向量空间？线性空间？★★★★-0703赵轲" class="headerlink" title="*什么是向量空间？线性空间？★★★★(0703赵轲)"></a>*什么是向量空间？线性空间？★★★★(0703赵轲)</h3><p>所有n维向量构成的集合称为n维向量空间。</p>
<p>将n维向量空间抽象化，便引出线性空间的概念。定义集合V上的两种代数运算：加法和数乘。V中任意两向量之和与V中的一个向量gamma对应；V中任意向量和域K中的任一数lambda的数乘与V中的一个向量eta对应。</p>
<p>并且加法满足交换律、结合律、零元、逆元，数乘存在单位元、满足结合律，数乘关于加法满足分配律。</p>
<p>那么这个集合V就称作线性空间，又叫向量空间。V中的元素统称为“向量“。</p>
<p>参考资料：《线性代数与矩阵论 许以超》书不好找，直接放截图了</p>
<p>这里的“纯量积”其实就是数乘：常数乘向量（伸缩变换）</p>


<h3 id="什么是向量的基？★★★"><a href="#什么是向量的基？★★★" class="headerlink" title="*什么是向量的基？★★★"></a>*什么是向量的基？★★★</h3><p>在线性空间V中可以找到n个向量，这n个向量线性无关，并且线性空间V中的任意一个向量都和这n个向量线性相关，那么这n个向量就称作线性空间V的基。</p>
<p>参考资料：《线性代数与矩阵论 许以超》书不好找，直接放截图了</p>


<h3 id="什么是向量正交？什么是矩阵正交？★★"><a href="#什么是向量正交？什么是矩阵正交？★★" class="headerlink" title="*什么是向量正交？什么是矩阵正交？★★"></a>*什么是向量正交？什么是矩阵正交？★★</h3><p>正交向量组中，任意两个向量的数量积为0.</p>
<p>正交矩阵的每一列都是一个单位向量，并且任意两列求数量积都为0.</p>
<p>两个矩阵正交，表示这两个矩阵相乘结果为单位矩阵。</p>
<p>参考资料：《线性代数 成立波》118页</p>
<h3 id="高斯分布-正态分布-★★★★"><a href="#高斯分布-正态分布-★★★★" class="headerlink" title="*高斯分布(正态分布) ★★★★"></a>*高斯分布(正态分布) ★★★★</h3><p>一个随机变量如果是由大量微小、独立的随机因素的叠加结果，那么这个变量一般都可以认为服从正态分布。</p>
<p>正态分布曲线关于其均值点对称，标准差越大图像越扁平。</p>
<p>参考资料：《概率论与数理统计 茆诗松》截图</p>


<h3 id="线性方程组的解，Ax-x3D-b，Am×nAm×n分别为长矩阵和扁矩阵？怎么确定哪个解是最优解？★★★★"><a href="#线性方程组的解，Ax-x3D-b，Am×nAm×n分别为长矩阵和扁矩阵？怎么确定哪个解是最优解？★★★★" class="headerlink" title="线性方程组的解，Ax&#x3D;b，Am×nAm×n分别为长矩阵和扁矩阵？怎么确定哪个解是最优解？★★★★"></a>线性方程组的解，Ax&#x3D;b，Am×nAm×n分别为长矩阵和扁矩阵？怎么确定哪个解是最优解？★★★★</h3><h3 id="什么相似矩阵？什么是正定矩阵？★★★★"><a href="#什么相似矩阵？什么是正定矩阵？★★★★" class="headerlink" title="*什么相似矩阵？什么是正定矩阵？★★★★"></a>*什么相似矩阵？什么是正定矩阵？★★★★</h3><p>对于两个矩阵A、B，如果存在一个矩阵P，使得 矩阵P的逆 乘矩阵A 乘矩阵P 等于矩阵B，那么矩阵A相似于矩阵B。相似矩阵A和B它们的特征值相同。</p>
<p>参考资料：《线性代数 成立波》124页</p>
<p>假如一个实对称矩阵S对于任一n行1列的矩阵alpha都有 alpha的转置乘矩阵S乘alpha都大于0，则该矩阵正定。</p>
<p>参考资料：《线性代数与矩阵论 许以超》截图：</p>


<h3 id="矩阵范数（一阶二阶范数）★★★★"><a href="#矩阵范数（一阶二阶范数）★★★★" class="headerlink" title="*矩阵范数（一阶二阶范数）★★★★"></a>*矩阵范数（一阶二阶范数）★★★★</h3><p>矩阵范数是一个满足非负性、齐次性、三角不等式以及相容性的函数。</p>
<p>矩阵一范数就是矩阵所有元素取绝对值，然后求最大列和。</p>
<p>矩阵A的2范数就是“矩阵A的转置与矩阵A相乘所得矩阵”的最大特征值。</p>
<p>参考CSDN：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_28972529/article/details/113452038">https://blog.csdn.net/weixin_28972529/article/details/113452038</a></p>
<h3 id="矩阵的特征值与特征向量有什么关系？特征值特征向量的含义和作用？★★★★"><a href="#矩阵的特征值与特征向量有什么关系？特征值特征向量的含义和作用？★★★★" class="headerlink" title="*矩阵的特征值与特征向量有什么关系？特征值特征向量的含义和作用？★★★★"></a>*矩阵的特征值与特征向量有什么关系？特征值特征向量的含义和作用？★★★★</h3><p>矩阵的特征向量是这样的向量：矩阵作用于该向量后，向量保持方向不变，进行某一比例的伸缩变换，而这个比例就是特征值。</p>
<p>因此，特征值与特征向量的关系就是，特征向量与特征值进行数乘操作后所得的向量，和矩阵对该向量进行变换所得向量相同。</p>
<p>因此特征值的含义就是和矩阵具有同等变换效果的常数，而特征向量就是与矩阵作用之后保持方向不变的向量。</p>
<p>作用：特征值可以用于奇异值分解、主成分分析。可以用于谱分解、特征值分解。</p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21874816/answer/181864044">https://www.zhihu.com/question/21874816/answer/181864044</a></p>
<h3 id="矩阵运算下Ax-x3D-b中什么情况下x有解★★"><a href="#矩阵运算下Ax-x3D-b中什么情况下x有解★★" class="headerlink" title="*矩阵运算下Ax&#x3D;b中什么情况下x有解★★"></a>*矩阵运算下Ax&#x3D;b中什么情况下x有解★★</h3><p>线性方程组Ax&#x3D;b的充要条件是，系数矩阵A和增广矩阵B的秩相等。</p>
<p>假如线性方程组Ax&#x3D;b有解，那么在m&gt;&#x3D;r&#x3D;rank(A)的情况下它的通解依赖于m-r个独立参数，当m&#x3D;r时具有唯一解。</p>
<p>m个未知数，n个线性方程的齐次线性方程组必有零解，齐次线性方程组有非零解的充要条件是其系数矩阵A的秩&lt;m，而且通解有无穷多个解，依赖于m-r个独立参数。</p>
<p>齐次线性方程组有m-r组解，这m-r组解就是齐次线性方程组的基础解系。</p>
<p>非齐次线性方程组解的通解由相伴的齐次线性方程组的通解和非齐次线性方程组的一个特解组成。</p>
<h3 id="什么是张量？张量与矩阵有什么区别？★★"><a href="#什么是张量？张量与矩阵有什么区别？★★" class="headerlink" title="*什么是张量？张量与矩阵有什么区别？★★"></a>*什么是张量？张量与矩阵有什么区别？★★</h3><p>张量可以看作标量、向量、矩阵的推广，矩阵是二阶张量，而标量是0阶张量、矢量是1阶张量。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22189865">https://www.zhihu.com/question/22189865</a></p>
<h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><h3 id="变量与随机变量有什么区别？★★"><a href="#变量与随机变量有什么区别？★★" class="headerlink" title="*变量与随机变量有什么区别？★★"></a>*变量与随机变量有什么区别？★★</h3><p>随机变量能够描述随机现象，并通过概率统计的方法进行分析。而变量通常用来描述确定性的现象。</p>
<p>变量的取值是固定唯一的，并且取值范围是整个定义域。而随机变量取值有多个，而且每个取值都有一定的概率。在试验之前，随机变量的取值是不能预知的，试验之后，随机变量的取值范围就是这次试验的样本空间。</p>
<p>参考《概率论与数理统计 浙大第四版》31页</p>
<h3 id="随机变量与概率分布有什么联系？★★"><a href="#随机变量与概率分布有什么联系？★★" class="headerlink" title="*随机变量与概率分布有什么联系？★★"></a>*随机变量与概率分布有什么联系？★★</h3><p>随机变量的分布函数表述了随机变量的统计规律性，已知一个随机变量的分布函数就可以得知该随机变量落在某一区间的概率。</p>
<p>参考《概率统计 浙大第四版》 39页</p>
<h3 id="联合概率与边缘概率有什么区别？有什么联系？★★"><a href="#联合概率与边缘概率有什么区别？有什么联系？★★" class="headerlink" title="*联合概率与边缘概率有什么区别？有什么联系？★★"></a>*联合概率与边缘概率有什么区别？有什么联系？★★</h3><p>区别：</p>
<p>联合概率是基于两个随机变量及其相互作用的样本空间的概率。</p>
<p>边缘概率是多维随机变量的样本空间中，某一个或多个随机变量构成的子空间的概率。</p>
<p>联系：</p>
<p>在联合概率的基础上固定若干个随机变量的取值便得到边缘概率。</p>
<p>参考资料《浙大第四版》60页</p>
<h3 id="常见的概率分布有哪些？有什么应用场景？请举例说明★★"><a href="#常见的概率分布有哪些？有什么应用场景？请举例说明★★" class="headerlink" title="*常见的概率分布有哪些？有什么应用场景？请举例说明★★"></a>*常见的概率分布有哪些？有什么应用场景？请举例说明★★</h3><p>二项分布：常用于检查产品合格率、色盲率调查等等</p>
<p>两点分别：比赛胜率估计</p>
<p>泊松分布：常用于一天内到达顾客数、铸件上的砂眼数、一天内电路受到电磁波干扰次数等等</p>
<p>超几何分布：用于进行有限总体中进行不放回抽样。</p>
<p>几何分布：一次伯努利试验中事件A首次出现时的试验次数。例如产品不合格率调查。</p>
<p>正态分布：主要应用于统计理论、误差理论等等</p>
<p>指数分布：常用于随即服务系统、寿命估计、排队论等等</p>
<p>参考《概率论与数理统计》</p>
<h3 id="大数定律和中心极限定理的意义与作用（切比雪夫大数定律）★★★★"><a href="#大数定律和中心极限定理的意义与作用（切比雪夫大数定律）★★★★" class="headerlink" title="*大数定律和中心极限定理的意义与作用（切比雪夫大数定律）★★★★"></a>*大数定律和中心极限定理的意义与作用（切比雪夫大数定律）★★★★</h3><p>浙大第四版：</p>
<p>辛钦大数定理：说明了对于独立同分布且具有均值u的n个随机变量，当n很大的时候它们的算术平均值依概率收敛于u。</p>
<p>伯努利大数定律表明只要随机试验的次数n充分大，那么事件A频率和概率的绝对偏差很小，说明在实际应用中，试验次数很大的时候可以用事件的频率来替代事件的概率。</p>
<p>参考《浙大第四版》120页</p>
<p>独立同分布的中心极限定理：均值为u，标准差为sigma的独立同分布的n个随机变量之和的标准化变量在n充分大的时候近似服从于标准正态分布。</p>
<p>由此推论均值为u标准差为sigma的独立同分布的n个随机变量的算术平均值，当n充分大的时候近似服从均值为u方差为sigma^2&#x2F;n的正态分布。</p>
<p>李雅普诺夫定理：独立的n个随机变量，其随机变量之和的标准化变量很大的时候近似服从与标准正态分布。</p>
<p>棣莫弗-拉普拉斯定理表明正态分布是二项分布的极限分布。</p>
<p>参考《浙大第四版》121页</p>
<h3 id="正态分布的和还是正态分布吗，正态分布性质与独立同分布）★★★★★"><a href="#正态分布的和还是正态分布吗，正态分布性质与独立同分布）★★★★★" class="headerlink" title="*正态分布的和还是正态分布吗，正态分布性质与独立同分布）★★★★★"></a>*正态分布的和还是正态分布吗，正态分布性质与独立同分布）★★★★★</h3><p>彼此独立的正态分布的和仍然是正态分布，这叫做正态分布的可加性。</p>
<p>正态分布的可加性就是：如果多个随机变量分别服从不同的正态分布，如果这些随机变量彼此独立，那么这些随机变量的和也服从正态分布。</p>
<p>事实上，独立同分布的正态分布随机变量具有线性性质，证明过程参考下图：</p>


<h3 id="什么是假设和检验？★★"><a href="#什么是假设和检验？★★" class="headerlink" title="*什么是假设和检验？★★"></a>*什么是假设和检验？★★</h3><p>假设检验问题关注于通过试验来判断是否参数theta是否落在参数空间的某一个子集或者其补集里面。在总体分布函数未知或者只知其形式不知其参数的情况下，为了推断某些参数，提出关于总体的假设，然后通过样本来决定对所做出的假设接受或者拒绝。假设检验就是做出这一决策的过程。</p>
<p>假设就是关于总体的参数的参数空间的一部分，包括原假设和备择假设。这两个假设互补。而检验就是对于假设检验问题满足某一显著性水平的概率的不等式。通过这一不等式来判断某一估计是否满足需求。</p>
<p>参考1《Probability and statistics》</p>


<p>参考2《概率论与数理统计 茆诗松》</p>


<h3 id="数学期望和方差？★★"><a href="#数学期望和方差？★★" class="headerlink" title="*数学期望和方差？★★"></a>*数学期望和方差？★★</h3><p>随机变量的数学期望就是随机变量每个取值于该取值的概率的乘积的累加和。它描述了随机变量的集中特性。</p>
<p>而随机变量的方差描述了随机变量的波动特性，即离散特性，其定义是随机变量的每个取值和数学期望的偏差平方和与该取值的概率的乘积的连加和。</p>
<p>参考：根据公式的理解</p>
<h3 id="独立和不相关的区别？★★"><a href="#独立和不相关的区别？★★" class="headerlink" title="*独立和不相关的区别？★★"></a>*独立和不相关的区别？★★</h3><p>见下图，概括就是：独立一定不相关，而不相关不一定独立。例如线性不相关的随机变量可能是非线性相关。最常见的例子就是Logistics函数或者二次函数，自变量和因变量计算所得相关系数很低，但是是互相依赖的变量。</p>


<h3 id="概率密度函数？★★"><a href="#概率密度函数？★★" class="headerlink" title="*概率密度函数？★★"></a>*概率密度函数？★★</h3><p>连续随机变量的一切取值充满整个样本空间，而这其中有无穷个不可列的实数，因此无法采用分布列表示，采用概率密度函数表示。</p>
<p>概率密度函数不是概率，乘以区间长度微元后就表示概率的近似值，而概率密度函数在一段区间上的积分就是随机变量X在这段区间上取值的概率。因此，如果存在实数轴上的一个非负可积函数使得对任意实数x都有“这个函数从负无穷到x的积分值就是随机变量X的分布函数F(x)”，这个函数称为随机变量X的概率密度函数。</p>
<p>参考《概率统计 茆诗松》69页</p>
<h3 id="举几个泊松分布的例子★★"><a href="#举几个泊松分布的例子★★" class="headerlink" title="*举几个泊松分布的例子★★"></a>*举几个泊松分布的例子★★</h3><p>参考《概率论与数理统计 茆诗松》</p>


<h3 id="说一下全概率公式和贝叶斯公式★★★★★★★"><a href="#说一下全概率公式和贝叶斯公式★★★★★★★" class="headerlink" title="*说一下全概率公式和贝叶斯公式★★★★★★★"></a>*说一下全概率公式和贝叶斯公式★★★★★★★</h3><p>全概率就是表示达到某个目的，有多种方式（或者造成某种结果，有多种原因），问达到目的的概率是多少（造成这种结果的概率是多少）？</p>
<p>全概率公式：</p>
<p>设事件是一个完备事件组，则对于任意一个事件Ｃ，若有如下公式成立：</p>


<p>那么就称这个公式为全概率公式。</p>
<p><strong>贝叶斯公式就是当已知结果，问导致这个结果的第i原因的可能性是多少？执果索因！</strong></p>
<p>贝叶斯公式：</p>
<p>在已知条件概率和全概率的基础上，贝叶斯公式是很容易计算的：</p>






<h3 id="解释下相关系数、协方差、相关系数或协方差为0的时候能否说明两个分布无关？"><a href="#解释下相关系数、协方差、相关系数或协方差为0的时候能否说明两个分布无关？" class="headerlink" title="*解释下相关系数、协方差、相关系数或协方差为0的时候能否说明两个分布无关？"></a>*解释下相关系数、协方差、相关系数或协方差为0的时候能否说明两个分布无关？</h3><p>所谓随机变量X和Y的协方差就是“X的偏差和Y的偏差乘积的数学期望”。若协方差大于零，表示这两个随机变量呈正相关关系，若协方差小于零表示两个随机变量呈负相关关系。而协方差等于零表示不“线性相关”。</p>
<p>相关系数可以看作标准化的协方差，它没有量纲，取值范围在[0, 1]。</p>
<p>取值为0不能说明两个分布无关，而是“线性不相关”，有可能存在非线性的相关关系，也有可能取值毫无关联。</p>
<h3 id="若干正态分布相加、相乘后得到的分布分别是什么？★★★"><a href="#若干正态分布相加、相乘后得到的分布分别是什么？★★★" class="headerlink" title="*若干正态分布相加、相乘后得到的分布分别是什么？★★★"></a>*若干正态分布相加、相乘后得到的分布分别是什么？★★★</h3><p>相加参考6.</p>
<p>相乘：来自知乎：</p>
<p>正态分布相乘之后，服从的分布为：正态分布乘以常数</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/46458824/answer/1658826258">https://www.zhihu.com/question/46458824/answer/1658826258</a></p>
<p>知乎截图内容：</p>


<h3 id="假如有一枚不均匀的-硬币，抛正面的几率是p，抛反面是1-p，请问如何做才能得出1-x2F-2？★★★"><a href="#假如有一枚不均匀的-硬币，抛正面的几率是p，抛反面是1-p，请问如何做才能得出1-x2F-2？★★★" class="headerlink" title="假如有一枚不均匀的 硬币，抛正面的几率是p，抛反面是1-p，请问如何做才能得出1&#x2F;2？★★★"></a>假如有一枚不均匀的 硬币，抛正面的几率是p，抛反面是1-p，请问如何做才能得出1&#x2F;2？★★★</h3><h3 id="机器学习为什么要使用概率？★★"><a href="#机器学习为什么要使用概率？★★" class="headerlink" title="*机器学习为什么要使用概率？★★"></a>*机器学习为什么要使用概率？★★</h3><p>机器学习的是由数据驱动的方法，它的学习对象是数据，从数据出发提取数据特征抽象出数据模型又从数据中发现知识，最后回到数据的分析和预测中去。</p>
<p>机器学习算法的设计通常依赖于对数据的概率假设，如果不理解相关的数学知识，那么久无法真正理解算法的精髓。并且，机器学习模型的训练和预测过程的评价指标——模型误差，其本身就是概率的形式。</p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/285189181">https://www.zhihu.com/question/285189181</a></p>
<h2 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h2><h3 id="解释下什么是群环域？★★-赵轲"><a href="#解释下什么是群环域？★★-赵轲" class="headerlink" title="*解释下什么是群环域？★★(赵轲)"></a>*解释下什么是群环域？★★(赵轲)</h3><p>由一个非空集合S和该集合上的k个运算组成的系统称作代数系统。群就是一个特殊的代数系统，在这个代数系统的运算是可结合的二元运算，并且该系统中存在单位元和逆元。</p>
<p>环：若一个代数系统存在两个运算1和运算2，集合R关于运算1构成交换群，关于运算2构成半群，并且运算2关于运算1适合分配律。则集合R和这两个运算构成的代数系统称作环。其中称运算1为加法，运算2为乘法。</p>
<p>域：如果一个环的乘法运算符合交换律，并且关于乘法运算存在单位元，并且对于环中的任意两个非零元素执行乘法操作结果均不为0，那么这个环R构成一个域。</p>
<p>参考：《离散数学 屈婉玲》181页</p>
<h3 id="你知道哪些离散型随机变量-★"><a href="#你知道哪些离散型随机变量-★" class="headerlink" title="*你知道哪些离散型随机变量 ★"></a>*你知道哪些离散型随机变量 ★</h3><p>0-1分布：用于估计样本空间只有0、1两个值的独立重复实验的概率。</p>
<p>二项分布：常用于样本空间只有两个值的独立重复实验地概率计算。</p>
<p>泊松分布：常用于服务系统，预测某一天某时段某服务台到达人数</p>
<p>几何分布：在n次伯努利试验中，试验k次才得到第一次成功的机率。</p>
<p>超几何分布：不放回抽样的概率计算。</p>
<p>参考《浙大第四版 概率统计》</p>
<h3 id="哈密顿图、欧拉图有什么区别，怎么求？★★★"><a href="#哈密顿图、欧拉图有什么区别，怎么求？★★★" class="headerlink" title="*哈密顿图、欧拉图有什么区别，怎么求？★★★"></a>*哈密顿图、欧拉图有什么区别，怎么求？★★★</h3><p>所谓的欧拉图就是包含欧拉回路的图，欧拉回路就是能够通过图中所有的边一次且仅一次就通过所有顶点的回路。也就是所谓的“能够一笔画的图”</p>
<p>而哈密顿图是经过所有顶点一次且仅一次。</p>
<p>欧拉图可以求出精确解，教材提到了两种算法：</p>
<p><strong>Hierholzier算法：</strong></p>
<p>中心思想：欧拉图是由一个或多个回路拼接而成，只要把图中的每个回路的路径拼接起来，就可以遍历这个欧拉图。</p>
<p>主要步骤：从一个可能的顶点出发，进行深度优先搜索，但是每次沿着辅助边从某个顶点移动到另外一个顶点的时候，都需要删除这个辅助边。如果没有可以移动的路径，则将所在结点加入到栈中并返回。</p>
<p>1. 任选起始点并记录</p>
<p>2. 从起点出发到达任一临接点，到达的点成为新的起点，删除经过的边</p>
<p>3. 重复步骤2直到回到初始点，此时到达步骤1，将本次记录的点集合与上次记录的点集合拼接。若本图成为空图，到达步骤4.</p>
<p>4. 输出所有记录点。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40493829/article/details/108253637">https://blog.csdn.net/qq_40493829/article/details/108253637</a></p>
<p><strong>Fleury算法：</strong></p>
<p>输入一个欧拉图</p>
<p>任取一个顶点，假设路径Pi&#x3D;v0e1v1e2…eivi已经行遍</p>
<p>然后开始在E(G)-{e1, e2, …, ei}中寻找邻接边，找边的规则为：</p>
<p>1. 和当前顶点相关联。</p>
<p>2. 除非无边可选，否则不选E(G)-{e1,e2,…,ei}中的桥</p>
<p>当已经无边可选了，算法停止，Pm&#x3D;v0e1v1e2v2…emvm(vm&#x3D;v0)为G中一条欧拉回路。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/guomutian911/article/details/42105127">https://blog.csdn.net/guomutian911/article/details/42105127</a></p>
<p>而哈密顿图，则至今没有一个高效地求出经确解地方法，暴力求解的话，这属于是NP-Hard问题，实际应用中，通常使用启发式搜索算法求出一个近似精确解，常用方法有：</p>
<p>禁忌搜索算法、蚁群算法、遗传算法等等。（CSDN可搜）</p>
<h3 id="欧拉图和欧拉函数★★★"><a href="#欧拉图和欧拉函数★★★" class="headerlink" title="*欧拉图和欧拉函数★★★"></a>*欧拉图和欧拉函数★★★</h3><p>所谓的欧拉图就是包含欧拉回路的图，欧拉回路就是能够通过图中所有的边一次且仅一次就通过所有顶点的回路。也就是所谓的“能够一笔画的图”</p>
<p>参考《离散数学 屈婉玲 316页》</p>
<p><strong>数论的欧拉函数</strong>：和欧拉图无关，欧拉函数其实是初等数论的重要内容</p>
<p>其定义为：对自然数n，从0到n-1中与n互素的数的个数就是欧拉函数phi(n)。</p>
<p>参考：《离散数学 屈婉玲》</p>
<p>99页计算方法证明 382页应用</p>
<h3 id="哈夫曼树的定义，怎么求，应用？★"><a href="#哈夫曼树的定义，怎么求，应用？★" class="headerlink" title="*哈夫曼树的定义，怎么求，应用？★"></a>*哈夫曼树的定义，怎么求，应用？★</h3><p>Haffuman树：又称最优二叉树，假设给定有n个权值的集合，且二叉树T有n个叶子节点，将权值赋值给n个叶子节点，定义二叉树的带权路径长度为权重和对应叶子节点的路径长度乘积之和，而最优二叉树就是一组使得带权路径长度最短的权重配置方案作为权重的二叉树。</p>
<p>Huffman树的基本思想就是：带权路径长度最小的二叉树应该是权值大的外结点离根节点最近的扩充二叉树。</p>
<p>计算方法：用n个权重各创建一个平凡树，并赋该树根以权值，然后开始循环</p>
<p>循环内容：</p>
<ol>
<li>选择树根权值最小的两个树</li>
<li>创建一个新树，左右子树分别是这两个权值最小的树</li>
<li>新树的树根权值为两树权值之和</li>
<li>删去原来的两个树，添加新树</li>
<li>判断，如果只剩一个树就跳出循环</li>
</ol>
<p>应用：编码设计：Huffman编码、决策算法、算法设计等。</p>
<p>参考《数据结构 殷人昆 第二版》241页</p>
<h3 id="无向图的定义★"><a href="#无向图的定义★" class="headerlink" title="*无向图的定义★"></a>*无向图的定义★</h3><p>无向图是一个有序二元组，二元组由一个非空有穷集——顶点集，和一个由顶点集的有序积的有穷多重子集——边集所构成。无向图的边都是无序的，表示顶点和顶点的连接关系。不同于有向边只表示单向关系。</p>
<p>参考《离散数学 屈婉玲》273页</p>
<h3 id="解释下等价关系和等价类★★"><a href="#解释下等价关系和等价类★★" class="headerlink" title="*解释下等价关系和等价类★★"></a>*解释下等价关系和等价类★★</h3><p>如果非空集合A上的一个关系R，同时满足自反性、对称性和传递性，就称R为集合A上的等价关系。</p>
<p>等价类就是集合A中所有与x等价的元素构成的集合。</p>
<p>参考：《离散数学 屈婉玲》123页</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>http://yoursite.com/2023/04/12/计算机面试专业课资料/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月12日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/shizhuofan.GitHub.io/2023/03/29/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85gitlab/" title="">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/shizhuofan.GitHub.io/js/events.js" ></script>
<script  src="/shizhuofan.GitHub.io/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/shizhuofan.GitHub.io/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/shizhuofan.GitHub.io/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/shizhuofan.GitHub.io/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
