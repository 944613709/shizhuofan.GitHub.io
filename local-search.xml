<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9D%A2%E8%AF%95%E4%B8%93%E4%B8%9A%E8%AF%BE%E8%B5%84%E6%96%99/"/>
    <url>/shizhuofan.GitHub.io/2023/04/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9D%A2%E8%AF%95%E4%B8%93%E4%B8%9A%E8%AF%BE%E8%B5%84%E6%96%99/</url>
    
    <content type="html"><![CDATA[<h1 id="面试资料"><a href="#面试资料" class="headerlink" title="面试资料"></a>面试资料</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="O-n-的大O是什么意思？什么是时间复杂度-★★★"><a href="#O-n-的大O是什么意思？什么是时间复杂度-★★★" class="headerlink" title="*O(n)的大O是什么意思？什么是时间复杂度? ★★★"></a>*O(n)的大O是什么意思？什么是时间复杂度? ★★★</h3><p>O(n)这个大O表示的是最坏情况下的时间复杂度，时间复杂度是指执行算法所需要的计算工作量，对程序规模得一个描述。</p><h3 id="线性存储结构和链式存储结构的优点★★★"><a href="#线性存储结构和链式存储结构的优点★★★" class="headerlink" title="*线性存储结构和链式存储结构的优点★★★"></a>*线性存储结构和链式存储结构的优点★★★</h3><p>线性存储结构地址空间连接，可随机访问，但是顺序存储的缺点是删除，插入操作需要花费很多时间在移动元素上</p><p>链式存储结构不要求逻辑上相邻的元素在物理位置上是相邻，但也同时失去了顺序表可随机存取的优点，但方便插入与删除</p><h3 id="解释一下顺序存储与链式存储★★★"><a href="#解释一下顺序存储与链式存储★★★" class="headerlink" title="*解释一下顺序存储与链式存储★★★"></a>*解释一下顺序存储与链式存储★★★</h3><p>顺序存储结构吧逻辑上相邻的元素存放到物理位置上相邻的存储单元中，数据元素之间的逻辑关系由存储单元的邻接位置关系来体现。</p><p>链接存储方法不要求逻辑上相邻的元素在物理位置上也相邻，元素之间的逻辑关系由附加的指针指示。</p><p>参考：《数据结构 殷人昆 第二版》第6页</p><h3 id="头指针和头结点的区别？★★"><a href="#头指针和头结点的区别？★★" class="headerlink" title="*头指针和头结点的区别？★★"></a>*头指针和头结点的区别？★★</h3><p>以单链表为例，</p><p>头指针就是指向链表第一个结点的指针，链表的第一个结点的地址可以通过链表的头指针找到，对单链表中任一元素的访问必须首先根据头指针找到第一个结点。</p><p>参考：《数据结构 殷人昆 第二版》第53页</p><p>而头结点是一个附加结点，头结点的data域可以不存储任何信息，也可以存放特殊标志或表长，只要表存在就必须至少有一个头结点。头结点的存在可以优化单链表的增删操作，使得对于空表或者在非空表第一个结点之前插入不用作为特殊情况专门处理，而是使用通用方法。</p><p>参考：《数据结构 殷人昆 第二版》第59页</p><h3 id="栈和队列的区别和内存结构★★★"><a href="#栈和队列的区别和内存结构★★★" class="headerlink" title="*栈和队列的区别和内存结构★★★"></a>*栈和队列的区别和内存结构★★★</h3><p>栈的定义是只允许在表的末端进行插入和删除的线性表，允许插入和删除的一端叫做栈顶，不允许插入和删除的一端叫做栈底。</p><p>栈的存储结构通常分为基于数组的存储表示和顺序存储结构和基于链表的链式存储结构，</p><p>顺序栈的内存结构：存放栈中元素的数组、栈顶指针、最大容纳元素个数</p><p>链式栈的内存结构：栈顶指针</p><p>参考：《数据结构 殷人昆 第二版》第89页</p><p>队列的定义是：只允许在表的一端插入，在另一端删除的线性表。允许插入元素的一端称为队尾，允许删除的一端称为队首。</p><p>队列的存储结构通常分为基于数组的存储表示和基于链表的存储表示。</p><p>顺序存储结构利用一个一维数组作为存储结构，并设置头指针和尾指针两个指针来指示队首和队尾的位置。</p><p>链式队列由队首指针和队尾指针构成。</p><h3 id="有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？★★"><a href="#有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？★★" class="headerlink" title="有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？★★"></a>有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？★★</h3><p>(p-f+n)%n</p><h3 id="如何区分循环队列是队空还是队满？★★★"><a href="#如何区分循环队列是队空还是队满？★★★" class="headerlink" title="如何区分循环队列是队空还是队满？★★★"></a>如何区分循环队列是队空还是队满？★★★</h3><p>front表示队头指针（指向队列内首元素）</p><p>rear表示队尾指针（指向队列内尾元素的下一个位置）</p><p>m表示队列的容量（包括那个留空的位置）</p><p><strong>队空：front&#x3D;rear</strong></p><p><strong></strong></p><p><strong>队满：front&#x3D;(rear+1)%m</strong></p><p><a href="https://blog.csdn.net/tiansheshouzuo/article/details/86572825?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164171302716780261911139%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164171302716780261911139&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2%5C~all%5C~sobaiduend%5C~default-2-86572825.pc_search_result_control_group&utm_term=%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA%E5%92%8C%E9%98%9F%E6%BB%A1&spm=1018.2226.3001.4187">https://blog.csdn.net/tiansheshouzuo/article/details/86572825?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164171302716780261911139%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164171302716780261911139&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2\~all\~sobaiduend\~default-2-86572825.pc_search_result_control_group&amp;utm_term=%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA%E5%92%8C%E9%98%9F%E6%BB%A1&amp;spm=1018.2226.3001.4187</a></p><h3 id="堆、大顶堆、小顶堆实现及应用-★★"><a href="#堆、大顶堆、小顶堆实现及应用-★★" class="headerlink" title="堆、大顶堆、小顶堆实现及应用 ★★"></a>堆、大顶堆、小顶堆实现及应用 ★★</h3><h3 id="哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？★★★★"><a href="#哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？★★★★" class="headerlink" title="哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？★★★★"></a>哈希表的概念、构造方法、哈希有几种类型？哈希冲突的解决办法？★★★★</h3><p><a href="https://www.nowcoder.com/tutorial/93/e7dc954667634630b6c1e93ac87dd271">https://www.nowcoder.com/tutorial/93/e7dc954667634630b6c1e93ac87dd271</a></p><h3 id="判断链表是否有环（非常重要！）★★★★★★★"><a href="#判断链表是否有环（非常重要！）★★★★★★★" class="headerlink" title="*判断链表是否有环（非常重要！）★★★★★★★"></a>*判断链表是否有环（非常重要！）★★★★★★★</h3><p>快慢指针：从头开始设置两个指针，快指针每次走2步，慢指针每次走1步，如果快指针先碰到尾，则无环，否则两个指针之后一定会重合，则有环。（leetcode原题)</p><h3 id="平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造★★★"><a href="#平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造★★★" class="headerlink" title="*平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造★★★"></a>*平衡二叉树、二叉排序树、完全二叉树、二叉搜索树的区别及如何构造★★★</h3><p>完全二叉树的每一个节点都与高度为k的满二叉树的1-n编号一一对应。</p><p>具体参考：《数据结构 殷人昆 第二版》220页</p><p>二叉搜索树和二叉排序树是一个东西。</p><p>二叉排序树每一个节点都是用于排序的关键码，左子树所有节点关键码都小于根节点的关键码，右子树的所有关键码都大于根节点的关键码，其中，左右子树都是二叉树。对一棵二叉排序树进行中序遍历就可以得到关键码从小到大的排列。</p><p>二叉排序树的构造方法主要执行插入操作，进行插入之前必须先检查是否该节点的关键码已经在树中存在，也就是要先查找，假如查找成功，不执行任何操作，假如搜索不成功，就在搜索停止的地方添加新元素。</p><p>具体参考：《数据结构 殷人昆 第二版》309页</p><p>平衡二叉树是一种二叉搜索树，它的左右子树高度差的绝对值不超过1。构造一棵平衡二叉树仍然是通过插入节点的方式，每插入一个结点，都应该检查平衡因子，并通过旋转操作使之平衡化。</p><p>具体参考：《数据结构 殷人昆 第二版》321页</p><h3 id="如何由遍历序列构造一颗二叉树？-x2F-已知先序序列和后序序列能否重现二叉树？（笔试经常考）★★★"><a href="#如何由遍历序列构造一颗二叉树？-x2F-已知先序序列和后序序列能否重现二叉树？（笔试经常考）★★★" class="headerlink" title="*如何由遍历序列构造一颗二叉树？&#x2F;已知先序序列和后序序列能否重现二叉树？（笔试经常考）★★★"></a>*如何由遍历序列构造一颗二叉树？&#x2F;已知先序序列和后序序列能否重现二叉树？（笔试经常考）★★★</h3><p>若是中序和先序或者中序和后序，则可。</p><p>首先先序中我们可以锁定当前第一个点为根，中序中找到这个点，去把子树分割成左子树和右子树两个部分，再依次递归下去即可</p><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><p>先序和中序不能重现一颗唯一的二叉树。但有可能找出满足此的二叉树。</p><h3 id="B树是什么-在数据库中有什么应用？（B数和B-树的区别）★★★"><a href="#B树是什么-在数据库中有什么应用？（B数和B-树的区别）★★★" class="headerlink" title="*B树是什么?在数据库中有什么应用？（B数和B+树的区别）★★★"></a>*B树是什么?在数据库中有什么应用？（B数和B+树的区别）★★★</h3><p>在数据库查询中，以树存储数据。树有多少层，就意味着要读多少次磁盘IO。所以树的高度越矮，就意味着查询数据时，需要读IO的次数就越少。（众所周知，读IO是一件费事的操作）当数据量大的时候，用AVL树存的话，就算AVL是平衡树，但是也扛不住数据量大，数据量大，AVL树的树高肯定很高，那么读取数据的IO次数也会多。B树的一个结点可以装多个值，读取时，是把整个结点读到内存，然后在内存中，对结点的值进行处理，在内存中处理速度肯定比磁盘快。所以只要树的高度低，IO少，就能够提升查询效率，这是B树的好处之一。</p><p>B树的缺点是：不利于范围查找(区间查找)，如果要找 0~100的索引值，那么B树需要多次从根结点开始逐个查找。</p><p>B+树和B树最大的不同是：B+树内部有两种结点，一种是索引结点，一种是叶子结点。B+树的索引结点并不会保存记录，只用于索引，所有的数据都保存在B+树的叶子结点中。而B树则是所有结点都会保存数据。</p><p>B+树的叶子结点都会被连成一条链表。叶子本身按索引值的大小从小到大进行排序。即这条链表是 从小到大的。因此可以直接通过遍历链表实现范围查找。</p><p>参考CSDN：<a href="https://blog.csdn.net/chai471793/article/details/99563704">https://blog.csdn.net/chai471793/article/details/99563704</a></p><h3 id="红黑树原理是什么？建立过程？★★★"><a href="#红黑树原理是什么？建立过程？★★★" class="headerlink" title="红黑树原理是什么？建立过程？★★★"></a>红黑树原理是什么？建立过程？★★★</h3><h3 id="二分搜索和单纯的线性搜索的区别-x2F-时间复杂度★★★"><a href="#二分搜索和单纯的线性搜索的区别-x2F-时间复杂度★★★" class="headerlink" title="二分搜索和单纯的线性搜索的区别&#x2F;时间复杂度★★★"></a>二分搜索和单纯的线性搜索的区别&#x2F;时间复杂度★★★</h3><h3 id="插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）★★★★★★"><a href="#插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）★★★★★★" class="headerlink" title="*插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）★★★★★★"></a>*插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？（排序必考）★★★★★★</h3><p>基本思想参考：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p><p>冒泡排序最坏情况：如4,3,2,1升序排序，需要比较 3+2+1&#x3D;6&#x3D;4*3&#x2F;2 次</p><p>快速排序最坏情况：已经排好顺序的（包括升序、降序、所有元素都一样）</p><h3 id="最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？★★★★★★★"><a href="#最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？★★★★★★★" class="headerlink" title="*最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？★★★★★★★"></a>*最小生成树和最短路径用什么算法来实现？（迪杰斯特拉、弗洛依德、普利姆、克鲁斯卡尔）算法的基本思想是什么？算法的时间复杂度？如何进行优化？★★★★★★★</h3><p>最小生成树:<strong>普利姆、克鲁斯卡尔</strong></p><p>最短路：<strong>迪杰斯特拉、弗洛依德，单源负权边时是</strong>Bellman Ford算法</p><p>迪杰斯特拉，克鲁斯卡尔，普利姆是贪心。</p><p>floyd是动态规划，也就是枚举中间点，i-j的距离可以被优化成经过中间点k,i-k-j</p><p>堆优化的迪杰斯特拉，克鲁斯卡尔，普利姆均为O(nlogn)</p><p>普通dji是O(n^2)</p><p>floyd为O(n^3)</p><h3 id="邻接表和邻接矩阵（如何存储大数据）★"><a href="#邻接表和邻接矩阵（如何存储大数据）★" class="headerlink" title="邻接表和邻接矩阵（如何存储大数据）★"></a>邻接表和邻接矩阵（如何存储大数据）★</h3><h3 id="介绍一下深度优先搜索和广度优先搜索是如何实现的？★★★"><a href="#介绍一下深度优先搜索和广度优先搜索是如何实现的？★★★" class="headerlink" title="介绍一下深度优先搜索和广度优先搜索是如何实现的？★★★"></a>介绍一下深度优先搜索和广度优先搜索是如何实现的？★★★</h3><h3 id="介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）★★★"><a href="#介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）★★★" class="headerlink" title="介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）★★★"></a>介绍一下字符串匹配算法：朴素的匹配算法和KMP算法。（如何实现要会用语言描述）★★★</h3><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="OSI和TCP-x2F-IP模型各个层之间的协议和功能★★★★★★"><a href="#OSI和TCP-x2F-IP模型各个层之间的协议和功能★★★★★★" class="headerlink" title="OSI和TCP&#x2F;IP模型各个层之间的协议和功能★★★★★★"></a>OSI和TCP&#x2F;IP模型各个层之间的协议和功能★★★★★★</h3><h3 id="计算机网络为什么要分层？优点？-★★★"><a href="#计算机网络为什么要分层？优点？-★★★" class="headerlink" title="*计算机网络为什么要分层？优点？ ★★★"></a>*计算机网络为什么要分层？优点？ ★★★</h3><p>1.各层之间是独立的。某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间的接口所提供的服务。由于每一层只实现一种相对独立的功能，因而可将一个难以处理的复杂问题分解为若干个较容易处理的更小一些的问题。这样，整个问题的复杂程度就下降了。</p><p>2.灵活性好。当任何一层发生变化时（例如由于技术的变化），只要层间接口关系保持不变，则在这层以上或以下各层均不受影响。此外，对某一层提供的服务还可进行修改。</p><p>3.当某层提供的服务不再需要时，甚至可以将这层取消。</p><p>4.结构上可分割开。各层都可以采用最合适的技术来实现。</p><p>5.易于实现和维护。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统已被分解为若干个相对独立的子系统。</p><p>6.能促进标准化工作。因为每一层的功能及其所提供的服务都已有了精确的说明。</p><h3 id="简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？★★"><a href="#简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？★★" class="headerlink" title="简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？★★"></a>简述一下层次路由的原理（叙述一下与自治系统相关的内部网关协议和外部网关协议）单工、半双工、全双工通信？★★</h3><h3 id="协议三要素？（语法、语义、时序）★★"><a href="#协议三要素？（语法、语义、时序）★★" class="headerlink" title="协议三要素？（语法、语义、时序）★★"></a>协议三要素？（语法、语义、时序）★★</h3><h3 id="香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？"><a href="#香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？" class="headerlink" title="香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？"></a>香农公式？信道容量含义？带宽增加，信道容量怎么变？香农公式的前提条件？</h3><h3 id="简述一下CSMA-x2F-CD协议★★★★"><a href="#简述一下CSMA-x2F-CD协议★★★★" class="headerlink" title="*简述一下CSMA&#x2F;CD协议★★★★"></a>*简述一下CSMA&#x2F;CD协议★★★★</h3><p>先听后发，边发边听，冲突停发，随机延迟后重发（截断二进制指数退避算法）</p><p><strong>CSMA协议(载波侦听多路访问)（Carrier Sense Multiple Access)</strong></p><p><strong>非持续式：</strong></p><p>经侦听，如果介质空闲，开始发送</p><p>如果介质忙，则等待一个随机分布的时间，然后重复步骤1</p><p>优点：等待一个随机时间可以减少再次碰撞冲突的可能性</p><p>缺点：如果在这个随机时间内介质上没有数据传送，则会发生浪费</p><p><strong>1-持续式：</strong></p><p>经侦听，如介质空闲，开始发送</p><p>如介质忙，持续侦听，一旦空闲立即发送</p><p>如果发生冲突，等待一个随机分布的时间再重复步骤1</p><p>优点：持续式的延迟时间要少于非持续式</p><p>缺点：如果两个以上的站等待发送，一旦介质空闲就一定会发生冲突</p><p><strong>p-持续式：</strong></p><p>经侦听，如介质空闲，那么以p的概率发送，以(1–p)的概率延迟一个时间单元发送</p><p>如介质忙，持续侦听，一旦空闲重复步骤1</p><p>如果发送已推迟一个时间单元，再重复步骤1</p><p><strong>CSMA&#x2F;CD协议（Collision Detection:碰撞检测）</strong></p><p>载波侦听多路访问／碰撞检测(Carrier Sense Multiple Access with Collision Detection,</p><p>CSMA&#x2F;CD)</p><p>协议是CSMA 协议的改进方案。”载波帧听”就是发送前先侦听，即每个站在发送数据之前先要检测</p><p>一下总线上是否有其他站点正在发送数据，若有则暂时不发送数据，等待信道变为空闲时再发</p><p>送。”碰撞检测”就是边发送边侦听，即适配器边发送数据边检测信道上信号电压的变化情况，以</p><p>便判断自己在发送数据时其他站点是否也在发送数据。工作流程可简单概括为“先听后发，边听边</p><p>发（区别于CSMA 协议），冲突停发，随机重发”。</p><ol><li>适配器从其父结点获得一个网络层数据报，准备一个以太网帧，并把该帧放到适配器缓冲区</li></ol><p>中。</p><ol start="2"><li>如果适配器侦听到信道空闲，那么它开始传输该帧。如果适配器侦听到信道忙，那么它将等待</li></ol><p>直至侦听到没有信号能量，然后开始传输该帧。3) 在传输过程中，适配器检测来自其他适配器的信号能量。如果这个适配器传输了整个帧，而没</p><p>有检测到来自其他适配器的信号能量，那么这个适配器完成该帧的传输。否则，适配器就须停止</p><p>传输它的帧，取而代之传输一个48 比特的拥塞信号。</p><ol start="4"><li>在中止（即传输拥塞信号）后，适配器采用截断二进制指数退避算法等待一段随机时间</li></ol><p>后返回到步骤2) 。</p><h3 id="TCP和UDP的异同点★★★★★★"><a href="#TCP和UDP的异同点★★★★★★" class="headerlink" title="*TCP和UDP的异同点★★★★★★"></a>*TCP和UDP的异同点★★★★★★</h3><p>TCP和UDP的相同点：</p><p>TCP和UDP都是在网络层，都是传输层协议，都能都是保护网络层的传输，双方的通信都需要开放端口。</p><p>TCP和UDP的不同点：</p><ol><li><p>TCP的传输是可靠传输。</p><p>UDP的传输是不可靠传输。</p></li></ol><p>2. TCP是基于连接的协议，在正式收发数据前，必须和对方建立可靠的连接。</p><p>UDP是和TCP相对应的协议，它是面向非连接的协议，它不与对方建立连接，而是直接把数据包发送出去</p><p>3. TCP是一种可靠的通信服务，负载相对而言比较大，TCP采用套接字（socket）或者端口（port）来建立通信。</p><p>UDP是一种不可靠的网络服务，负载比较小。</p><p>4. TCP和UDP结构不同，TCP包括序号、确认信号、数据偏移、控制标志（通常说的URG、ACK、PSH、RST、SYN、FIN）、窗口、校验和、紧急指针、选项等信息。</p><p>UDP包含长度和校验和信息。</p><p>5. TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。</p><p>UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。</p><p>6. TCP在发送数据包前在通信双方有一个三次握手机制，确保双方准备好，在传输数据包期间，TCP会根据链路中数据流量的大小来调节传送的速率，传输时如果发现有丢包，会有严格的重传机制，故而传输速度很慢。</p><p>UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。</p><p>7. TCP支持全双工和并发的TCP连接，提供确认、重传与拥塞控制。</p><p>UDP适用于哪些系统对性能的要求高于数据完整性的要求，需要“简短快捷”的数据交换、需要多播和广播的应用环境。</p><p>原文链接：<a href="https://blog.csdn.net/quiet_girl/article/details/50599777">https://blog.csdn.net/quiet_girl/article/details/50599777</a></p><h3 id="TCP的三次握手四次挥手过程？为什么会采用三次握手，若采用二次握手可以吗？★★★★★"><a href="#TCP的三次握手四次挥手过程？为什么会采用三次握手，若采用二次握手可以吗？★★★★★" class="headerlink" title="*TCP的三次握手四次挥手过程？为什么会采用三次握手，若采用二次握手可以吗？★★★★★"></a>*TCP的三次握手四次挥手过程？为什么会采用三次握手，若采用二次握手可以吗？★★★★★</h3><p>四次挥手:<a href="https://blog.csdn.net/guoweimelon/article/details/50879302">https://blog.csdn.net/guoweimelon/article/details/50879302</a></p><p>三次握手:<a href="https://blog.csdn.net/guoweimelon/article/details/50878730">https://blog.csdn.net/guoweimelon/article/details/50878730</a></p><p>如果二次握手：</p><p>先假如出现了一种异常情况，即A发出的第一个连接请求报文段因为在某些网络节点上滞留了。由于超时重传，于是A又向B发起请求并成功建立了连接，在传输完数据之后，AB同之间释放了连接。</p><p>而在A和B已经释放连接之后，那个在网络上滞留的报文段又达到了B。这时候，B接收到报文以为是A发起的新的一次建立连接的请求，于是就向A发出确认建立连接报文段。而A此时并没有发起建立连接的请求，于是不予理睬。但是B以为新的连接已经建立，一直等待A发送数据，于是B的许多资源就浪费了。</p><h3 id="介绍下TCP和UDP协议的特点、头部结构★★★★★"><a href="#介绍下TCP和UDP协议的特点、头部结构★★★★★" class="headerlink" title="介绍下TCP和UDP协议的特点、头部结构★★★★★"></a>介绍下TCP和UDP协议的特点、头部结构★★★★★</h3><h3 id="简述下TCP建立连接的过程-TCP如何保证可靠传输？★★★★★★"><a href="#简述下TCP建立连接的过程-TCP如何保证可靠传输？★★★★★★" class="headerlink" title="*简述下TCP建立连接的过程,TCP如何保证可靠传输？★★★★★★"></a>*简述下TCP建立连接的过程,TCP如何保证可靠传输？★★★★★★</h3><p>TCP协议保证数据传输可靠性的方式主要有：</p><ul><li>校验和</li><li>序列号</li><li>确认应答</li><li>超时重传</li><li>连接管理</li><li>流量控制</li><li>拥塞控制</li></ul><p><a href="https://blog.csdn.net/liuchenxia8/article/details/80428157?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164024563516780274155503%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164024563516780274155503&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2%5C~all%5C~sobaiduend%5C~default-1-80428157.pc_search_insert_es_download&utm_term=TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93&spm=1018.2226.3001.4187">https://blog.csdn.net/liuchenxia8/article/details/80428157?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164024563516780274155503%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164024563516780274155503&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2\~all\~sobaiduend\~default-1-80428157.pc_search_insert_es_download&amp;utm_term=TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93&amp;spm=1018.2226.3001.4187</a></p><h3 id="在TCP拥塞控制中，什么是慢开始、拥塞避免、快重传和快恢复算法？★★★★"><a href="#在TCP拥塞控制中，什么是慢开始、拥塞避免、快重传和快恢复算法？★★★★" class="headerlink" title="*在TCP拥塞控制中，什么是慢开始、拥塞避免、快重传和快恢复算法？★★★★"></a>*在TCP拥塞控制中，什么是慢开始、拥塞避免、快重传和快恢复算法？★★★★</h3><p>我们在开始假定:</p><p>1:数据是单方向传递,另一个窗口只发送确认.</p><p>2:接收方的缓存足够大,因此发送方的大小的大小由网络的拥塞程度来决定.</p><p>一:慢开始算法和拥塞避免算法</p><p>发送方会维持一个拥塞窗口,刚开始的拥塞窗口和发送窗口相等,一般开始均设置1,然后我们每收到一个确认,就让拥塞窗口大小变为原来的两倍,接着发送分组也是原来的两倍,以此类推,当窗口值等于16(慢开始门限),然后我们开始采用”加法增大”的策略,即不在以2倍的方式增加,而是转变为每次加1的方式.直到网络拥塞.我们开始采用”拥塞避免”算法:让新的慢开始门限值变为发生拥塞时候的值的一半,将拥塞窗口置为1,然后让它再次重复,这时一瞬间会将网络中的数据量大量降低.</p><p>二:快重传和快恢复算法</p><p>快重传可以提高网络的吞吐量而快恢复算法相当于拥塞避免算法的后半恢复部分的优化.</p><p>假设以下情况:如果在发送方设置的超时定时器到时间还没有收到确认,那么有一种可能是网络发生堵塞,这种情况下,tcp会将拥塞窗口置为一,新的门限值变为发生阻塞时的一半并且开始执行慢开始算法.当我们使用快重传的时候,要求接收方接收到一个失序的报文段后就立即发出 重复确认,(目的是让对方早知道有报文段没有到达)</p><p>假设发送方发送了M1–M4四个分组,接收方收到了M1和M2,以及M4,这些分组.</p><p>现在接收方不能确认M4,因为M3没有收到,此时接收方可以什么都不干,也可以发送对M2的确认,但是快重传算法要求这样做:</p><p>接收方应该及时发送对M2的重复确认,这样可以让发送方知道M3并没有被传过来,发送方还会试着发送M5,M6,接收方收到之后,我们会继续发送对M2的确认,这样一共发了好几个对M2的确认,按照规定,只要发送方收到三个重复确认,就立即重传对方未收到的报文段M3.这样可以避免阻塞,并且提高我们网络的吞吐量.</p><p>快恢复算法与快重传算法配合使用</p><p>当发送方收到三个连续确认时,就执行”乘法减小”算法,把”慢开始门限”减半,注意接下来不会执行慢开始算法.</p><p>由于此时没有发送网络阻塞(要是发生阻塞的话就不会连续收到4个确认),因此此时不执行慢开始算法,并不会将拥塞窗口的值置为1,而是将它置为慢开始门限的一半.然后再实行拥塞避免算法,每次收到确认之后+1.</p><p><a href="https://blog.csdn.net/sinat_21112393/article/details/50810053?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%9C%A8TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%85%A2%E5%BC%80%E5%A7%8B%E3%80%81%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E3%80%81%E5%BF%AB%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E6%81%A2%E5%A4%8D%E7%AE%97&utm_medium=distribute.pc_search_result.none-task-blog-2%5C~all%5C~sobaiduweb%5C~default-0-50810053.pc_search_result_control_group&spm=1018.2226.3001.4187">https://blog.csdn.net/sinat_21112393/article/details/50810053?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%9C%A8TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%85%A2%E5%BC%80%E5%A7%8B%E3%80%81%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E3%80%81%E5%BF%AB%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E6%81%A2%E5%A4%8D%E7%AE%97&amp;utm_medium=distribute.pc_search_result.none-task-blog-2\~all\~sobaiduweb\~default-0-50810053.pc_search_result_control_group&amp;spm=1018.2226.3001.4187</a></p><h3 id="TCP的快速重传机制★★★★"><a href="#TCP的快速重传机制★★★★" class="headerlink" title="TCP的快速重传机制★★★★"></a>TCP的快速重传机制★★★★</h3><p><a href="https://blog.csdn.net/Shawei_/article/details/81775504?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2%5C~aggregatepage%5C~first_rank_ecpm_v1%5C~rank_v31_ecpm-3-81775504.pc_agg_new_rank&utm_term=tcp%E7%9A%84%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6&spm=1000.2123.3001.4430">https://blog.csdn.net/Shawei_/article/details/81775504?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2\~aggregatepage\~first_rank_ecpm_v1\~rank_v31_ecpm-3-81775504.pc_agg_new_rank&amp;utm_term=tcp%E7%9A%84%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6&amp;spm=1000.2123.3001.4430</a></p><h3 id="流量控制和拥塞是什么关系-★★★★"><a href="#流量控制和拥塞是什么关系-★★★★" class="headerlink" title="*流量控制和拥塞是什么关系? ★★★★"></a>*流量控制和拥塞是什么关系? ★★★★</h3><p>流量控制解决的是发送方和接收方速率不匹配的问题；拥塞控制解决的是避免网络资源被耗尽的问题。流量控制是通过滑动窗口来实现的；拥塞控制是通过拥塞窗口来实现的。</p><p>拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：慢开始、拥塞避免快重传、快恢复。</p><p>流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。</p><p><a href="https://www.huaweicloud.com/articles/ba31660f82bbdd3a3e8615ec68d85bc3.html">https://www.huaweicloud.com/articles/ba31660f82bbdd3a3e8615ec68d85bc3.html</a></p><h3 id="两个服务器之间网络已经联通，却收不到彼此的UDP报文原因★★★★"><a href="#两个服务器之间网络已经联通，却收不到彼此的UDP报文原因★★★★" class="headerlink" title="*两个服务器之间网络已经联通，却收不到彼此的UDP报文原因★★★★"></a>*两个服务器之间网络已经联通，却收不到彼此的UDP报文原因★★★★</h3><p>可能的原因很多，比如设置了acl（访问控制列表），禁用了某些端口，网络拥塞，丢包等</p><p>主要丢包原因</p><p><strong>1、接收端处理时间过长导致丢包</strong>：调用recv方法接收端收到数据后，处理数据花了一些时间，处理完后再次调用recv方法，在这二次调用间隔里,发过来的包可能丢失。对于这种情况可以修改接收端，将包接收后存入一个缓冲区，然后迅速返回继续recv。</p><p><strong>2、发送的包巨大丢包</strong>：虽然send方法会帮你做大包切割成小包发送的事情，但包太大也不行。例如超过50K的一个udp包，不切割直接通过send方法发送也会导致这个包丢失。这种情况需要切割成小包再逐个send。</p><p><strong>3、发送的包较大，超过接受者缓存导致丢包</strong>：包超过mtu size数倍，几个大的udp包可能会超过接收者的缓冲，导致丢包。这种情况可以设置socket接收缓冲。以前遇到过这种问题，我把接收缓冲设置成64K就解决了。</p><p>int nRecvBuf&#x3D;32*1024;&#x2F;&#x2F;设置为32K</p><p>setsockopt(s,SOL_SOCKET,SO_RCVBUF,(const char*)&amp;nRecvBuf,sizeof(int));</p><p><strong>4、发送的包频率太快</strong>：虽然每个包的大小都小于mtu size 但是频率太快，例如40多个mut size的包连续发送中间不sleep，也有可能导致丢包。这种情况也有时可以通过设置socket接收缓冲解决，但有时解决不了。所以在发送频率过快的时候还是考虑sleep一下吧。</p><p><strong>5、局域网内不丢包，公网上丢包</strong>。这个问题我也是通过切割小包并sleep发送解决的。如果流量太大，这个办法也不灵了。总之udp丢包总是会有的，如果出现了用我的方法解决不了，还有这个几个方法： 要么减小流量，要么换tcp协议传输，要么做丢包重传的工作。</p><h3 id="地址解析协议和RARP协议★★"><a href="#地址解析协议和RARP协议★★" class="headerlink" title="地址解析协议和RARP协议★★"></a>地址解析协议和RARP协议★★</h3><h3 id="网卡是什么？功能？★★★"><a href="#网卡是什么？功能？★★★" class="headerlink" title="*网卡是什么？功能？★★★"></a>*网卡是什么？功能？★★★</h3><p>网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p><p>网卡的作用：</p><p>网络是通过模拟信号将信息转化为电流传播的，网卡在这里面就充当了一个解码器的作用，将电信号重新转换文文字图像等就是网卡的责任。网卡的其他功能还有监控上传及下载流量，控制网速稳定的作用，它就相当于电脑的港口，所有信息上传到网络之前都要先到网卡这里走一遭。</p><p>每台电脑都有网卡，没有网卡无法上网。</p><h3 id="说下网络中的主机通信流程★★"><a href="#说下网络中的主机通信流程★★" class="headerlink" title="说下网络中的主机通信流程★★"></a>说下网络中的主机通信流程★★</h3><h3 id="一个主机将两个端口接到网络上是否会提升吞吐量？为什么？★★"><a href="#一个主机将两个端口接到网络上是否会提升吞吐量？为什么？★★" class="headerlink" title="一个主机将两个端口接到网络上是否会提升吞吐量？为什么？★★"></a>一个主机将两个端口接到网络上是否会提升吞吐量？为什么？★★</h3><h3 id="简述下DNS域名解析的过程。★★★★★"><a href="#简述下DNS域名解析的过程。★★★★★" class="headerlink" title="*简述下DNS域名解析的过程。★★★★★"></a>*简述下DNS域名解析的过程。★★★★★</h3><p>1、当客户机提出查询请求时，首先在本地计算机的缓存中查找。如果在本地无法获得查询信息，则将查询请求发给DNS服务器。</p><p>2、首先客户机将域名查询请求发送到本地DNS服务器,当本地DNS服务器接到查询后，首先在该服务器管理的区域的记录中查找，如果找到该记录，则利用此记录进行解析；如果没有区域信息可以满足查询要求，服务器在本地的缓存中查找。</p><p>3、如果本地服务器不能在本地找到客户机查询的信息，将客户机请求发送到根域名DNS服务器。</p><p>4、根域名服务器负责解析客户机请求的根域部分，它将包含下一级域名信息的DNS服务器地址返回给客户机的DNS服务器地址。</p><p>5、客户机的DNS服务器利用根域名服务器解析的地址访问下一级DNS服务器，得到再下一级域我的DNS服务器地址。</p><p>6、按照上述递归方法逐级接近查询目标，最后在有目标域名的DNS服务器上找到相应IP地址信息。</p><p>7、客户机的本地DNS服务器将递归查询结果返回客户机。</p><p>8、客户机利用从本地DNS服务器查询得到的IP访问目标主机，就完成了一个解析过程。</p><h3 id="点击网页一次HTTP请求过程？（在浏览器里输入一个网址，会发生什么）★★★"><a href="#点击网页一次HTTP请求过程？（在浏览器里输入一个网址，会发生什么）★★★" class="headerlink" title="*点击网页一次HTTP请求过程？（在浏览器里输入一个网址，会发生什么）★★★"></a>*点击网页一次HTTP请求过程？（在浏览器里输入一个网址，会发生什么）★★★</h3><p><a href="https://blog.csdn.net/qq_21993785/article/details/81188253">https://blog.csdn.net/qq_21993785/article/details/81188253</a></p><h3 id="机器的ip地址和mac地址，他们有什么区别，有什么用途？★★"><a href="#机器的ip地址和mac地址，他们有什么区别，有什么用途？★★" class="headerlink" title="机器的ip地址和mac地址，他们有什么区别，有什么用途？★★"></a>机器的ip地址和mac地址，他们有什么区别，有什么用途？★★</h3><h3 id="HTTP状态码及其含义★★★★-HTTP和HTTPS的区别★★★★"><a href="#HTTP状态码及其含义★★★★-HTTP和HTTPS的区别★★★★" class="headerlink" title="*HTTP状态码及其含义★★★★ HTTP和HTTPS的区别★★★★"></a>*HTTP状态码及其含义★★★★ HTTP和HTTPS的区别★★★★</h3><p>状态码含义:<a href="https://blog.csdn.net/whl826661099/article/details/98606745">https://blog.csdn.net/whl826661099/article/details/98606745</a></p><p>区别:<a href="https://www.cnblogs.com/wqhwe/p/5407468.html">https://www.cnblogs.com/wqhwe/p/5407468.html</a></p><h3 id="DHCP的作用？★★"><a href="#DHCP的作用？★★" class="headerlink" title="DHCP的作用？★★"></a>DHCP的作用？★★</h3><p><a href="https://baike.baidu.com/item/DHCP/218195?fr=aladdin">https://baike.baidu.com/item/DHCP/218195?fr=aladdin</a></p><h3 id="能不能直接在应用层把数据交给网络层★★★"><a href="#能不能直接在应用层把数据交给网络层★★★" class="headerlink" title="*能不能直接在应用层把数据交给网络层★★★"></a>*能不能直接在应用层把数据交给网络层★★★</h3><p>在应用层数据的呈现形式是声音、图形、文字等具体的信息，而网络通信信道所能传输的是电信号（一般是数字信号），以上信息无法直接通过信道传输，所以，必须将数据转化成二进制传输。</p><p>不完整回答（从传输层目的层面）：</p><p><strong>传输层</strong>为<strong>运行在不同主机上的进程之间</strong>提供了逻辑通信,而<strong>网络层</strong>则提供了<strong>主机之间</strong>的逻辑通信。</p><p>传输层向上提供可靠的和不可靠的逻辑通信信道</p><p>TCP 和 UDP 都用<strong>端口号</strong>来识别应用层实体,一边准确地把信息交给上层对应的协议(进程)。</p><h3 id="了解Socket吗？什么是socket？★★★★"><a href="#了解Socket吗？什么是socket？★★★★" class="headerlink" title="*了解Socket吗？什么是socket？★★★★"></a>*了解Socket吗？什么是socket？★★★★</h3><h3 id="简述一下Cookie-和-Session的区别★★★"><a href="#简述一下Cookie-和-Session的区别★★★" class="headerlink" title="*简述一下Cookie 和 Session的区别★★★"></a>*简述一下Cookie 和 Session的区别★★★</h3><p>区别：</p><p>1、数据存放位置不同：</p><p>cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、安全程度不同：</p><p>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。</p><p>3、性能使用程度不同：</p><p>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。</p><p>4、数据存储大小不同：</p><p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，而session则存储与服务端，浏览器对其没有限制。</p><p>5、会话机制不同</p><p>session会话机制：session会话机制是一种服务器端机制，它使用类似于哈希表（可能还有哈希表）的结构来保存信息。</p><p>cookies会话机制：cookie是服务器存储在本地计算机上的小块文本，并随每个请求发送到同一服务器。 Web服务器使用HTTP标头将cookie发送到客户端。在客户端终端，浏览器解析cookie并将其保存为本地文件，该文件自动将来自同一服务器的任何请求绑定到这些cookie。</p><h3 id="https-www-cnblogs-com-zyf-zhaoyafei-p-4716297-htmlhttps-www-cnblogs-com-zyf-zhaoyafei-p-4716297-html-https-www-cnblogs-com-zyf-zhaoyafei-p-4716297-html计算机网络之面试常考"><a href="#https-www-cnblogs-com-zyf-zhaoyafei-p-4716297-htmlhttps-www-cnblogs-com-zyf-zhaoyafei-p-4716297-html-https-www-cnblogs-com-zyf-zhaoyafei-p-4716297-html计算机网络之面试常考" class="headerlink" title="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.htmlhttps://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html计算机网络之面试常考"></a><a href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html</a><a href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html</a> <a href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html</a><a href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html">计算机网络之面试常考</a></h3><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="操作系统的特点？功能？★"><a href="#操作系统的特点？功能？★" class="headerlink" title="*操作系统的特点？功能？★"></a>*操作系统的特点？功能？★</h3><p>操作系统特点：</p><p>操作系统的四个基本特征是并发,共享,异步,虚拟。而每个操作系统又有其独特的特征，如我们常用的linux系统有开放性;多用户多任务;设备的独立性;强大的网络功能和网络可靠性等特点。</p><p>操作系统的功能：</p><p>管理计算机系统的全部软、硬件资源 , 合理组织计算机的工作流程 , 以达到充分发挥计算机资源的效率 , 为用户提供友好界面</p><h3 id="中断和系统调用的区别★★★"><a href="#中断和系统调用的区别★★★" class="headerlink" title="*中断和系统调用的区别★★★"></a>*中断和系统调用的区别★★★</h3><p><a href="http://www.cppblog.com/chxzwj/archive/2011/11/03/159575.html">http://www.cppblog.com/chxzwj/archive/2011/11/03/159575.html</a><a href="http://www.cppblog.com/chxzwj/archive/2011/11/03/159575.html">中断和系统调用的区别</a></p><p>中断分两种，硬中断和软中断；硬中断是实实在在的硬件发出的中断，cpu检测到发生中断后，保护现场，查找中断向量地址，执行中断服务程序，之后，重新选择进程进行调度。软中断是由指令执行过程中发出的中断，但是并没有中断向量表，而是有对应的散转表，查找对应的中断号，转中断服务程序，之后的和硬中断相同。</p><p><strong>系统调用是软中断的一种。</strong></p><p>无论如何，发生中断时，要从目态转向管态。</p><h3 id="进程、线程的概念以及区别？进程间的通信方式？★★★★★★"><a href="#进程、线程的概念以及区别？进程间的通信方式？★★★★★★" class="headerlink" title="*进程、线程的概念以及区别？进程间的通信方式？★★★★★★"></a>*进程、线程的概念以及区别？进程间的通信方式？★★★★★★</h3><p><strong>一、进程与线程的区别</strong></p><p>进程是具有一定功能的程序，是系统进行资源分配调度的一个独立单位。</p><p>线程是进程的一个实体，是CPU调度分配的基本单位，线程之间基本上不拥有系统资源。</p><p>一个程序至少有一个进程，一个进程至少有一个线程，资源分配给进程，同一个进程下所有线程共享该进程的资源。</p><p><strong>二、线程哪些资源共享？哪些资源不共享？</strong></p><p>共享：堆、全局变量、静态变量、文件等共用资源</p><p>独享：栈、寄存器</p><p>进程间的通信方式:<a href="https://blog.csdn.net/zhaohong_bo/article/details/89552188">https://blog.csdn.net/zhaohong_bo/article/details/89552188</a></p><h3 id="进程有哪几种状态，状态之间的转换、进程调度策略？★★★★"><a href="#进程有哪几种状态，状态之间的转换、进程调度策略？★★★★" class="headerlink" title="*进程有哪几种状态，状态之间的转换、进程调度策略？★★★★"></a>*进程有哪几种状态，状态之间的转换、进程调度策略？★★★★</h3><p>进程的三种状态</p><p><strong>就绪（Ready）状态</strong></p><p>进程已分配到除CPU以外的所有必要资源，只要获得处理机便可立即执行。</p><p><strong>执行（Running）状态</strong></p><p>进程已获得处理机，其程序正在处理机上执行。</p><p><strong>阻塞（Blocked）状态</strong></p><p>正在执行的程序，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的原因可能是等待I&#x2F;O完成、申请缓冲区不能满足、等待信号等。</p><p><strong>Q1：为什么在转换图中没有就绪到阻塞和阻塞到执行的转换方向？</strong></p><p>就绪状态进程没有占有处理机，即不经过执行，其状态就不会改变；阻塞状态进程唤醒后要先进入到就绪队列，才会被调度程序选中，进行执行状态</p><p><strong>1.先来先服务调度算法：</strong>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p><p><strong>2.短作业(进程)优先调度算法：</strong>短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</p><p><strong>3.高优先权优先调度算法：</strong>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。</p><p><strong>3.1) 非抢占式优先权算法：</strong>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p><p><strong>3.2) 抢占式优先权调度算法：</strong>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi&gt;Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p><p><strong>4、高响应比优先调度算法：</strong>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</p><p>在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。</p><p><strong>5、时间片轮转法：</strong>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。</p><p><strong>6、多级反馈队列调度算法：</strong>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。</p><p><strong>(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。</strong>第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。</p><p><strong>(2)当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。</strong>当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。</p><p><strong>(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；</strong>仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</p><ol><li><strong>*读写者问题是用进程实现的还是线程实现的？文件系统中文件是如何组织的？</strong></li></ol><p>读写者问题是用进程实现的还是线程实现的？文件系统中文件是如何组织的？</p><p>（不作为回答内容：这题网上没答案吧，我看读者写者进程、线程实现都可以，根据武老师上课说，我们第二章之后讲的都以进程作为例子，推测是进程）</p><p>读写者问题实现：</p><p>读写者问题是经典进程同步问题，是用进程实现的。</p><p>如何组织：</p><p>文件组织是指文件的构造方式。文件用户按照自己的使用要求，把构成文件的元素组织起来，文件的这种结构叫文件逻辑结构。</p><p>文件的逻辑组织 文件的逻辑组织通常分为两种形式，即有结构文件（记录文件）和无结构文件（字符流文件）。1）有结构文件又称作记录式文件，它在逻辑上可被看成一组连续记录的集合，即文件是由若干个相关的记录组成。每个记录是一组相关的数据集合，用于描述一个对象某个方面的属性。记录式文件按其记录的长度是否相同又可分为：定长记录文件和变长记录文件两种。（1）定长记录文件：指文件中所有记录的长度都相同。文件的长度可用记录的数目来表示。定长记录处理方便，开销小，被广泛用于数据处理中。（2）变长记录文件：指文件中各记录的长度不相同。在处理之前每个记录的长度是已知的。2）无结构文件无结构文件是指文件内部不再划分记录，它是由一组相关信息组成的有序字符流，即流式文件，其长度直接按字节计算。如大量的源程序、可执行程序、库函数等采用的文件形式是无结构文件形式。在UNIX系统中，所有的普通文件都被看做是流式文件，系统不对文件进行格式处理。 ●常用的记录式结构有：连续结构、多重结构、转置结构和顺序结构。 ●常用的存取方法有顺序存取法、随机存取法（直接存取法）和按键存取法。 文件的物理组织 ●常用的文件物理结构有连续文件、串联文件和索引文件。 1）连续文件连续文件（又称做顺序文件）是基于磁带设备的最简单的物理文件结构，它是把一个逻辑上连续的文件信息存放在连续编号的物理块（或物理记录）中。连续文件的优点是在顺序存取时速度较快，常用于存放系统文件，如操作系统文件、编译程序文件和其它由系统提供的实用程序文件，因为这类文件往往被从头至尾依次存取。但连续文件也存在如下缺点：</p><p>（1）要求建立文件时就确定它的长度，依此来分配相应的存储空间，这往往很难实现。</p><p>（2）不便于文件的动态扩充。</p><p>（3）可能出现外部碎片，就是在存储介质上存在很多空闲块，但它们都不连续，无法被连续的文件使用，从而造成浪费。 2）串联文件为克服连续文件的缺点，可把一个逻辑上连续的文件分散存放在不同的物理块中，这些物理块不要求连续，也不必规则排列。为了使系统能找到下一个逻辑块所在的物理块，可在各物理块中设立一个指针（称为连接字），它指示该文件的下一个物理块。串连文件克服了连续文件的缺点，但它又带来新的问题：</p><p>（1）一般仅适于对信息的顺序访问，而不利于对文件的随机存取。</p><p>（2）每个物理块上增加一个连接字，为信息管理添加了一些麻烦。 FAT格式通过把文件分配表（FAT，File Allocation Table ）放在一个内存表格中的方式加以克服串联文件的缺点。 3）索引文件 索引文件是实现非连续分配的另一种方案：系统为每个文件建立一个索引表。其中的表项指出存放该文件的各个物理块号，而整个索引表由文件说明项指出。这种结构除了具备串连文件的优点之外，还克服了它的缺点。它可以方便地进行随机存取。但是这种组织形式需要增加索引表带来的空间开销。如果这些表格仅放在盘上，那么在存取文件时首先得取出索引表，然后才能查表、得到物理块号。这样就至少增加了一次访盘操作，从而降低了存取文件的速度，加重了 I&#x2F;O负担。一种改进办法是同时把索引表部分或全部地放人内存。这是以内存空间为代价来换取存取速度的改善。 树型目录结构树型目录结构可能是目录结构中，考的比较多的，考的也简单。</p><h3 id="什么是死锁？死锁产生的四个必要条件？如何预防死锁？★★★★★★"><a href="#什么是死锁？死锁产生的四个必要条件？如何预防死锁？★★★★★★" class="headerlink" title="*什么是死锁？死锁产生的四个必要条件？如何预防死锁？★★★★★★"></a>*什么是死锁？死锁产生的四个必要条件？如何预防死锁？★★★★★★</h3><p><strong>一、什么是死锁</strong></p><p>死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p><p><strong>二、产生死锁的原因：</strong></p><p>1、竞争不可抢占型资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</p><p>2、竞争可消耗型资源（可消耗型资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</p><p>3、进程推进顺序不当（若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。</p><p>当P1运行到P1，Request时，将因R2已被P2占用而阻塞；当P2运行到P2：Request时，也将因R1已被P1占用而阻塞，于是发生进程死锁）</p><p><strong>三、死锁产生的四个必要条件</strong></p><p>1、互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</p><p>2、请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>3、不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</p><p>4、环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</p><p><strong>四、如何预防死锁</strong></p><p>1、资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</p><p>2、允许程序获得运行初期条件的所有资源后开始运行，过程中逐步释放给自己的已用毕的资源，然后再请求新的资源（破坏请保持条件）</p><p>3、可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</p><p>4、资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p><p>原文链接：<a href="https://blog.csdn.net/hd12370/article/details/82814348">https://blog.csdn.net/hd12370/article/details/82814348</a></p><h3 id="哲学家进餐有哪些实现方式？★★★★"><a href="#哲学家进餐有哪些实现方式？★★★★" class="headerlink" title="*哲学家进餐有哪些实现方式？★★★★"></a>*哲学家进餐有哪些实现方式？★★★★</h3><p>哲学家进餐问题的核心是保证至少有一位哲学家能拿到两只筷子就餐后释放筷子。</p><p>（1）最多只允许n-1个哲学家拿起筷子就餐。</p><p>（2）资源分级算法,奇数号哲学家先拿左手边的筷子，偶数号的哲学家先拿右手边的筷子。</p><p>（3）设立规则，当一位哲学家拿起一只筷子时，另一个筷子无法得到，则放下刚刚拿起的筷子.</p><p>(4 ) 服务生算法,一次只允许一名哲学家进餐，等到这名哲学家进餐完毕后才允许其他哲学家进餐。</p><h3 id="简述下银行家算法★★★★"><a href="#简述下银行家算法★★★★" class="headerlink" title="*简述下银行家算法★★★★"></a>*简述下银行家算法★★★★</h3><p>银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。</p><p>银行家算法中的数据结构</p><p>为了实现银行家算法，必须设置以下四个数据结构:</p><p>（1）可利用资源向量Available:其初始值是系统中所配置的该类全部可用资源的数目。</p><p>（2）最大需求矩阵Max:它定义了系统中n个进程中的每一个进程对m类资源的最大需求。</p><p>（3）分配矩阵Allocation:它定义了系统中每一类资源当前已分配给每一个进程的资源数。</p><p>（4）需求矩阵Need：用一表示每一个进程尚需的各类资源数。</p><p>银行家算法检查的步骤</p><p>Request(i)是进程P(i)的请求向量。如果Requst(i)[j] &#x3D; K,表示进程P(i)需要K个R(j)类型的资源。</p><p>（1）如果Request(i)[j] &lt;&#x3D; Need[i,j],便转向步骤2,否则出错；</p><p>（2）如果Request(i)[j] &lt;&#x3D; Available[j],便转向步骤3，否则出错；</p><p>（3）系统试探着把资源分配给进程P,并修改下面数据结构中的数值:</p><p>(非常重要)</p><p>Available[j] &#x3D; Avaliable[j] - Request(i)[j];</p><p>Allocation[i,j] &#x3D; Allocation[i,j] + Request(i)[j];</p><p>Need[i,j] &#x3D; Need[i,j] - Request(i)[j];</p><p>（4）执行**安全性算法*,检查此次资源分配后系统是否处于安全状态*。安全则分配，否则分配作废。</p><p>原文链接：<a href="https://blog.csdn.net/qq_34649947/article/details/70224868">https://blog.csdn.net/qq_34649947/article/details/70224868</a></p><h3 id="介绍下几种常见的进程调度算法及其流程（FCFS，SJF，剩余短作业优先，优先级调度，轮转法，多级反馈队列等等）★★★★★★"><a href="#介绍下几种常见的进程调度算法及其流程（FCFS，SJF，剩余短作业优先，优先级调度，轮转法，多级反馈队列等等）★★★★★★" class="headerlink" title="介绍下几种常见的进程调度算法及其流程（FCFS，SJF，剩余短作业优先，优先级调度，轮转法，多级反馈队列等等）★★★★★★"></a>介绍下几种常见的进程调度算法及其流程（FCFS，SJF，剩余短作业优先，优先级调度，轮转法，多级反馈队列等等）★★★★★★</h3><h3 id="分页的作用，好处？和分段有什么区别？★★★"><a href="#分页的作用，好处？和分段有什么区别？★★★" class="headerlink" title="*分页的作用，好处？和分段有什么区别？★★★"></a>*分页的作用，好处？和分段有什么区别？★★★</h3><p>（1）页是信息的物理单位，分页是为了实现非连续分配，以便解决内存碎片问题，或者说分页是由于系统管理的需要。段是信息的逻辑单位，它含有一组意义相对完整的信息，分段的目的是为了更好地实现共享，满足用户的需要。</p><p>（2）页的大小固定且由系统确定，将逻辑地址划分为页号和页内地址是由机器硬件实现的，而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时根据信息的性质来划分。</p><p>（3）分页的作业地址空间是一维的；分段的地址空间是二维的。</p><h3 id="内存分配有哪些机制？（JVM的内存管理及垃圾回收算法）★★★"><a href="#内存分配有哪些机制？（JVM的内存管理及垃圾回收算法）★★★" class="headerlink" title="内存分配有哪些机制？（JVM的内存管理及垃圾回收算法）★★★"></a>内存分配有哪些机制？（JVM的内存管理及垃圾回收算法）★★★</h3><ol><li><strong>*什么是虚拟内存？什么是共享内存？</strong>★★★</li></ol><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。</p><p>共享内存是最快速的进程间通信机制。操作系统在几个进程的地址空间上映射一段内存，然后这几个进程可以在不需要调用操作系统函数的情况下在那段内存上进行读&#x2F;写操作</p><p>原文链接：<a href="https://blog.csdn.net/zhanyd/article/details/102987669">https://blog.csdn.net/zhanyd/article/details/102987669</a></p><p><a href="http://blog.sina.com.cn/s/blog_a9cdad020102wxzw.html">http://blog.sina.com.cn/s/blog_a9cdad020102wxzw.html</a></p><h3 id="有哪些页面置换算法？★★★★"><a href="#有哪些页面置换算法？★★★★" class="headerlink" title="*有哪些页面置换算法？★★★★"></a>*有哪些页面置换算法？★★★★</h3><ol><li>最佳置换算法(OPT):每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</li><li>先进先出置换算法（FIFO）:每次选择淘汰的页面是最早进入内存的页面。</li><li>最近最久未使用置换算法:每次淘汰的页面是最近最久未使用的页面</li><li>时钟置换算法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某个页被访问时，其访问位置1.当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，暂不换出，将访问位改为0，继续检查下一个页面，若第一轮扫描中所有的页面都是1，则将这些页面的访问位一次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）。</li><li>改进型时钟置换算法：</li></ol><p>第一轮：从当前位置开始扫描第一个的页用于替换，本轮扫描不修改任何标志位。</p><p>第二轮：若第一轮扫描失败，则重新扫描，查找第一个的页用于替换。本轮将所有扫描的过的页访问位设为0。</p><p>第三轮：若第二轮扫描失败，则重新扫描，查找第一个的页用于替换。本轮扫描不修改任何标志位。</p><p>第四轮：若第三轮扫描失败，则重新扫描，查找第一个的页用于替换。</p><p>原文链接：<a href="https://www.jianshu.com/p/18285ecffbfb">https://www.jianshu.com/p/18285ecffbfb</a></p><h3 id="说一说操作系统中缓冲区溢出怎么处理★★★"><a href="#说一说操作系统中缓冲区溢出怎么处理★★★" class="headerlink" title="*说一说操作系统中缓冲区溢出怎么处理★★★"></a>*说一说操作系统中缓冲区溢出怎么处理★★★</h3><p><strong>缓冲区溢出</strong></p><p>当计算机程序向缓冲区内填充的数据位数超过了缓冲区本身的容量。溢出的数据覆盖在合法数据上</p><p>理想情况是，程序检查数据长度并且不允许输入超过缓冲区长度的字符串。但是绝大多数程序都会假设数据长度总是与所分配的存储空间相匹配，这就为缓冲区溢出埋下隐患。操作系统所使用的缓冲区又被称为堆栈，在各个操作进程之间，指令被临时存储在堆栈当中，堆栈也会出现缓冲区溢出。</p><p><strong>上溢</strong></p><p>当一个超长的数据进入到缓冲区时，超出部分被写入上级缓冲区，</p><p>上级缓冲区存放的可能是数据、上一条指令的指针，或者是其他程序的输出内容</p><p>，这些内容都被覆盖或者破坏掉。可见一小部分数据或者一套指令的溢出就可能导致一个程序或者操作系统崩溃。</p><p><strong>下溢</strong></p><p>当一个超长的数据进入到缓冲区时，超出部分被写入下级缓冲区，</p><p>下级缓冲区存放的是下一条指令的指针，或者是其他程序的输出内容。</p><p>缓冲区攻击的日渐泛滥，微软并未任其张扬，陆陆续续推出了各种保存措施。其中重要的有GS，SafeSeh，ASLR，DEP等，接下来我们针对这些措施进行原理分析：</p><p><strong>①.GS保护原理：</strong></p><p>通过VC++编译器在函数前后添加额外的处理代码，前部分用于由伪随机数生成的cookie并放入.data节段，当本地变量初始化，就会向栈中插入cookie，它位于局部变量和返回地址之间在缓冲区溢出利用时，如果将恶意代码从局部变量覆盖到返回地址，那么自然就会覆写cookie，当检测到与原始cookie不同时，就会触发异常，最后终止进程。</p><p><strong>②.SafeSeh保护</strong></p><p>为了防止SEH节点被攻击者恶意利用，微软在．net编译器中加入&#x2F;sdeseh编译选项引入SafeSEH技术。编译器在编译时将PE文件所有合法的异常处理例程的地址解析出来制成一张表，放在PE文件的数据块(LQAJ)一C0N—FIG)中，并使用shareuser内存中的一个随机数加密，用于匹配检查。</p><p>如果该PE文件不支持safesEH，则表的地址为0。当PE文件被系统加载后，表中的内容被加密保存到ntdl1．dll模块的某个数据区。在PE文件运行期间，如果发生异常需要调用异常处理例程，系统会逐个检查该例程在表中是否有记录：如果没有则说明该例程非法，进而不执行该异常例程。</p><p><strong>③.ASLR保护</strong></p><p>ASLR（地址空间布局随机化）技术的主要功能是通过对系统关键地址的随机化，防止攻击者在堆栈溢出后利用固定的地址定位到恶意代码并加以运行。</p><p><strong>④.DEP保护</strong></p><p>数据执行保护 (DEP) 是一套软硬件技术，能够在内存上执行额外检查以防止在不可运行的内存区域上执行代码</p><p>这些保护机制的出现，一度使得攻击难度大大增加，但攻击者们也不是吃素的，他们也在研究绕过这些保护的办法。所谓千里之堤溃于蚁穴，对于上面的保护，攻击者只要找到了它们的一个弱点，便可以突破所有防线，实现攻击。攻击与防护，不断在对抗，可以预见，在未来一段时间，这种游戏还将持续上演。</p><p>但是，现在的漏洞门槛比十年前高了N倍，笔者在实际中也常常遇到有漏洞却不能利用的情况。但是也不要灰心，老的技术被淘汰，新的技术又会出来，本属正常，但像缓冲区溢出这种经典的东西，无论什么时候，都值得我们学习。</p><h3 id="磁盘调度算法以及磁盘空间存储管理？★★★★"><a href="#磁盘调度算法以及磁盘空间存储管理？★★★★" class="headerlink" title="*磁盘调度算法以及磁盘空间存储管理？★★★★"></a>*磁盘调度算法以及磁盘空间存储管理？★★★★</h3><p><a href="https://blog.csdn.net/lishanleilixin/article/details/89709194">https://blog.csdn.net/lishanleilixin/article/details/89709194</a></p><h3 id="文件系统中文件是如何组织的？★★"><a href="#文件系统中文件是如何组织的？★★" class="headerlink" title="*文件系统中文件是如何组织的？★★"></a>*文件系统中文件是如何组织的？★★</h3><p>文件的逻辑组织 文件的逻辑组织通常分为两种形式，即有结构文件（记录文件）和无结构文件（字符流文件）。1）有结构文件又称作记录式文件，它在逻辑上可被看成一组连续记录的集合，即文件是由若干个相关的记录组成。每个记录是一组相关的数据集合，用于描述一个对象某个方面的属性。记录式文件按其记录的长度是否相同又可分为：定长记录文件和变长记录文件两种。（1）定长记录文件：指文件中所有记录的长度都相同。文件的长度可用记录的数目来表示。定长记录处理方便，开销小，被广泛用于数据处理中。（2）变长记录文件：指文件中各记录的长度不相同。在处理之前每个记录的长度是已知的。2）无结构文件无结构文件是指文件内部不再划分记录，它是由一组相关信息组成的有序字符流，即流式文件，其长度直接按字节计算。如大量的源程序、可执行程序、库函数等采用的文件形式是无结构文件形式。在UNIX系统中，所有的普通文件都被看做是流式文件，系统不对文件进行格式处理。 ●常用的记录式结构有：连续结构、多重结构、转置结构和顺序结构。 ●常用的存取方法有顺序存取法、随机存取法（直接存取法）和按键存取法。 文件的物理组织 ●常用的文件物理结构有连续文件、串联文件和索引文件。 1）连续文件连续文件（又称做顺序文件）是基于磁带设备的最简单的物理文件结构，它是把一个逻辑上连续的文件信息存放在连续编号的物理块（或物理记录）中。连续文件的优点是在顺序存取时速度较快，常用于存放系统文件，如操作系统文件、编译程序文件和其它由系统提供的实用程序文件，因为这类文件往往被从头至尾依次存取。但连续文件也存在如下缺点：</p><p>（1）要求建立文件时就确定它的长度，依此来分配相应的存储空间，这往往很难实现。</p><p>（2）不便于文件的动态扩充。</p><p>（3）可能出现外部碎片，就是在存储介质上存在很多空闲块，但它们都不连续，无法被连续的文件使用，从而造成浪费。 2）串联文件为克服连续文件的缺点，可把一个逻辑上连续的文件分散存放在不同的物理块中，这些物理块不要求连续，也不必规则排列。为了使系统能找到下一个逻辑块所在的物理块，可在各物理块中设立一个指针（称为连接字），它指示该文件的下一个物理块。串连文件克服了连续文件的缺点，但它又带来新的问题：</p><p>（1）一般仅适于对信息的顺序访问，而不利于对文件的随机存取。</p><p>（2）每个物理块上增加一个连接字，为信息管理添加了一些麻烦。 FAT格式通过把文件分配表（FAT，File Allocation Table ）放在一个内存表格中的方式加以克服串联文件的缺点。 3）索引文件 索引文件是实现非连续分配的另一种方案：系统为每个文件建立一个索引表。其中的表项指出存放该文件的各个物理块号，而整个索引表由文件说明项指出。这种结构除了具备串连文件的优点之外，还克服了它的缺点。它可以方便地进行随机存取。但是这种组织形式需要增加索引表带来的空间开销。如果这些表格仅放在盘上，那么在存取文件时首先得取出索引表，然后才能查表、得到物理块号。这样就至少增加了一次访盘操作，从而降低了存取文件的速度，加重了 I&#x2F;O负担。一种改进办法是同时把索引表部分或全部地放人内存。这是以内存空间为代价来换取存取速度的改善。 树型目录结构树型目录结构可能是目录结构中，考的比较多的，考的也简单。</p><p>原文链接 <a href="https://zhidao.baidu.com/question/1946134093877936908.html">https://zhidao.baidu.com/question/1946134093877936908.html</a></p><h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><h3 id="冯诺依曼机的体系结构★★★★★"><a href="#冯诺依曼机的体系结构★★★★★" class="headerlink" title="*冯诺依曼机的体系结构★★★★★"></a>*冯诺依曼机的体系结构★★★★★</h3><p>主要由五大部件组成</p><p>1.存储器用来存放数据和程序</p><p>2.运算器主要运行算数运算和逻辑运算，并将中间结果暂存到运算器中</p><p>3.控制器主要用来控制和指挥程序和数据的输入运行，以及处理运算结果</p><p>4.输入设备用来将人们熟悉的信息形式转换为机器能够识别的信息形式，常见的有键盘，鼠标等</p><p>5.输出设备可以将机器运算结果转换为人们熟悉的信息形式，如打印机输出，显示器输出等</p><h3 id="衡量计算机性能指标★★★★"><a href="#衡量计算机性能指标★★★★" class="headerlink" title="*衡量计算机性能指标★★★★"></a>*衡量计算机性能指标★★★★</h3><p>1、<strong>吞吐量</strong>：表征一台计算机在某一时间间隔内能够处理的信息量，单位是字节&#x2F;秒。</p><p>2、<strong>响应时间</strong>：表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量，例如微秒（10-6S）、纳秒（10-9S）。</p><p>3、<strong>利用率</strong>：表示在给定的时间间隔内，系统被实际使用的时间所占的比率，一般用百分比表示。</p><p>4、<strong>处理机字长</strong>：指处理机运算器中一次能够完成二进制数运算的位数。当前处理机的字长有8位、16位、32位、64位。字长越长，表示计算的精度越高。</p><p>5、<strong>总线宽度</strong>：一般指CPU中运算器与存储器之间进行互连的内部总线二进制位数。</p><p>6、<strong>存储器容量</strong>：存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示。 其中K&#x3D;210，M&#x3D;220，G&#x3D;230，T&#x3D;240， B&#x3D;8位（1个字节）。</p><p>7、<strong>存储器带宽</strong>：存储器的速度指标，单位时间内从存储器读出的二进制数信息量，一般用字节数&#x2F;秒表示。</p><p>8、<strong>主频&#x2F;时钟周期</strong>：CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率（f）叫CPU的主频。度量单位是MHz、GHz。 主频的倒数称为CPU时钟周期（T），即T&#x3D;1&#x2F;f，度量单位是微秒、纳秒。</p><p>9、<strong>CPU执行时间</strong>：表示CPU执行一段程序所占用的CPU时间，可用下式计算： CPU执行时间 ＝ CPU时钟周期数 × CPU时钟周期长 CPI：表示每条指令周期数，即执行一条指令所需的平均时钟周期数。 用下式计算：</p><p>MIPS:每秒百万条数据。MIPS是单位时间内的执行指令数，所以MIPS值越高说明机器速度越快。 MFLOPS是基于操作而非指令的，只能用来衡量机器浮点操作的性能，而不能体现机器的整体性能。</p><h3 id="原码、反码、补码★★★"><a href="#原码、反码、补码★★★" class="headerlink" title="原码、反码、补码★★★"></a>原码、反码、补码★★★</h3><p>在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念.</p><p><strong>1、机器数</strong></p><p>一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.</p><p>比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。</p><p>那么，这里的 00000011 和 10000011 就是机器数。</p><p><strong>2、真值</strong></p><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。</p><p>所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p><p>例：0000 0001的真值 &#x3D; +000 0001 &#x3D; +1，1000 0001的真值 &#x3D; –000 0001 &#x3D; –1</p><p><strong>3. 原码</strong></p><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p><p>[+1]原 &#x3D; 0000 0001 [-1]原 &#x3D; 1000 0001</p><p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p><p>[1111 1111 , 0111 1111]&#x3D;&#x3D;&gt;[-127 , 127]</p><p><strong>4. 反码</strong></p><p>反码的表示方法是:</p><ul><li>正数的反码是其本身</li><li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</li></ul><p>[+1] &#x3D; [00000001]原 &#x3D; [00000001]反 [-1] &#x3D; [10000001]原 &#x3D; [11111110]反</p><p><strong>5. 补码</strong></p><p>补码的表示方法是:</p><ul><li>正数的补码就是其本身</li><li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</li></ul><p>[+1] &#x3D; [00000001]原 &#x3D; [00000001]反 &#x3D; [00000001]补 [-1] &#x3D; [10000001]原 &#x3D; [11111110]反 &#x3D; [11111111]补</p><h3 id="奇偶校验、汉明码校验，循环冗余校验★★"><a href="#奇偶校验、汉明码校验，循环冗余校验★★" class="headerlink" title="*奇偶校验、汉明码校验，循环冗余校验★★"></a>*奇偶校验、汉明码校验，循环冗余校验★★</h3><p><strong>奇偶校验：</strong></p><p>奇偶校验有两种校验规则：</p><ul><li>奇校验：使完整编码（有效位和校验位）中的”1”的个数为奇数个；</li><li>偶校验：使完整编码（有效位和校验位）中的”1”的个数为偶数个</li></ul><p>直接举例：</p><table><thead><tr><th>待编有效信息</th><th>奇校验码</th><th>偶校验码</th></tr></thead><tbody><tr><td>10111010</td><td>101110100</td><td>101110101</td></tr><tr><td>11010010</td><td>110100101</td><td>110100100</td></tr></tbody></table><p>因此，如果是奇校验，当待编有效信息的”1”为奇数个，在最后添0，偶数个添1，偶校验相反。</p><p>1.奇偶校验实际上就是对我们DnDn-1…D0进行异或运算（两两相同为0，不同为1），最后偶校验生成0，奇校验生成1，正确，反之错误。</p><p>上面表格，第一个我们使用奇校验，第二个使用偶校验。</p><p>第一个奇校验：1⊕0⊕1⊕1⊕1⊕0⊕1⊕0⊕0&#x3D;1</p><p>第二个偶校验：1⊕1⊕0⊕1⊕0⊕0⊕1⊕0⊕0&#x3D;0</p><p>2.如果第一个数据传输过去，变成111110100，很明显地D7变成了1，这时候再进行奇偶校验</p><p>1⊕1⊕1⊕1⊕1⊕0⊕1⊕0⊕0&#x3D;0</p><p>这样我们就能判断数据中出现了错误。</p><p><strong>汉明码校验：</strong></p><p><a href="https://blog.csdn.net/zhang175gl/article/details/88637223">https://blog.csdn.net/zhang175gl/article/details/88637223</a></p><p><strong>循环冗余校验：</strong></p><p><a href="https://blog.csdn.net/liyuanbhu/article/details/7882789">https://blog.csdn.net/liyuanbhu/article/details/7882789</a></p><h3 id="存储器的分类（RAM、DAM的区别）★★"><a href="#存储器的分类（RAM、DAM的区别）★★" class="headerlink" title="存储器的分类（RAM、DAM的区别）★★"></a>存储器的分类（RAM、DAM的区别）★★</h3><p>常见存储器分类图示</p><p>RAM：随机存取存储器是与CPU直接交换数据的内部存储器。它可以随时读写，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储媒介。当电源关闭时RAM不能保留数据。如果需要保存数据，就必须把它们写入一个长期的存储设备中（例如硬盘）。RAM和ROM相比，两者的最大区别是RAM在断电以后保存在上面的数据会自动消失，而ROM不会自动消失，可以长时间断电保存。</p><p>ROM：只读存储器。ROM所存数据，一般是装入整机前事先写好的，整机工作过程中只能读出，而不像随机存储器那样能快速地、方便地加以改写。ROM所存数据稳定，断电后所存数据也不会改变。</p><p>RAM可以分为SRAM（静态随机存储器）和DRAM（动态随机存储器）。</p><p>SRAM它是一种具有静止存取功能的内存，不需要刷新电路即能保存它内部存储的数据。优点是速度快，不必配合内存刷新电路，可提高整体的工作效率。缺点是集成度低，功耗较大，相同的容量体积较大，而且价格较高，少量用于关键性系统以提高效率。</p><p>DRAM是最为常见的系统内存。DRAM只能将数据保持很短的时间。为了保持数据，DRAM使用电容存储，所以必须隔一段时间刷新（refresh）一次，如果存储单元没有被刷新，存储的信息就会丢失。</p><p>SDRAM（同步动态随机存取存储器），是在DRAM的基础上发展而来，为DRAM的一种，同步是指Memory工作需要同步时钟，内部命令的发送与数据的传输都以时钟为基准；动态是指存储阵列需要不断的刷新来保证数据不丢失；随机是指数据不是线性依次存储，而是由指定地址进行数据读写。</p><p>DDR SDRAM又是在SDRAM的基础上发展而来，这种改进型的DRAM和SDRAM是基本一样的，不同之处在于它可以在一个时钟读写两次数据，这样就使得数据传输速度加倍了。这是目前电脑中用得最多的内存，而且它有着成本优势。</p><h3 id="段页式虚拟内存★★★"><a href="#段页式虚拟内存★★★" class="headerlink" title="段页式虚拟内存★★★"></a>段页式虚拟内存★★★</h3><h3 id="cpu一个指令周期的流程是什么？★★★★★"><a href="#cpu一个指令周期的流程是什么？★★★★★" class="headerlink" title="cpu一个指令周期的流程是什么？★★★★★"></a>cpu一个指令周期的流程是什么？★★★★★</h3><h3 id="总线通讯的四种方式★★"><a href="#总线通讯的四种方式★★" class="headerlink" title="总线通讯的四种方式★★"></a>总线通讯的四种方式★★</h3><h2 id="https-blog-csdn-net-yuanyuan320-article-details-110244550编译原理"><a href="#https-blog-csdn-net-yuanyuan320-article-details-110244550编译原理" class="headerlink" title="https://blog.csdn.net/yuanyuan320/article/details/110244550编译原理"></a><a href="https://blog.csdn.net/yuanyuan320/article/details/110244550%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86">https://blog.csdn.net/yuanyuan320/article/details/110244550编译原理</a></h2><h3 id="写出编译的过程；求first和follow集合★★★"><a href="#写出编译的过程；求first和follow集合★★★" class="headerlink" title="写出编译的过程；求first和follow集合★★★"></a>写出编译的过程；求first和follow集合★★★</h3><h3 id="上下文无关文法的特点★★★★"><a href="#上下文无关文法的特点★★★★" class="headerlink" title="上下文无关文法的特点★★★★"></a>上下文无关文法的特点★★★★</h3><h3 id="编译原理中的0、1、2、3型文法及其关系。★★★★★"><a href="#编译原理中的0、1、2、3型文法及其关系。★★★★★" class="headerlink" title="编译原理中的0、1、2、3型文法及其关系。★★★★★"></a>编译原理中的0、1、2、3型文法及其关系。★★★★★</h3><p>0型或短语文法：</p><p>产生式形如：α-&gt;β</p><p>其中：α、β属于字符串的闭包区间内且α至少包含有一个非终结符；</p><p>解释：左边有非终结符，右边有终结符。</p><p>举例：A-&gt;ab， A-&gt;Cb， A-&gt;b</p><p>0型文法是这几个文法中，限制最少的一个，一般见到的文法都可看做0型文法。0型文法的能力相当于图灵机（Turing）。</p><p>1型文法：又称为上下文有关文法：</p><p>产生式形如：α-&gt;β</p><p>其中：α-&gt;β均满足|α|&lt;&#x3D;|β|, 除了α-&gt;ε外；</p><p>解释：式子左边可以有多个字符，但必须有一个非终结符；式子右边可以有多个字符，可以是终结符，也可以是非终结符，但必须是有限个字符且左边长度必须小于右边</p><p>举例：A-&gt;B，A-&gt;Bba ，Bb-&gt;A，</p><p>2型文法：又称为上下文无关文法：</p><p>产生式形如： A -&gt;β</p><p>解释：式子左边必须是非终结符，然而一个终结符一个非终结符的组合不是一个非终结符，如Ab不是一个非终结符，但是两个非终结符的组合就是一个非终结符了，如AB就是行了；式子右边可以有多个字符，可以是终结符，也可以是非终结符，但必须是有限个字符</p><p>举例：AB-&gt;abc，B-&gt;ab</p><p>3型文法：又称为正规文法（正规文法又包括左线性文法和右线性文法）：</p><p>右线性文法：</p><p>产生式形如： A -&gt;αB 或 A -&gt;α</p><p>解释：式子左边只能有一个字符，而且必须是非终结符；式子右边最多有二个字符。如果有二个字符必须是（终结符+非终结符）的格式，如果是一个字符，那么必须是终结符。</p><p>举例：B-&gt;aB</p><p>左线性文法：</p><p>产生式形如： A -&gt;Bα 或 A -&gt;α</p><p>解释：式子左边只能有一个字符，而且必须是非终结符；式子右边最多有二个字符。如果有二个字符必须是（非终结符+终结符）的格式，如果是一个字符，那么必须是终结符。</p><p>举例：B-&gt;Ba</p><p>原文链接：<a href="https://blog.csdn.net/MillionSong/article/details/105672676">https://blog.csdn.net/MillionSong/article/details/105672676</a></p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="一二三范式★★★★★"><a href="#一二三范式★★★★★" class="headerlink" title="*一二三范式★★★★★"></a>*一二三范式★★★★★</h3><p><strong>第一范式 (1NF)</strong></p><p>属性不可分。即数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体</p><p>中的某个属性不能有多个值或者不能有重复的属性。</p><p><strong>第二范式 (2NF)</strong></p><p>每个非主属性完全函数依赖于键码。可以通过分解来满足 2NF。</p><p><strong>第三范式 (3NF)</strong></p><p>非主属性不传递函数依赖于键码。简而言之，第三范式就是属性不依赖于其它非主属性。</p><h3 id="SQL查询语句★★"><a href="#SQL查询语句★★" class="headerlink" title="SQL查询语句★★"></a>SQL查询语句★★</h3><h3 id="数据库有什么类型的数据库、关系型数据库的特点★★★★"><a href="#数据库有什么类型的数据库、关系型数据库的特点★★★★" class="headerlink" title="数据库有什么类型的数据库、关系型数据库的特点★★★★"></a>数据库有什么类型的数据库、关系型数据库的特点★★★★</h3><h3 id="数据库有几种锁？★★★"><a href="#数据库有几种锁？★★★" class="headerlink" title="数据库有几种锁？★★★"></a>数据库有几种锁？★★★</h3><p>共享（S)锁：多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S锁立即被释放。</p><p>排它（X)锁：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。</p><p>更新（U)锁：用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。</p><h3 id="数据库的三个完整性约束★★★★"><a href="#数据库的三个完整性约束★★★★" class="headerlink" title="数据库的三个完整性约束★★★★"></a>数据库的三个完整性约束★★★★</h3><p>实体完整性，参照完整性和用户自定义完整性约束。实体完整性规定表的每一行在表中是唯一的实体。</p><p>参照完整性指两个表的主关键字和外关键字的数据一致，保证表之间的数据一致性，防止数据丢失或无意义的数据在数据库中扩散。</p><p>用户自定义完整性是不同数据库根据应用环境不同，用户定义的一些特殊约束条件。</p><h3 id="事务与锁？什么是事物？什么事锁？事务的四个特性是什么？★★★★★"><a href="#事务与锁？什么是事物？什么事锁？事务的四个特性是什么？★★★★★" class="headerlink" title="*事务与锁？什么是事物？什么事锁？事务的四个特性是什么？★★★★★"></a>*事务与锁？什么是事物？什么事锁？事务的四个特性是什么？★★★★★</h3><p>什么是事务？</p><p>事务是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。</p><p>什么是锁？</p><p>锁是用于解决隔离性的一种机制。事务的隔离级别通过锁的机制来实现。</p><p>事物的四个特性（ACID）：</p><p>原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</p><p>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。</p><p>隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p><p>持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p><p>链接：</p><p>1.<a href="https://blog.csdn.net/qq_37206355/article/details/105475028">https://blog.csdn.net/qq_37206355/article/details/105475028</a></p><p>2.<a href="https://www.cnblogs.com/tjw-bk/p/13974795.html">https://www.cnblogs.com/tjw-bk/p/13974795.html</a></p><h3 id="存储过程是什么？触发器是什么？为什么要使用存储过程？★★★"><a href="#存储过程是什么？触发器是什么？为什么要使用存储过程？★★★" class="headerlink" title="存储过程是什么？触发器是什么？为什么要使用存储过程？★★★"></a>存储过程是什么？触发器是什么？为什么要使用存储过程？★★★</h3><p>存储过程（Stored Procedure）是在大型<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/215176">数据库系统</a>中，一组为了完成特定功能的SQL 语句集，它存储在数据库中，一次<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91/1258343">编译</a>后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。在数据量特别庞大的情况下利用存储过程能达到倍速的效率提升。</p><p>触发器（trigger）是SQL server 提供给<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%91%98/62748">程序员</a>和数据分析员来保证<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7/110071">数据完整性</a>的一种方法，它是与表事件相关的特殊的存储过程，它的<a href="https://baike.baidu.com/item/%E6%89%A7%E8%A1%8C/3166225">执行</a>不是由程序调用，也不是手工启动，而是由事件来触发，<a href="https://baike.baidu.com/item/%E6%AF%94%E5%A6%82">比如</a>当对一个表进行操作（ insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等。</p><p>存储过程处理比较复杂的业务时比较实用。 比如说，一个复杂的数据操作。如果你在前台处理的话。可能会涉及到多次数据库连接。但如果你用存储过程的话。就只有一次。从响应时间上来说有优势。 也就是说存储过程可以给我们带来运行效率提高的好处。 另外，程序容易出现 BUG 不稳定，而存储过程，只要数据库不出现问题，基本上是不会出现什么问题的。也就是说从安全上讲，使用了存储过程的系统更加稳定。</p><p>1.存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。 2.当对数据库进行复杂操作时(如对多个表进行 Update,Insert,Query,Delete 时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。这些操作，如果用程序来完成，就变成了一条条的 SQL 语句，可能要多次连接数据库。而换成存储，只需要连接一次数据库就可以了。 3.存储过程可以重复使用,可减少数据库开发人员的工作量。 4.安全性高,可设定只有某此用户才具有对指定存储过程的使用权。</p><p>存储过程的缺点 1：调试麻烦，但是用 PL&#x2F;SQL Developer 调试很方便！弥补这个缺点。 2：移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。 3：重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。 4：如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的。维护起来更加麻烦！</p><h3 id="数据库的ACID特性，事务回滚，如何解决数据的不一致？事务的ACID特性怎么保证？（REDO-x2F-UNDO机制）★★★"><a href="#数据库的ACID特性，事务回滚，如何解决数据的不一致？事务的ACID特性怎么保证？（REDO-x2F-UNDO机制）★★★" class="headerlink" title="数据库的ACID特性，事务回滚，如何解决数据的不一致？事务的ACID特性怎么保证？（REDO&#x2F;UNDO机制）★★★"></a>数据库的ACID特性，事务回滚，如何解决数据的不一致？事务的ACID特性怎么保证？（REDO&#x2F;UNDO机制）★★★</h3><h3 id="Mysql的存储引擎及区别★★★"><a href="#Mysql的存储引擎及区别★★★" class="headerlink" title="*Mysql的存储引擎及区别★★★"></a>*Mysql的存储引擎及区别★★★</h3><p>只要记住重要的几个引擎：InnoDB、MyISAM、Memory、Archive。不过其他的还有BLACKHOLE和CSV。</p><p>主要对比一下前两个和中间两个。</p><p>INNODB：</p><p>用于事务处理应用程序，支持外键和行级锁。如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包括很多更新和删除操作，那么InnoDB存储引擎是比较合适的。</p><p>InnoDB除了有效的降低由删除和更新导致的锁定，还可以确保事务的完整提交和回滚，</p><p>对于类似计费系统或者财务系统等对数据准确要求性比较高的系统都是合适的选择。</p><p>MyISAM：</p><p>如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那么可以选择这个存储引擎。</p><p>Memory：</p><p>将所有的数据保存在内存中，在需要快速定位记录和其他类似数据的环境下，可以提供极快的访问。Memory的缺陷是对表的大小有限制，虽然数据库因为异常终止的话数据可以正常恢复，但是一旦数据库关闭，存储在内存中的数据都会丢失。</p><p>ARCHIVE：</p><p>拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩。支持最基本的插入和查询两种功能。在MySQL 5.5开始支持索引。不支持事务。支持行级锁和专用的缓存区，所以可以实现高并发的插入。适合存储大量日志、历史数据。</p><p>是的，只有INNODB支持事务操作，INNODB也是MySQL的默认引擎，个人认为最重要的一个。</p><p>参考CSDN：<a href="https://blog.csdn.net/zgrgfr/article/details/74455547">https://blog.csdn.net/zgrgfr/article/details/74455547</a></p><ol><li><strong>如何优化数据库？提高查询的效率？</strong>★★★★★★</li></ol><p><a href="https://blog.csdn.net/xlgen157387/article/details/44156679">https://blog.csdn.net/xlgen157387/article/details/44156679</a></p><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><h3 id="什么是软件工程？软件工程三要素？★★★"><a href="#什么是软件工程？软件工程三要素？★★★" class="headerlink" title="什么是软件工程？软件工程三要素？★★★"></a>什么是软件工程？软件工程三要素？★★★</h3><p>软件工程三要素包括：方法、工具和过程。</p><h3 id="软件生存周期？★"><a href="#软件生存周期？★" class="headerlink" title="软件生存周期？★"></a>软件生存周期？★</h3><h3 id="软件开发模型？★"><a href="#软件开发模型？★" class="headerlink" title="软件开发模型？★"></a>软件开发模型？★</h3><h3 id="黑盒测试和白盒测试有什么区别？★★★"><a href="#黑盒测试和白盒测试有什么区别？★★★" class="headerlink" title="*黑盒测试和白盒测试有什么区别？★★★"></a>*黑盒测试和白盒测试有什么区别？★★★</h3><p><strong>一、测试方式不同</strong></p><p>1、黑盒测试：功能测试，是通过测试来检测每个功能是否都能正常使用。</p><p>2、白盒测试：称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。</p><p><strong>二、测试目的不同</strong></p><p>1、黑盒测试：把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。</p><p>2、白盒测试：通过检查软件内部的逻辑结构，对软件中的逻辑路径进行覆盖测试。在程序不同地方设立检查点，检查程序的状态，以确定实际运行状态与预期状态是否一致。</p><p><strong>三、测试原则不同</strong></p><p>1、黑盒测试：以用户的角度，从输入数据与输出数据的对应关系出发进行测试的。很明显，如果外部特性本身设计有问题或规格说明的规定有误，用黑盒测试方法是发现不了的。</p><p>2、白盒测试：一个模块中的所有独立路径至少被测试一次。所有逻辑值均需测试true和false两种情况。</p><h3 id="敏捷开发和瀑布模型的区别★"><a href="#敏捷开发和瀑布模型的区别★" class="headerlink" title="敏捷开发和瀑布模型的区别★"></a>敏捷开发和瀑布模型的区别★</h3><h3 id="配置管理包括哪些活动★"><a href="#配置管理包括哪些活动★" class="headerlink" title="配置管理包括哪些活动★"></a>配置管理包括哪些活动★</h3><h3 id="持续集成及其特性★"><a href="#持续集成及其特性★" class="headerlink" title="持续集成及其特性★"></a>持续集成及其特性★</h3><h3 id="说一个你了解的设计模式？结合项目举个例子？★★★★★★"><a href="#说一个你了解的设计模式？结合项目举个例子？★★★★★★" class="headerlink" title="*说一个你了解的设计模式？结合项目举个例子？★★★★★★"></a>*说一个你了解的设计模式？结合项目举个例子？★★★★★★</h3><p><strong>总体来说设计模式分为三大类：</strong></p><p><strong>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</strong></p><p><strong>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</strong></p><p><strong>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</strong></p><p><strong>其实还有两类：并发型模式和线程池模式。</strong></p><h3 id="介绍下MVC模式★★★★"><a href="#介绍下MVC模式★★★★" class="headerlink" title="*介绍下MVC模式★★★★"></a>*介绍下MVC模式★★★★</h3><p>MVC 模式（Model–view–controller）是软件工程中的一种软件架构模式，它把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p><p>MVC 模式的目的是实现一种动态的程序设计，简化后续对程序的修改和扩展，并且使程序某一部分的重复利用成为可能。除此之外，MVC 模式通过对复杂度的简化，使程序的结构更加直观。软件系统在分离了自身的基本部分的同时，也赋予了各个基本部分应有的功能。专业人员可以通过自身的专长进行相关的分组：</p><p><strong>模型（Model）</strong>：程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)；</p><p><strong>控制器（Controller）</strong>：负责转发请求，对请求进行处理；</p><p><strong>视图（View）</strong>：界面设计人员进行图形界面设计。</p><p>具体：<a href="https://blog.csdn.net/liitdar/article/details/86685880">https://blog.csdn.net/liitdar/article/details/86685880</a></p><h2 id="算法分析与设计"><a href="#算法分析与设计" class="headerlink" title="算法分析与设计"></a>算法分析与设计</h2><h3 id="动态规划和分治、贪心相比有什么区别？各自的优缺点？"><a href="#动态规划和分治、贪心相比有什么区别？各自的优缺点？" class="headerlink" title="动态规划和分治、贪心相比有什么区别？各自的优缺点？"></a>动态规划和分治、贪心相比有什么区别？各自的优缺点？</h3><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="指针和引用的区别★★★★★"><a href="#指针和引用的区别★★★★★" class="headerlink" title="指针和引用的区别★★★★★"></a>指针和引用的区别★★★★★</h3><p>★相同点：</p><p>●都是地址的概念；</p><p>指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。</p><p>★不同点：</p><p>●指针是一个实体，而引用仅是个别名；</p><p>●引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；</p><p>●引用没有const，指针有const，const的指针不可变；</p><p>●引用不能为空，指针可以为空；</p><p>●“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；</p><p>●指针和引用的自增(++)运算意义不一样；</p><p>●引用是类型安全的，而指针不是 (引用比指针多了类型检查</p><p>参考：<a href="https://blog.csdn.net/xdrt81y/article/details/18004129">https://blog.csdn.net/xdrt81y/article/details/18004129</a></p><h3 id="浅拷贝和深拷贝★★★"><a href="#浅拷贝和深拷贝★★★" class="headerlink" title="浅拷贝和深拷贝★★★"></a>浅拷贝和深拷贝★★★</h3><p><a href="https://blog.csdn.net/jiang7701037/article/details/98738487">https://blog.csdn.net/jiang7701037/article/details/98738487</a></p><h3 id="程序的编译执行过程★★★★★★"><a href="#程序的编译执行过程★★★★★★" class="headerlink" title="程序的编译执行过程★★★★★★"></a>程序的编译执行过程★★★★★★</h3><ol><li>第一步，预处理. 这一步处理 头文件、条件编译指令和宏定义。</li><li>第二步，编译. 将第一步产生的文件连同其他源文件一起编译成汇编代码。</li><li>第三步，汇编。将第二步产生的汇编源码转换为 object file.</li><li>第四步，链接. 将第三步产生的一些object file 链接成一个可执行的文件。</li></ol><h3 id="知道c-中的符号重载吗？★★★"><a href="#知道c-中的符号重载吗？★★★" class="headerlink" title="*知道c++中的符号重载吗？★★★"></a>*知道c++中的符号重载吗？★★★</h3><p>C++的预定义运算符的操作对象是基本的内置数据类型，对自定义数据类型，结构体或者类无法操作。符号重载可以可以自定义运算符的操作对象和运算规则，满足对自定义数据类型的需求。</p><p>实质上，运算符重载就是函数重载，语法形式如下：</p><p>&lt;返回类型说明符&gt; operator &lt;运算符符号&gt;(&lt;参数表&gt;)</p><p>{</p><p>&lt;函数体&gt;</p><p>}</p><p>函数重载的话，需要操作对象中至少有一个是用户自定义类型，避免导致重载之后出现歧义。出自之外，不能违背原本的语法规则，不能修改运算符的优先级，不能创建新的运算符等等，总之不能使得原有的运算规则出现错乱。</p><p>参考CSDN：<a href="https://blog.csdn.net/lishuzhai/article/details/50781753">https://blog.csdn.net/lishuzhai/article/details/50781753</a></p><h3 id="C-中如何实现多态？★★★"><a href="#C-中如何实现多态？★★★" class="headerlink" title="C++中如何实现多态？★★★"></a>C++中如何实现多态？★★★</h3><p>有一对继承关系的两个类，这两个类里面都有一个函数且名字、参数、返回值均相同，然后我们通过调用函数来实现不同类对象完成不同的事件。</p><p>多态的前提：</p><p>1. 调用函数的对象必须是指针或者引用。</p><p>2. 被调用的函数必须是虚函数，且完成了虚函数的重写</p><p><a href="https://blog.csdn.net/qq_39412582/article/details/81628254?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164171428616780265456117%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164171428616780265456117&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2%5C~blog%5C~first_rank_ecpm_v1%5C~hot_rank-3-81628254.nonecase&utm_term=C++%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81&spm=1018.2226.3001.4450">https://blog.csdn.net/qq_39412582/article/details/81628254?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164171428616780265456117%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=164171428616780265456117&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2\~blog\~first_rank_ecpm_v1\~hot_rank-3-81628254.nonecase&amp;utm_term=C%2B%2B%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81&amp;spm=1018.2226.3001.4450</a></p><h3 id="java和c-和c的区别（准备下英文）★★★★★★"><a href="#java和c-和c的区别（准备下英文）★★★★★★" class="headerlink" title="*java和c++和c的区别（准备下英文）★★★★★★"></a>*java和c++和c的区别（准备下英文）★★★★★★</h3><p>参考资料：<a href="https://blog.csdn.net/weixin_42482896/article/details/93380006">https://blog.csdn.net/weixin_42482896/article/details/93380006</a></p><p>百度翻译+人工润色：</p><p>1. Java不能在类之外的地方定义全局变量，只能在一个类中定义静态变量来实现一个全局变量。</p><p>C&#x2F;C++可以直接在类之外定义全局变量。</p><p>Java can’t define global variables outside a class, it can only define static variables in a class as a global variable.</p><p>2. Java不支持C&#x2F;C++的goto语句，而是通过try、catch来代替C&#x2F;C++的goto来处理异常时控制。</p><p>Java doesn’t support “goto” statements of C&#x2F;C++, but uses try&#x2F;catch syntax instead of “goto” for exception control.</p><p>3. C&#x2F;C++可以通过指针进行内存地址操作，例如通过指针对某内存地址进行显式类型转换，而这种操作访问私有成员破坏了安全性。</p><p>Java对指针进行完全的控制，不能在程序中进行任何指针操作，Java中的数组作为类实现，解决了关于数组的很多C&#x2F;C++难以检查的错误。</p><p>C&#x2F;C++ can operate memory address through pointer. For Example, C&#x2F;C++ makes explicitly conversion to a memory address by pointer, which destroys the security of the program because it accesses private members. Java Controls pointer completely, and can not operate any pointer in the program. The array in Java is implemented as a class, which solves many errors about array which are difficult to check in c&#x2F;c++.</p><p>4. 在C语言中通过malloc和free函数分配和释放内存；C++中可以通过new和delete进行内存的分配和释放。在Java中通过new运算符分配内存，进行对象实例化，而分配内存时随着程序运行动态分配，且Java能够进行自动管理和自动垃圾回收，防止内存资源产生的操作错误和浪费。</p><p>In C language, malloc function and free function are used to allocate and release memory; In C + +, memory can be allocated and released by new and delete keywords. In Java, the new operator is used to allocate memory and instantiate objects, and the allocated memory is dynamically allocated with the running of the program. Java can automatically manage memory and recycle garbage, so as to prevent memory operation errors and memory waste.</p><p>5. C&#x2F;C++对于不同的平台，数据类型的长度不同，代码不可移植。Java对数据类型总是分配固定长度位数，保证平台无关性。</p><p>The length of data type of C&#x2F;C++ is different in different platforms, so the code is not portable. Java always allocates a fixed number of bits to data type to ensure platform independence.</p><p>6. C++可以通过指针进行任意类型的转换，Java在进行类型转换时会进行类型相容性检查，防止不安全的转换。</p><p>C++ can do any type conversion by pointer. Java will check the type compatibility to prevent unsafe conversion.</p><p>7. C&#x2F;C++中用头文件声明类的原型及全局变量、库函数，在大的系统中难以维护这些文件。Java不支持头文件，所有类成员的类型和访问权限都封装在一个类中，运行时系统对访问会进行控制防止对私有成员的操作；导入其他类要使用import语句。</p><p>In C&#x2F;C++, header files are used to declare class prototypes, global variables and library functions, which are diffcult to maintain in large systems. Java does not support header files. The types and access rights of all class members are encapsulated in one class. When the program is running, the system will control the access to prevent the operation of private members.</p><p>8. C++中的结构体和联合体所有成员都是共有的，这有一定的安全问题。Java中没有结构体和联合体，一切内容都封装在类中。</p><p>All members of C++ structure and union are public, so there are some security problems. There is no structure or union in Java, everything is encapsulated in class.</p><p>9. C++支持宏定义，Java不支持宏定义，而是通过final来声明一个常量，实现宏定义中常量的定义。</p><p>C + + supports macro definition. Java does not support macro definition, but declares a constant through the final keyword to realize the definition of constant equivalent to macro definition.</p><h3 id="Java的垃圾回收算法★★★"><a href="#Java的垃圾回收算法★★★" class="headerlink" title="Java的垃圾回收算法★★★"></a>Java的垃圾回收算法★★★</h3><h3 id="Jvm的内存管理★★★"><a href="#Jvm的内存管理★★★" class="headerlink" title="Jvm的内存管理★★★"></a>Jvm的内存管理★★★</h3><h3 id="全局变量是好是坏？★★"><a href="#全局变量是好是坏？★★" class="headerlink" title="全局变量是好是坏？★★"></a>全局变量是好是坏？★★</h3><h2 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h2><h3 id="泰勒展开和傅立叶变换的概念以及他们在计算机领域中的应用★★★★★★"><a href="#泰勒展开和傅立叶变换的概念以及他们在计算机领域中的应用★★★★★★" class="headerlink" title="*泰勒展开和傅立叶变换的概念以及他们在计算机领域中的应用★★★★★★"></a>*泰勒展开和傅立叶变换的概念以及他们在计算机领域中的应用★★★★★★</h3><p>为了便于研究复杂的函数，用多项式来近似表达函数可以简单地进行计算，而泰勒多项式就是用多项式近似函数的一种方法，函数在某一点处展开为泰勒多项式就是泰勒展开。</p><p>泰勒多项式在计算机领域是数值分析的理论基础之一，数值微积分的很多定理和结论都是由泰勒展开推导得出。</p><p>参考《同济第七版 高等数学 上册》 第137页泰勒公式</p><p>傅里叶变换和其逆变换是一对互逆的运算，是用于对函数进行变换的工具。傅里叶变换可以将时域的非周期连续信号，转换为频域的非周期连续信号。</p><p>傅里叶变换的用途：在信号处理上，可以轻松地滤掉特定频率成分的波；在求解微分方程上，可以让微分和积分在频率中变为乘法和除法；在计算机科学中，作为DFT算法的理论基础。</p><p>感兴趣可以参考：</p><p><a href="https://zhuanlan.zhihu.com/p/19763358">https://zhuanlan.zhihu.com/p/19763358</a></p><h3 id="傅里叶变换和傅里叶级数的区别★★★"><a href="#傅里叶变换和傅里叶级数的区别★★★" class="headerlink" title="*傅里叶变换和傅里叶级数的区别★★★"></a>*傅里叶变换和傅里叶级数的区别★★★</h3><p>傅里叶级数是一个函数的近似表达，是将一个函数通过三角函数系进行表达的表达式。傅里叶级数仍然是一个函数。傅里叶级数拥有三角和复数两种表达形式。</p><p>而傅里叶变换是“函数的函数”，是一个对函数进行变换，使其拥有不同的特性，从时域转换到频域的工具。傅里叶变换是从傅里叶级数的复数形式推导而来。</p><p>参考百度百科词条：“傅里叶变换”</p><h3 id="函数零点和极值点怎么求？★★★★★"><a href="#函数零点和极值点怎么求？★★★★★" class="headerlink" title="*函数零点和极值点怎么求？★★★★★"></a>*函数零点和极值点怎么求？★★★★★</h3><p>函数的零点求法：</p><p>首先是，解析解：令函数值等于0，然后解方程得到零点。</p><p>对于过于复杂无法求方程解的情况，使用数值方法：二分法、牛顿迭代法</p><p>极值点：</p><p>对函数求导，然后令导函数等于0，按照上述方法求导函数的零点即可，对于所得零点判断解的两端导函数值的符号，</p><p>若两端同号，所得的解是驻点而不是极值点，</p><p>若两端异号，就是极值点。</p><h3 id="判断两个无穷集合的大小，单射满射和双射的概念？★★★"><a href="#判断两个无穷集合的大小，单射满射和双射的概念？★★★" class="headerlink" title="*判断两个无穷集合的大小，单射满射和双射的概念？★★★"></a>*判断两个无穷集合的大小，单射满射和双射的概念？★★★</h3><p>判断无穷集合的大小要引入“势”的概念，在谈论这个问题之前，需要先说说双射的概念。有穷集合和无穷集合相比的差别。</p><p>首先是，满射和单射。若A到B的函数满足“任一值域B中的一个值都存在定义域A中唯一的值与之对应”，这个函数就是单射的，若函数满足值域为集合B，就称函数时满射的。</p><p>接着是，若函数既是单射的又是满射的，就称作函数是双射的，这意味着函数的定义域为集合A，值域为集合B，且是单调函数。例如直线方程y&#x3D;kx+b，是集合R-&gt;R的双射函数，例如函数y&#x3D;tanx是(0,1)-&gt;R的双射函数。</p><p>参考《离散数学 屈婉玲》137页</p><p>无穷集合的大小通过集合的势来衡量，若是一个集合的势小于自然数集的势“阿列夫零”，它就是有穷集。假如两个集合之间能够建立一一映射，那就是等势的，例如整数集、偶数集、有理数集都和自然数集等势，也就是一样大小。而实数集和它任一子集都是等势的，且大于自然数集。且康托定理指出，一个集合的幂集都大于当前集合。</p><h3 id="欧氏距离及常见距离公式的缺点？★★★★★"><a href="#欧氏距离及常见距离公式的缺点？★★★★★" class="headerlink" title="*欧氏距离及常见距离公式的缺点？★★★★★"></a>*欧氏距离及常见距离公式的缺点？★★★★★</h3><p>欧氏距离也就是n维空间中两点之间的线段长度。</p><p>1 欧氏距离的缺点在于，会受到数据尺度的影响而产生偏斜，需要对数据进行归一化后使用。</p><p>2 余弦相似距离缺点在于只考虑了数据的方向，而没考虑向量的大小，受到数据尺度的影响较大。</p><p>3 曼哈顿距离就是街道距离，缺点在于不够直观，并且距离不是最短距离。</p><p>参考资料：<a href="https://blog.csdn.net/Datawhale/article/details/113787498">https://blog.csdn.net/Datawhale/article/details/113787498</a></p><h3 id="最大似然估计是什么？★★★★★"><a href="#最大似然估计是什么？★★★★★" class="headerlink" title="*最大似然估计是什么？★★★★★"></a>*最大似然估计是什么？★★★★★</h3><p>该方法的直观想法就是，取到了某一样本值，那么就表明取到这一样本的概率较大，因此认为取使得这一样本值的概率最大的参数值比较合理。</p><p>操作方法就是，固定样本的观察值，在参数的取值空间中挑选使得似然函数在该样本值下达到最大值的参数，作为参数的估计值。</p><p>《概统 浙大第四版》152页</p><h3 id="梯度方向导数与梯度下降？★★★★★"><a href="#梯度方向导数与梯度下降？★★★★★" class="headerlink" title="*梯度方向导数与梯度下降？★★★★★"></a>*梯度方向导数与梯度下降？★★★★★</h3><p>方向导数：各个坐标轴的偏导数组成的向量，和方向向量的内积</p><p>梯度：就是各个偏导数组成的向量</p><p>《同济第七版高等数学下册》103页</p><p>梯度下降法：从函数的任一点开始，沿着该店梯度反方向运动一段距离，再沿新位置的梯度反方向运行一段距离，如此迭代一直超着函数下坡最陡的方向运动，以此运动到函数的近似极小点。</p><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/25387613">https://zhuanlan.zhihu.com/p/25387613</a></p><h3 id="复合函数求导公式？给出函数让求？★★"><a href="#复合函数求导公式？给出函数让求？★★" class="headerlink" title="*复合函数求导公式？给出函数让求？★★"></a>*复合函数求导公式？给出函数让求？★★</h3><p>首先是，复合函数的概念，复合函数就是多个函数构成的函数，它的求导法则就是“链式法则”，如果某个函数由复合函数表示，则该复合函数的求导可以用构成复合函数的各个函数的导数的乘积表示。</p><h3 id="导数和偏导数的区别？★★"><a href="#导数和偏导数的区别？★★" class="headerlink" title="*导数和偏导数的区别？★★"></a>*导数和偏导数的区别？★★</h3><p>导数是针对一元函数的概念，即函数f对自变量x的导函数，又称导数、微商。</p><p>而偏导数是针对多元函数来讲的，多元函数对某一个自变量的导函数称作偏导数。</p><h3 id="可导、可微、连续、可积之间的关系（一元函数-二元函数）★★★"><a href="#可导、可微、连续、可积之间的关系（一元函数-二元函数）★★★" class="headerlink" title="*可导、可微、连续、可积之间的关系（一元函数+二元函数）★★★"></a>*可导、可微、连续、可积之间的关系（一元函数+二元函数）★★★</h3><p>一元函数：</p><p>可微和可导互为充分必要条件，可导比连续，连续不一定可导，</p><p>连续必可积，可积不一定连续</p><p>二元函数：</p><p>可微必连续，连续不一定可微</p><p>若连续则二重极限存在，反之不成立</p><p>连续必可积，可积不一定连续。</p><p>参考资料：《高等数学解题方法技巧归纳 毛纲源 下册》《数学分析 华师大 上册》截图：</p><p>《数学分析》 截图</p><h3 id="三个中值定理的区别、联系和物理意义（罗尔、拉格朗日、柯西）★★★"><a href="#三个中值定理的区别、联系和物理意义（罗尔、拉格朗日、柯西）★★★" class="headerlink" title="*三个中值定理的区别、联系和物理意义（罗尔、拉格朗日、柯西）★★★"></a>*三个中值定理的区别、联系和物理意义（罗尔、拉格朗日、柯西）★★★</h3><p>参考知乎：<a href="https://zhuanlan.zhihu.com/p/47436090">https://zhuanlan.zhihu.com/p/47436090</a></p><p>罗尔中值定理：函数f(x)在闭区间连续，开区间可导，区间端点函数值相等，必存在一点导数值为0</p><p>拉格朗日中值定理：函数f(x)在闭区间连续，开区间可导，必存在一点导数值等于端点连线的斜率。</p><p>罗尔中值定理：函数f(x)和g(x)在闭区间连续，开区间可导，且任意一点g(x)导数值不为0，必存在一点，f(x)导函数和g(x)导函数的比值，等于两函数区间端点函数值之差的比值。</p><p>区别在于，罗尔定理要求区间端点函数值相等，拉格朗日中值定理则不要求。柯西中值定理关系到两个函数</p><p>联系在于，柯西中值定理当g(x)&#x3D;x的时候，退化为拉格朗日中值定理，拉格朗日中值定理的区间端点函数值相等的时候，退化为罗尔中值定理。</p><p>物理意义在于，罗尔定理表明往复运动的始终必存在某一时刻速度为0。拉格朗日中值定理表明一段物体从一个地方移动到另一个地方的始终，中间必有一点加速度为0。柯西中值定理表明一段曲线运动的过程中，必有一点速度方向和位移方向相同。</p><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><h3 id="矩阵的秩-满秩代表什么？不满秩呢？★★★★★"><a href="#矩阵的秩-满秩代表什么？不满秩呢？★★★★★" class="headerlink" title="*矩阵的秩,满秩代表什么？不满秩呢？★★★★★"></a>*矩阵的秩,满秩代表什么？不满秩呢？★★★★★</h3><p>参考资料：《线性代数 成立波》56页</p><p>矩阵A的不等于零的子式的最高阶数称作矩阵A的秩。</p><p>一个秩为n的矩阵满秩意味着存在一个n阶子式不为0.</p><p>不满秩的话，假设其秩为r，意味着所有大于r阶的子式都为0.</p><h3 id="什么是线性相关？什么是线性无关？★★★★★"><a href="#什么是线性相关？什么是线性无关？★★★★★" class="headerlink" title="*什么是线性相关？什么是线性无关？★★★★★"></a>*什么是线性相关？什么是线性无关？★★★★★</h3><p>对于线性空间中的n个向量，假如存在n个常数使得这n个常数与n个向量对应乘积加合等于0，则称这n个向量线性相关，如果不存在这样的n个常数，称之为线性无关。</p><p>参考资料：《线性代数 成立波》65页</p><h3 id="什么是向量空间？线性空间？★★★★-0703赵轲"><a href="#什么是向量空间？线性空间？★★★★-0703赵轲" class="headerlink" title="*什么是向量空间？线性空间？★★★★(0703赵轲)"></a>*什么是向量空间？线性空间？★★★★(0703赵轲)</h3><p>所有n维向量构成的集合称为n维向量空间。</p><p>将n维向量空间抽象化，便引出线性空间的概念。定义集合V上的两种代数运算：加法和数乘。V中任意两向量之和与V中的一个向量gamma对应；V中任意向量和域K中的任一数lambda的数乘与V中的一个向量eta对应。</p><p>并且加法满足交换律、结合律、零元、逆元，数乘存在单位元、满足结合律，数乘关于加法满足分配律。</p><p>那么这个集合V就称作线性空间，又叫向量空间。V中的元素统称为“向量“。</p><p>参考资料：《线性代数与矩阵论 许以超》书不好找，直接放截图了</p><p>这里的“纯量积”其实就是数乘：常数乘向量（伸缩变换）</p><h3 id="什么是向量的基？★★★"><a href="#什么是向量的基？★★★" class="headerlink" title="*什么是向量的基？★★★"></a>*什么是向量的基？★★★</h3><p>在线性空间V中可以找到n个向量，这n个向量线性无关，并且线性空间V中的任意一个向量都和这n个向量线性相关，那么这n个向量就称作线性空间V的基。</p><p>参考资料：《线性代数与矩阵论 许以超》书不好找，直接放截图了</p><h3 id="什么是向量正交？什么是矩阵正交？★★"><a href="#什么是向量正交？什么是矩阵正交？★★" class="headerlink" title="*什么是向量正交？什么是矩阵正交？★★"></a>*什么是向量正交？什么是矩阵正交？★★</h3><p>正交向量组中，任意两个向量的数量积为0.</p><p>正交矩阵的每一列都是一个单位向量，并且任意两列求数量积都为0.</p><p>两个矩阵正交，表示这两个矩阵相乘结果为单位矩阵。</p><p>参考资料：《线性代数 成立波》118页</p><h3 id="高斯分布-正态分布-★★★★"><a href="#高斯分布-正态分布-★★★★" class="headerlink" title="*高斯分布(正态分布) ★★★★"></a>*高斯分布(正态分布) ★★★★</h3><p>一个随机变量如果是由大量微小、独立的随机因素的叠加结果，那么这个变量一般都可以认为服从正态分布。</p><p>正态分布曲线关于其均值点对称，标准差越大图像越扁平。</p><p>参考资料：《概率论与数理统计 茆诗松》截图</p><h3 id="线性方程组的解，Ax-x3D-b，Am×nAm×n分别为长矩阵和扁矩阵？怎么确定哪个解是最优解？★★★★"><a href="#线性方程组的解，Ax-x3D-b，Am×nAm×n分别为长矩阵和扁矩阵？怎么确定哪个解是最优解？★★★★" class="headerlink" title="线性方程组的解，Ax&#x3D;b，Am×nAm×n分别为长矩阵和扁矩阵？怎么确定哪个解是最优解？★★★★"></a>线性方程组的解，Ax&#x3D;b，Am×nAm×n分别为长矩阵和扁矩阵？怎么确定哪个解是最优解？★★★★</h3><h3 id="什么相似矩阵？什么是正定矩阵？★★★★"><a href="#什么相似矩阵？什么是正定矩阵？★★★★" class="headerlink" title="*什么相似矩阵？什么是正定矩阵？★★★★"></a>*什么相似矩阵？什么是正定矩阵？★★★★</h3><p>对于两个矩阵A、B，如果存在一个矩阵P，使得 矩阵P的逆 乘矩阵A 乘矩阵P 等于矩阵B，那么矩阵A相似于矩阵B。相似矩阵A和B它们的特征值相同。</p><p>参考资料：《线性代数 成立波》124页</p><p>假如一个实对称矩阵S对于任一n行1列的矩阵alpha都有 alpha的转置乘矩阵S乘alpha都大于0，则该矩阵正定。</p><p>参考资料：《线性代数与矩阵论 许以超》截图：</p><h3 id="矩阵范数（一阶二阶范数）★★★★"><a href="#矩阵范数（一阶二阶范数）★★★★" class="headerlink" title="*矩阵范数（一阶二阶范数）★★★★"></a>*矩阵范数（一阶二阶范数）★★★★</h3><p>矩阵范数是一个满足非负性、齐次性、三角不等式以及相容性的函数。</p><p>矩阵一范数就是矩阵所有元素取绝对值，然后求最大列和。</p><p>矩阵A的2范数就是“矩阵A的转置与矩阵A相乘所得矩阵”的最大特征值。</p><p>参考CSDN：<a href="https://blog.csdn.net/weixin_28972529/article/details/113452038">https://blog.csdn.net/weixin_28972529/article/details/113452038</a></p><h3 id="矩阵的特征值与特征向量有什么关系？特征值特征向量的含义和作用？★★★★"><a href="#矩阵的特征值与特征向量有什么关系？特征值特征向量的含义和作用？★★★★" class="headerlink" title="*矩阵的特征值与特征向量有什么关系？特征值特征向量的含义和作用？★★★★"></a>*矩阵的特征值与特征向量有什么关系？特征值特征向量的含义和作用？★★★★</h3><p>矩阵的特征向量是这样的向量：矩阵作用于该向量后，向量保持方向不变，进行某一比例的伸缩变换，而这个比例就是特征值。</p><p>因此，特征值与特征向量的关系就是，特征向量与特征值进行数乘操作后所得的向量，和矩阵对该向量进行变换所得向量相同。</p><p>因此特征值的含义就是和矩阵具有同等变换效果的常数，而特征向量就是与矩阵作用之后保持方向不变的向量。</p><p>作用：特征值可以用于奇异值分解、主成分分析。可以用于谱分解、特征值分解。</p><p>参考资料：<a href="https://www.zhihu.com/question/21874816/answer/181864044">https://www.zhihu.com/question/21874816/answer/181864044</a></p><h3 id="矩阵运算下Ax-x3D-b中什么情况下x有解★★"><a href="#矩阵运算下Ax-x3D-b中什么情况下x有解★★" class="headerlink" title="*矩阵运算下Ax&#x3D;b中什么情况下x有解★★"></a>*矩阵运算下Ax&#x3D;b中什么情况下x有解★★</h3><p>线性方程组Ax&#x3D;b的充要条件是，系数矩阵A和增广矩阵B的秩相等。</p><p>假如线性方程组Ax&#x3D;b有解，那么在m&gt;&#x3D;r&#x3D;rank(A)的情况下它的通解依赖于m-r个独立参数，当m&#x3D;r时具有唯一解。</p><p>m个未知数，n个线性方程的齐次线性方程组必有零解，齐次线性方程组有非零解的充要条件是其系数矩阵A的秩&lt;m，而且通解有无穷多个解，依赖于m-r个独立参数。</p><p>齐次线性方程组有m-r组解，这m-r组解就是齐次线性方程组的基础解系。</p><p>非齐次线性方程组解的通解由相伴的齐次线性方程组的通解和非齐次线性方程组的一个特解组成。</p><h3 id="什么是张量？张量与矩阵有什么区别？★★"><a href="#什么是张量？张量与矩阵有什么区别？★★" class="headerlink" title="*什么是张量？张量与矩阵有什么区别？★★"></a>*什么是张量？张量与矩阵有什么区别？★★</h3><p>张量可以看作标量、向量、矩阵的推广，矩阵是二阶张量，而标量是0阶张量、矢量是1阶张量。</p><p>参考链接：<a href="https://www.zhihu.com/question/22189865">https://www.zhihu.com/question/22189865</a></p><h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><h3 id="变量与随机变量有什么区别？★★"><a href="#变量与随机变量有什么区别？★★" class="headerlink" title="*变量与随机变量有什么区别？★★"></a>*变量与随机变量有什么区别？★★</h3><p>随机变量能够描述随机现象，并通过概率统计的方法进行分析。而变量通常用来描述确定性的现象。</p><p>变量的取值是固定唯一的，并且取值范围是整个定义域。而随机变量取值有多个，而且每个取值都有一定的概率。在试验之前，随机变量的取值是不能预知的，试验之后，随机变量的取值范围就是这次试验的样本空间。</p><p>参考《概率论与数理统计 浙大第四版》31页</p><h3 id="随机变量与概率分布有什么联系？★★"><a href="#随机变量与概率分布有什么联系？★★" class="headerlink" title="*随机变量与概率分布有什么联系？★★"></a>*随机变量与概率分布有什么联系？★★</h3><p>随机变量的分布函数表述了随机变量的统计规律性，已知一个随机变量的分布函数就可以得知该随机变量落在某一区间的概率。</p><p>参考《概率统计 浙大第四版》 39页</p><h3 id="联合概率与边缘概率有什么区别？有什么联系？★★"><a href="#联合概率与边缘概率有什么区别？有什么联系？★★" class="headerlink" title="*联合概率与边缘概率有什么区别？有什么联系？★★"></a>*联合概率与边缘概率有什么区别？有什么联系？★★</h3><p>区别：</p><p>联合概率是基于两个随机变量及其相互作用的样本空间的概率。</p><p>边缘概率是多维随机变量的样本空间中，某一个或多个随机变量构成的子空间的概率。</p><p>联系：</p><p>在联合概率的基础上固定若干个随机变量的取值便得到边缘概率。</p><p>参考资料《浙大第四版》60页</p><h3 id="常见的概率分布有哪些？有什么应用场景？请举例说明★★"><a href="#常见的概率分布有哪些？有什么应用场景？请举例说明★★" class="headerlink" title="*常见的概率分布有哪些？有什么应用场景？请举例说明★★"></a>*常见的概率分布有哪些？有什么应用场景？请举例说明★★</h3><p>二项分布：常用于检查产品合格率、色盲率调查等等</p><p>两点分别：比赛胜率估计</p><p>泊松分布：常用于一天内到达顾客数、铸件上的砂眼数、一天内电路受到电磁波干扰次数等等</p><p>超几何分布：用于进行有限总体中进行不放回抽样。</p><p>几何分布：一次伯努利试验中事件A首次出现时的试验次数。例如产品不合格率调查。</p><p>正态分布：主要应用于统计理论、误差理论等等</p><p>指数分布：常用于随即服务系统、寿命估计、排队论等等</p><p>参考《概率论与数理统计》</p><h3 id="大数定律和中心极限定理的意义与作用（切比雪夫大数定律）★★★★"><a href="#大数定律和中心极限定理的意义与作用（切比雪夫大数定律）★★★★" class="headerlink" title="*大数定律和中心极限定理的意义与作用（切比雪夫大数定律）★★★★"></a>*大数定律和中心极限定理的意义与作用（切比雪夫大数定律）★★★★</h3><p>浙大第四版：</p><p>辛钦大数定理：说明了对于独立同分布且具有均值u的n个随机变量，当n很大的时候它们的算术平均值依概率收敛于u。</p><p>伯努利大数定律表明只要随机试验的次数n充分大，那么事件A频率和概率的绝对偏差很小，说明在实际应用中，试验次数很大的时候可以用事件的频率来替代事件的概率。</p><p>参考《浙大第四版》120页</p><p>独立同分布的中心极限定理：均值为u，标准差为sigma的独立同分布的n个随机变量之和的标准化变量在n充分大的时候近似服从于标准正态分布。</p><p>由此推论均值为u标准差为sigma的独立同分布的n个随机变量的算术平均值，当n充分大的时候近似服从均值为u方差为sigma^2&#x2F;n的正态分布。</p><p>李雅普诺夫定理：独立的n个随机变量，其随机变量之和的标准化变量很大的时候近似服从与标准正态分布。</p><p>棣莫弗-拉普拉斯定理表明正态分布是二项分布的极限分布。</p><p>参考《浙大第四版》121页</p><h3 id="正态分布的和还是正态分布吗，正态分布性质与独立同分布）★★★★★"><a href="#正态分布的和还是正态分布吗，正态分布性质与独立同分布）★★★★★" class="headerlink" title="*正态分布的和还是正态分布吗，正态分布性质与独立同分布）★★★★★"></a>*正态分布的和还是正态分布吗，正态分布性质与独立同分布）★★★★★</h3><p>彼此独立的正态分布的和仍然是正态分布，这叫做正态分布的可加性。</p><p>正态分布的可加性就是：如果多个随机变量分别服从不同的正态分布，如果这些随机变量彼此独立，那么这些随机变量的和也服从正态分布。</p><p>事实上，独立同分布的正态分布随机变量具有线性性质，证明过程参考下图：</p><h3 id="什么是假设和检验？★★"><a href="#什么是假设和检验？★★" class="headerlink" title="*什么是假设和检验？★★"></a>*什么是假设和检验？★★</h3><p>假设检验问题关注于通过试验来判断是否参数theta是否落在参数空间的某一个子集或者其补集里面。在总体分布函数未知或者只知其形式不知其参数的情况下，为了推断某些参数，提出关于总体的假设，然后通过样本来决定对所做出的假设接受或者拒绝。假设检验就是做出这一决策的过程。</p><p>假设就是关于总体的参数的参数空间的一部分，包括原假设和备择假设。这两个假设互补。而检验就是对于假设检验问题满足某一显著性水平的概率的不等式。通过这一不等式来判断某一估计是否满足需求。</p><p>参考1《Probability and statistics》</p><p>参考2《概率论与数理统计 茆诗松》</p><h3 id="数学期望和方差？★★"><a href="#数学期望和方差？★★" class="headerlink" title="*数学期望和方差？★★"></a>*数学期望和方差？★★</h3><p>随机变量的数学期望就是随机变量每个取值于该取值的概率的乘积的累加和。它描述了随机变量的集中特性。</p><p>而随机变量的方差描述了随机变量的波动特性，即离散特性，其定义是随机变量的每个取值和数学期望的偏差平方和与该取值的概率的乘积的连加和。</p><p>参考：根据公式的理解</p><h3 id="独立和不相关的区别？★★"><a href="#独立和不相关的区别？★★" class="headerlink" title="*独立和不相关的区别？★★"></a>*独立和不相关的区别？★★</h3><p>见下图，概括就是：独立一定不相关，而不相关不一定独立。例如线性不相关的随机变量可能是非线性相关。最常见的例子就是Logistics函数或者二次函数，自变量和因变量计算所得相关系数很低，但是是互相依赖的变量。</p><h3 id="概率密度函数？★★"><a href="#概率密度函数？★★" class="headerlink" title="*概率密度函数？★★"></a>*概率密度函数？★★</h3><p>连续随机变量的一切取值充满整个样本空间，而这其中有无穷个不可列的实数，因此无法采用分布列表示，采用概率密度函数表示。</p><p>概率密度函数不是概率，乘以区间长度微元后就表示概率的近似值，而概率密度函数在一段区间上的积分就是随机变量X在这段区间上取值的概率。因此，如果存在实数轴上的一个非负可积函数使得对任意实数x都有“这个函数从负无穷到x的积分值就是随机变量X的分布函数F(x)”，这个函数称为随机变量X的概率密度函数。</p><p>参考《概率统计 茆诗松》69页</p><h3 id="举几个泊松分布的例子★★"><a href="#举几个泊松分布的例子★★" class="headerlink" title="*举几个泊松分布的例子★★"></a>*举几个泊松分布的例子★★</h3><p>参考《概率论与数理统计 茆诗松》</p><h3 id="说一下全概率公式和贝叶斯公式★★★★★★★"><a href="#说一下全概率公式和贝叶斯公式★★★★★★★" class="headerlink" title="*说一下全概率公式和贝叶斯公式★★★★★★★"></a>*说一下全概率公式和贝叶斯公式★★★★★★★</h3><p>全概率就是表示达到某个目的，有多种方式（或者造成某种结果，有多种原因），问达到目的的概率是多少（造成这种结果的概率是多少）？</p><p>全概率公式：</p><p>设事件是一个完备事件组，则对于任意一个事件Ｃ，若有如下公式成立：</p><p>那么就称这个公式为全概率公式。</p><p><strong>贝叶斯公式就是当已知结果，问导致这个结果的第i原因的可能性是多少？执果索因！</strong></p><p>贝叶斯公式：</p><p>在已知条件概率和全概率的基础上，贝叶斯公式是很容易计算的：</p><h3 id="解释下相关系数、协方差、相关系数或协方差为0的时候能否说明两个分布无关？"><a href="#解释下相关系数、协方差、相关系数或协方差为0的时候能否说明两个分布无关？" class="headerlink" title="*解释下相关系数、协方差、相关系数或协方差为0的时候能否说明两个分布无关？"></a>*解释下相关系数、协方差、相关系数或协方差为0的时候能否说明两个分布无关？</h3><p>所谓随机变量X和Y的协方差就是“X的偏差和Y的偏差乘积的数学期望”。若协方差大于零，表示这两个随机变量呈正相关关系，若协方差小于零表示两个随机变量呈负相关关系。而协方差等于零表示不“线性相关”。</p><p>相关系数可以看作标准化的协方差，它没有量纲，取值范围在[0, 1]。</p><p>取值为0不能说明两个分布无关，而是“线性不相关”，有可能存在非线性的相关关系，也有可能取值毫无关联。</p><h3 id="若干正态分布相加、相乘后得到的分布分别是什么？★★★"><a href="#若干正态分布相加、相乘后得到的分布分别是什么？★★★" class="headerlink" title="*若干正态分布相加、相乘后得到的分布分别是什么？★★★"></a>*若干正态分布相加、相乘后得到的分布分别是什么？★★★</h3><p>相加参考6.</p><p>相乘：来自知乎：</p><p>正态分布相乘之后，服从的分布为：正态分布乘以常数</p><p><a href="https://www.zhihu.com/question/46458824/answer/1658826258">https://www.zhihu.com/question/46458824/answer/1658826258</a></p><p>知乎截图内容：</p><h3 id="假如有一枚不均匀的-硬币，抛正面的几率是p，抛反面是1-p，请问如何做才能得出1-x2F-2？★★★"><a href="#假如有一枚不均匀的-硬币，抛正面的几率是p，抛反面是1-p，请问如何做才能得出1-x2F-2？★★★" class="headerlink" title="假如有一枚不均匀的 硬币，抛正面的几率是p，抛反面是1-p，请问如何做才能得出1&#x2F;2？★★★"></a>假如有一枚不均匀的 硬币，抛正面的几率是p，抛反面是1-p，请问如何做才能得出1&#x2F;2？★★★</h3><h3 id="机器学习为什么要使用概率？★★"><a href="#机器学习为什么要使用概率？★★" class="headerlink" title="*机器学习为什么要使用概率？★★"></a>*机器学习为什么要使用概率？★★</h3><p>机器学习的是由数据驱动的方法，它的学习对象是数据，从数据出发提取数据特征抽象出数据模型又从数据中发现知识，最后回到数据的分析和预测中去。</p><p>机器学习算法的设计通常依赖于对数据的概率假设，如果不理解相关的数学知识，那么久无法真正理解算法的精髓。并且，机器学习模型的训练和预测过程的评价指标——模型误差，其本身就是概率的形式。</p><p>参考资料：<a href="https://www.zhihu.com/question/285189181">https://www.zhihu.com/question/285189181</a></p><h2 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h2><h3 id="解释下什么是群环域？★★-赵轲"><a href="#解释下什么是群环域？★★-赵轲" class="headerlink" title="*解释下什么是群环域？★★(赵轲)"></a>*解释下什么是群环域？★★(赵轲)</h3><p>由一个非空集合S和该集合上的k个运算组成的系统称作代数系统。群就是一个特殊的代数系统，在这个代数系统的运算是可结合的二元运算，并且该系统中存在单位元和逆元。</p><p>环：若一个代数系统存在两个运算1和运算2，集合R关于运算1构成交换群，关于运算2构成半群，并且运算2关于运算1适合分配律。则集合R和这两个运算构成的代数系统称作环。其中称运算1为加法，运算2为乘法。</p><p>域：如果一个环的乘法运算符合交换律，并且关于乘法运算存在单位元，并且对于环中的任意两个非零元素执行乘法操作结果均不为0，那么这个环R构成一个域。</p><p>参考：《离散数学 屈婉玲》181页</p><h3 id="你知道哪些离散型随机变量-★"><a href="#你知道哪些离散型随机变量-★" class="headerlink" title="*你知道哪些离散型随机变量 ★"></a>*你知道哪些离散型随机变量 ★</h3><p>0-1分布：用于估计样本空间只有0、1两个值的独立重复实验的概率。</p><p>二项分布：常用于样本空间只有两个值的独立重复实验地概率计算。</p><p>泊松分布：常用于服务系统，预测某一天某时段某服务台到达人数</p><p>几何分布：在n次伯努利试验中，试验k次才得到第一次成功的机率。</p><p>超几何分布：不放回抽样的概率计算。</p><p>参考《浙大第四版 概率统计》</p><h3 id="哈密顿图、欧拉图有什么区别，怎么求？★★★"><a href="#哈密顿图、欧拉图有什么区别，怎么求？★★★" class="headerlink" title="*哈密顿图、欧拉图有什么区别，怎么求？★★★"></a>*哈密顿图、欧拉图有什么区别，怎么求？★★★</h3><p>所谓的欧拉图就是包含欧拉回路的图，欧拉回路就是能够通过图中所有的边一次且仅一次就通过所有顶点的回路。也就是所谓的“能够一笔画的图”</p><p>而哈密顿图是经过所有顶点一次且仅一次。</p><p>欧拉图可以求出精确解，教材提到了两种算法：</p><p><strong>Hierholzier算法：</strong></p><p>中心思想：欧拉图是由一个或多个回路拼接而成，只要把图中的每个回路的路径拼接起来，就可以遍历这个欧拉图。</p><p>主要步骤：从一个可能的顶点出发，进行深度优先搜索，但是每次沿着辅助边从某个顶点移动到另外一个顶点的时候，都需要删除这个辅助边。如果没有可以移动的路径，则将所在结点加入到栈中并返回。</p><p>1. 任选起始点并记录</p><p>2. 从起点出发到达任一临接点，到达的点成为新的起点，删除经过的边</p><p>3. 重复步骤2直到回到初始点，此时到达步骤1，将本次记录的点集合与上次记录的点集合拼接。若本图成为空图，到达步骤4.</p><p>4. 输出所有记录点。</p><p>参考：<a href="https://blog.csdn.net/qq_40493829/article/details/108253637">https://blog.csdn.net/qq_40493829/article/details/108253637</a></p><p><strong>Fleury算法：</strong></p><p>输入一个欧拉图</p><p>任取一个顶点，假设路径Pi&#x3D;v0e1v1e2…eivi已经行遍</p><p>然后开始在E(G)-{e1, e2, …, ei}中寻找邻接边，找边的规则为：</p><p>1. 和当前顶点相关联。</p><p>2. 除非无边可选，否则不选E(G)-{e1,e2,…,ei}中的桥</p><p>当已经无边可选了，算法停止，Pm&#x3D;v0e1v1e2v2…emvm(vm&#x3D;v0)为G中一条欧拉回路。</p><p>参考：<a href="https://blog.csdn.net/guomutian911/article/details/42105127">https://blog.csdn.net/guomutian911/article/details/42105127</a></p><p>而哈密顿图，则至今没有一个高效地求出经确解地方法，暴力求解的话，这属于是NP-Hard问题，实际应用中，通常使用启发式搜索算法求出一个近似精确解，常用方法有：</p><p>禁忌搜索算法、蚁群算法、遗传算法等等。（CSDN可搜）</p><h3 id="欧拉图和欧拉函数★★★"><a href="#欧拉图和欧拉函数★★★" class="headerlink" title="*欧拉图和欧拉函数★★★"></a>*欧拉图和欧拉函数★★★</h3><p>所谓的欧拉图就是包含欧拉回路的图，欧拉回路就是能够通过图中所有的边一次且仅一次就通过所有顶点的回路。也就是所谓的“能够一笔画的图”</p><p>参考《离散数学 屈婉玲 316页》</p><p><strong>数论的欧拉函数</strong>：和欧拉图无关，欧拉函数其实是初等数论的重要内容</p><p>其定义为：对自然数n，从0到n-1中与n互素的数的个数就是欧拉函数phi(n)。</p><p>参考：《离散数学 屈婉玲》</p><p>99页计算方法证明 382页应用</p><h3 id="哈夫曼树的定义，怎么求，应用？★"><a href="#哈夫曼树的定义，怎么求，应用？★" class="headerlink" title="*哈夫曼树的定义，怎么求，应用？★"></a>*哈夫曼树的定义，怎么求，应用？★</h3><p>Haffuman树：又称最优二叉树，假设给定有n个权值的集合，且二叉树T有n个叶子节点，将权值赋值给n个叶子节点，定义二叉树的带权路径长度为权重和对应叶子节点的路径长度乘积之和，而最优二叉树就是一组使得带权路径长度最短的权重配置方案作为权重的二叉树。</p><p>Huffman树的基本思想就是：带权路径长度最小的二叉树应该是权值大的外结点离根节点最近的扩充二叉树。</p><p>计算方法：用n个权重各创建一个平凡树，并赋该树根以权值，然后开始循环</p><p>循环内容：</p><ol><li>选择树根权值最小的两个树</li><li>创建一个新树，左右子树分别是这两个权值最小的树</li><li>新树的树根权值为两树权值之和</li><li>删去原来的两个树，添加新树</li><li>判断，如果只剩一个树就跳出循环</li></ol><p>应用：编码设计：Huffman编码、决策算法、算法设计等。</p><p>参考《数据结构 殷人昆 第二版》241页</p><h3 id="无向图的定义★"><a href="#无向图的定义★" class="headerlink" title="*无向图的定义★"></a>*无向图的定义★</h3><p>无向图是一个有序二元组，二元组由一个非空有穷集——顶点集，和一个由顶点集的有序积的有穷多重子集——边集所构成。无向图的边都是无序的，表示顶点和顶点的连接关系。不同于有向边只表示单向关系。</p><p>参考《离散数学 屈婉玲》273页</p><h3 id="解释下等价关系和等价类★★"><a href="#解释下等价关系和等价类★★" class="headerlink" title="*解释下等价关系和等价类★★"></a>*解释下等价关系和等价类★★</h3><p>如果非空集合A上的一个关系R，同时满足自反性、对称性和传递性，就称R为集合A上的等价关系。</p><p>等价类就是集合A中所有与x等价的元素构成的集合。</p><p>参考：《离散数学 屈婉玲》123页</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85gitlab/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85gitlab/</url>
    
    <content type="html"><![CDATA[<p>虚拟机安装gitlab</p><p>直接参考官网不用修改文件</p><p><a href="https://gitlab.cn/install/">https://gitlab.cn/install/</a></p><p>账号root</p><p>密码0pk1auItXvIShOGJp8qWAftNPWL2cbwAMbVUcYRlkuw&#x3D;</p><p>新增用户</p><p>944613709</p><p>250772730</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E5%90%91%E8%AE%BA%E6%96%87%E4%BD%9C%E8%80%85%E8%A6%81%E4%BB%A3%E7%A0%81/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E5%90%91%E8%AE%BA%E6%96%87%E4%BD%9C%E8%80%85%E8%A6%81%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>Dear Mr.&#x2F;Mrs.: 作者名</p><p>I am a graduate student of 大学名 in China. I major in 专业名. Recently, I found one of your articles, titled 文章名 in 杂志名. I found it may help me achieve my goals in this research field. This would make a really positive contribution to my work.<br>I am wondering if you could kindly send me the source program and the necessary information about it. I promise they will be used only for research purposed.<br>Thank you very much for your kind consideration and I am looking forward to your early reply.</p><p>Sincerely: 你的名字<br>My Email address is:email</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E4%BD%BF%E7%94%A8python%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E4%BD%BF%E7%94%A8python%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="使用python中的问题"><a href="#使用python中的问题" class="headerlink" title="使用python中的问题"></a>使用python中的问题</h1><h2 id="pip安装问题指定源"><a href="#pip安装问题指定源" class="headerlink" title=".pip安装问题指定源"></a>.pip安装问题指定源</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">D:\<span class="hljs-number">360</span>MoveData\Users\<span class="hljs-number">86189</span>\Desktop\reinforcement_torch_pfrl-main\venv\Scripts\activate.bat <br>pip install --index-url http:<span class="hljs-regexp">//</span>pypi.douban.com<span class="hljs-regexp">/simple/</span> gym --trusted-host pypi.douban.com<br>pip install --index-url http:<span class="hljs-regexp">//</span>pypi.douban.com<span class="hljs-regexp">/simple/</span> stable-baselines3[extra] --trusted-host pypi.douban.com<br>pip install stable-baselines3[extra]<br>pip install gym[box2d]<br>stable-baselines3[extra]<br>pip install --upgrade setuptools --index-url http:<span class="hljs-regexp">//</span>pypi.douban.com<span class="hljs-regexp">/simple/</span> --trusted-host pypi.douban.com<br>pip install 安装包名字 -i http:<span class="hljs-regexp">//</span>pypi.douban.com<span class="hljs-regexp">/simple/</span>  <br><br>pip install D:\Anacoda3\Box2D-<span class="hljs-number">2.3</span>.<span class="hljs-number">10</span>-cp39-cp39-win_amd64.whl<br>D:\Anacoda3\Box2D-<span class="hljs-number">2.3</span>.<span class="hljs-number">10</span>-cp39-cp39-win_amd64.whl<br><br><br><br>pip install -r requirements.txt<br></code></pre></td></tr></table></figure><h2 id="conda的安装执行conda-forge源"><a href="#conda的安装执行conda-forge源" class="headerlink" title="conda的安装执行conda-forge源"></a>conda的安装执行conda-forge源</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">conda <span class="hljs-keyword">install</span> -c conda-forge stable-baselines3<br><br>conda <span class="hljs-keyword">install</span> --yes --<span class="hljs-keyword">file</span> requirements.txt<br></code></pre></td></tr></table></figure><h1 id="Cannot-uninstall-xxx-It-is-a-distutils-installed-project-and-thus-we-cannot"><a href="#Cannot-uninstall-xxx-It-is-a-distutils-installed-project-and-thus-we-cannot" class="headerlink" title="Cannot uninstall xxx It is a distutils installed project and thus we cannot"></a>Cannot uninstall xxx It is a distutils installed project and thus we cannot</h1><p><a href="https://blog.csdn.net/u010469993/article/details/102623270">https://blog.csdn.net/u010469993/article/details/102623270</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="组会及导师交流"><a href="#组会及导师交流" class="headerlink" title="组会及导师交流"></a>组会及导师交流</h1><h2 id="2022-2-18与导师交流"><a href="#2022-2-18与导师交流" class="headerlink" title="2022.2.18与导师交流"></a>2022.2.18与导师交流</h2><h3 id="RL实验目前问题："><a href="#RL实验目前问题：" class="headerlink" title="RL实验目前问题："></a>RL实验目前问题：</h3><h4 id="稀疏奖励"><a href="#稀疏奖励" class="headerlink" title="稀疏奖励"></a>稀疏奖励</h4><p>目前只有一个final reward &#x3D;  -(整体X部署方案平均响应时间)</p><p>期间中间状态的reward &#x3D; 0设计等于0</p><p><strong>解决方法</strong></p><p>-&gt;ICM，好奇心机制</p><p>-&gt;设计中间状态reward</p><p>-&gt;随机生成一个终止状态，并且reverse推导</p><h3 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h3><h4 id="保研："><a href="#保研：" class="headerlink" title="保研："></a>保研：</h4><p>不再以课内学分为重点，而是参加项目参加科研</p><p>准备夏令营准备推免</p><h4 id="实验室："><a href="#实验室：" class="headerlink" title="实验室："></a><strong>实验室：</strong></h4><p>保留原任务?</p><p>1.做点实验室开发项目</p><p>2.帮忙师兄师姐科研-&gt;三四作</p><h2 id="2022-3-23与导师交流"><a href="#2022-3-23与导师交流" class="headerlink" title="2022.3.23与导师交流"></a>2022.3.23与导师交流</h2><h1 id="每日–进度："><a href="#每日–进度：" class="headerlink" title="每日–进度："></a>每日–进度：</h1><h3 id="2023-3-7："><a href="#2023-3-7：" class="headerlink" title="2023.3.7："></a>2023.3.7：</h3><p>reward，以及不满足条件时候怎么处理</p><h3 id="2023-3-8"><a href="#2023-3-8" class="headerlink" title="2023.3.8"></a>2023.3.8</h3><p>仍需要继续找论文</p><p>1 是否要多优化目标 <a href="https://github.com/Farama-Foundation/MO-Gymnasium">https://github.com/Farama-Foundation/MO-Gymnasium</a></p><p>2 目前解决稀疏奖励的思路：<a href="https://cloud.tencent.com/developer/article/1658242">https://cloud.tencent.com/developer/article/1658242</a>  <a href="https://zhuanlan.zhihu.com/p/389199294">https://zhuanlan.zhihu.com/p/389199294</a></p><p>3.训练时突然控制台卡住，不报错也不动</p><p>得选择一个方向</p><p>1.人工设置中间奖励</p><p>2.事后经验池&#x2F;好奇心机制</p><p>方向1，<strong>人工设置中间奖励，参考论文</strong></p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230308105357236.png" class title="image-20230308105357236"><p>方向2，<strong>利用数据改进 agent 的学习</strong> </p><p>好奇心驱动（Curiosity Driven）、奖励重塑（Reward Shaping）、模仿学习（Imitation Learning）、课程学习（Curriculum Learning</p><p>方向3，<strong>改进模型</strong></p><p>分层强化学习（Hierarchical Reinforcement Learning），使用多层次的结构分别学习不同层次的策略来提高模型解决复杂问题的能力，以及元学习（Meta-Learning）的方法</p><p>然而stablebaselines3似乎没有改进模型</p><p><strong>3 如何验证当前RL训练后结果是否达到了预期条件</strong></p><p>​用自己电脑测试，运行一会，跑的步数会不会太少，然后因此达不到效果</p><h3 id="2023-3-10"><a href="#2023-3-10" class="headerlink" title="2023.3.10"></a>2023.3.10</h3><p>索要代码</p><h4 id="安装anaconda环境，或者自己买一台服务器去跑，或者直接用现成的"><a href="#安装anaconda环境，或者自己买一台服务器去跑，或者直接用现成的" class="headerlink" title="安装anaconda环境，或者自己买一台服务器去跑，或者直接用现成的"></a>安装anaconda环境，或者自己买一台服务器去跑，或者直接用现成的</h4><p>选择鞠驰云okk</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230310115638251.png" class title="image-20230310115638251"><h3 id="2023-3-11"><a href="#2023-3-11" class="headerlink" title="2023.3.11"></a>2023.3.11</h3><p><strong>新参考论文思路</strong>—-新的一条路子</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230311100723433.png" class title="image-20230311100723433"><p>这里，|U|表示用户的总数，zui (t)表示深度神经网络在时间槽t的决策的多个用户的总延迟。我们使用 zui (t) 来表示服务在没有迁移的情况下停留在原始边缘服务器上的总延迟。</p><p>问题：<strong>我需要去写optuna</strong></p><p>待办</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230311222006317.png" class title="image-20230311222006317"><p>大致思路</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">def preRun_optuna_DRL(exp_name, data_dir_path, <span class="hljs-keyword">method</span>):<br>    study = optuna.create_study(direction=<span class="hljs-string">&#x27;maximize&#x27;</span>)<br>    <span class="hljs-keyword">for</span> :<br>        拿到env<br>        def optimize_agent(trial):<br>            使用env<br>        study.optimize(optimize_agent, n_trials=<span class="hljs-number">10</span>)<br>    保存model<br></code></pre></td></tr></table></figure><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230311221941724.png" class title="image-20230311221941724"><p>问题：是否需要每个数据文件夹都给创建一个model</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230311202511399.png" class title="image-20230311202511399"><p>DONE问题4：<strong>total_timesteps不是指episode回合数！</strong></p><p><strong>我记得我们之前都习惯使用episode作为训练的轮数，所以需要注意一下不同。因此，此处设置的1e5可不代表我们要让模型玩1e5次登月游戏hhh，而是模型能拿到的采样数为1e5，这样设置对于定量设置采样池也更加有效。</strong></p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230311182622295.png" class title="image-20230311182622295"><p>问题3：model &#x3D; PPO.load(f”.&#x2F;model&#x2F;{method}”)是错的！！！！！！！！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#第一个训练模型需要初始化</span><br><span class="hljs-keyword">if</span> is_first ==<span class="hljs-literal">True</span>:<br>    model = PPO(<br>        <span class="hljs-string">&quot;MlpPolicy&quot;</span>, env, verbose=<span class="hljs-number">1</span>,<br>        tensorboard_log=<span class="hljs-string">f&quot;./tensorboard/<span class="hljs-subst">&#123;method&#125;</span>/&quot;</span>,<br>    )<br>    is_first =<span class="hljs-literal">False</span><br><span class="hljs-keyword">else</span>:<span class="hljs-comment"># 如果不是第一次,需要load接着以前继续训练</span><br>    <span class="hljs-comment">#TODO!!!!env也得变，不能接着上一回的env继续</span><br>    model = PPO.load(<span class="hljs-string">f&quot;./model/<span class="hljs-subst">&#123;method&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>DONE<strong>问题1：</strong></p><p>发现了predict返回的reward会加工为narray</p><p>解决方案：narray转回int</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">num</span> = action.item()<br><span class="hljs-built_in">print</span>(type(<span class="hljs-built_in">num</span>))  # &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">int</span>&#x27;&gt;</span><br></code></pre></td></tr></table></figure><p><strong><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230311161128103.png" class title="image-20230311161128103"></strong></p><h3 id="2023-3-12"><a href="#2023-3-12" class="headerlink" title="2023.3.12"></a>2023.3.12</h3><p>任务：联系作者要源代码，&#x2F;写optuna</p><p>2023.3.17</p><p><strong>目前问题</strong>：</p><p>一个data数据为一个env是否存在问题</p><p>现在env(svc_obj)其中的svc_obj都是固定的</p><p>env()是否要随机</p><h3 id="2023-4-5"><a href="#2023-4-5" class="headerlink" title="2023.4.5"></a>2023.4.5</h3><p>证明了num_timesteps&#x3D;1000000就够了1e6</p><ul><li><input checked disabled type="checkbox"> 1.解决plt绘图超过20占内存</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/mnt/</span>AlgoDeployment-master<span class="hljs-regexp">/commom/</span>SvcCallGraph.py:<span class="hljs-number">331</span>: RuntimeWarning: More than <span class="hljs-number">20</span> figures have been opened. Figures created through the pyplot <span class="hljs-keyword">interface</span> (`matplotlib.pyplot.figure`) are retained until explicitly closed and may consume too much memory. (To control <span class="hljs-keyword">this</span> warning, see the rcParam `figure.max_open_warning`)<br></code></pre></td></tr></table></figure><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230405142716015.png" class title="image-20230405142716015"><p>解决方法直接加入直接pass</p><p><strong>这还大量加速了代码运行！！！！</strong></p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230405144818728.png" class title="image-20230405144818728"><ul><li><input checked disabled type="checkbox"> 2.尝试解决之前死循环，action一直同一个—（似乎再也没遇见了）</li></ul><p>让无法在该node部署安置后，让action剔除该node</p><p><strong>新方法：动作屏蔽</strong></p><p>动作屏蔽（Action Masking）是一种防止智能体在某些状态下采取指定动作的技术。在强化学习中，如果某个动作在特定的状态下是无效的或不合法的，那么我们可以使用动作屏蔽来强制让智能体不采取该动作，从而提高智能体的性能。</p><p>动作屏蔽通常在 OpenAI Gym 这样的强化学习库中实现。在使用这种技术时，我们可以为每个状态指定一个动作掩码（Action Mask），这个掩码用来表示在该状态下哪些动作是合法的，哪些是不合法的。对于那些被标记为不合法的动作，智能体将不会进行尝试，直到它遇到一个合法的动作为止。</p><p>动作屏蔽在许多场景中都是必需的，例如当动作空间非常大、环境复杂或存在诸如物理约束等实际限制时</p><p><strong>方法1</strong>：（不行）</p><p>self.action_node_values为当前可以选用的node</p><p>如果action代表node不在这里，那么就重新从这列表self.action_node_values随机选取一个</p><p><strong>方法2：</strong>目前不行</p><p>（似乎对于model.PPO(env)就定死了self.action_space）</p><p>该次尝试已写入 MyEnv_3-尝试动态更新action_space.py</p><p>在自定义环境中step（）写了重新定义了self.action_space</p><p>比如</p><p>init()：</p><p>​action_space_arr 本来是[0,1,2,3]</p><p>step（）:</p><p>​如果遇上该svc无法在node部署</p><p>​则在action_space去掉该node</p><p><strong>方法2遇上报错</strong></p><p>归根到底原因就是，我在step（self,action）中修改了self.action_space()但是作用到了self.action_space.sample()，却没有作用到下一个进入step（self,action）的action</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230405155950671.png" class title="image-20230405155950671"><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230405154441536.png" class title="image-20230405154441536"><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230405152657192.png" class title="image-20230405152657192"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;D:\jetbrain\apps\PyCharm-P\ch-0\231.8109.197\plugins\python\helpers\pydev\pydevd.py&quot;</span>, line <span class="hljs-number">1496</span>, <span class="hljs-keyword">in</span> _<span class="hljs-built_in">exec</span><br>    pydev_imports.execfile(file, <span class="hljs-built_in">globals</span>, <span class="hljs-built_in">locals</span>)  <span class="hljs-comment"># execute the script</span><br>  File <span class="hljs-string">&quot;D:\jetbrain\apps\PyCharm-P\ch-0\231.8109.197\plugins\python\helpers\pydev\_pydev_imps\_pydev_execfile.py&quot;</span>, line <span class="hljs-number">18</span>, <span class="hljs-keyword">in</span> execfile<br>    <span class="hljs-built_in">exec</span>(<span class="hljs-built_in">compile</span>(contents+<span class="hljs-string">&quot;\n&quot;</span>, file, <span class="hljs-string">&#x27;exec&#x27;</span>), glob, loc)<br>  File <span class="hljs-string">&quot;D:\360MoveData\Users\86189\Desktop\ʵ���ұ�Ե����\AlgoDeployment-master\DRL_main.py&quot;</span>, line <span class="hljs-number">369</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    train_DRL_single(<span class="hljs-string">&#x27;experiment3&#x27;</span>, data_path_1_small, <span class="hljs-string">&#x27;PPO_SiLu3&#x27;</span>)<br>  File <span class="hljs-string">&quot;D:\360MoveData\Users\86189\Desktop\ʵ���ұ�Ե����\AlgoDeployment-master\DRL_main.py&quot;</span>, line <span class="hljs-number">143</span>, <span class="hljs-keyword">in</span> train_DRL_single<br>    model.learn(total_timesteps=<span class="hljs-built_in">int</span>(<span class="hljs-number">1e7</span>), reset_num_timesteps=<span class="hljs-literal">False</span>, log_interval=<span class="hljs-number">500</span>, callback=[callback, checkpoint_callback])<br>  File <span class="hljs-string">&quot;D:\Anacoda3\lib\site-packages\stable_baselines3\ppo\ppo.py&quot;</span>, line <span class="hljs-number">307</span>, <span class="hljs-keyword">in</span> learn<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().learn(<br>  File <span class="hljs-string">&quot;D:\Anacoda3\lib\site-packages\stable_baselines3\common\on_policy_algorithm.py&quot;</span>, line <span class="hljs-number">248</span>, <span class="hljs-keyword">in</span> learn<br>    continue_training = self.collect_rollouts(self.env, callback, self.rollout_buffer, n_rollout_steps=self.n_steps)<br>  File <span class="hljs-string">&quot;D:\Anacoda3\lib\site-packages\stable_baselines3\common\on_policy_algorithm.py&quot;</span>, line <span class="hljs-number">175</span>, <span class="hljs-keyword">in</span> collect_rollouts<br>    new_obs, rewards, dones, infos = env.step(clipped_actions)<br>  File <span class="hljs-string">&quot;D:\Anacoda3\lib\site-packages\stable_baselines3\common\vec_env\base_vec_env.py&quot;</span>, line <span class="hljs-number">163</span>, <span class="hljs-keyword">in</span> step<br>    <span class="hljs-keyword">return</span> self.step_wait()<br>  File <span class="hljs-string">&quot;D:\Anacoda3\lib\site-packages\stable_baselines3\common\vec_env\dummy_vec_env.py&quot;</span>, line <span class="hljs-number">54</span>, <span class="hljs-keyword">in</span> step_wait<br>    obs, self.buf_rews[env_idx], self.buf_dones[env_idx], self.buf_infos[env_idx] = self.envs[env_idx].step(<br>  File <span class="hljs-string">&quot;D:\Anacoda3\lib\site-packages\stable_baselines3\common\monitor.py&quot;</span>, line <span class="hljs-number">94</span>, <span class="hljs-keyword">in</span> step<br>    observation, reward, done, info = self.env.step(action)<br>  File <span class="hljs-string">&quot;D:\360MoveData\Users\86189\Desktop\ʵ���ұ�Ե����\AlgoDeployment-master\DRL_Fars\MyEnv_3.py&quot;</span>, line <span class="hljs-number">156</span>, <span class="hljs-keyword">in</span> step<br>    remain_svc_instance_count = self.node_res_for_svc(cur_svc_deploy_node,self.cur_svc_index)<br>  File <span class="hljs-string">&quot;D:\360MoveData\Users\86189\Desktop\ʵ���ұ�Ե����\AlgoDeployment-master\DRL_Fars\MyEnv_3.py&quot;</span>, line <span class="hljs-number">373</span>, <span class="hljs-keyword">in</span> node_res_for_svc<br>    count_cpu = math.floor(self.remain_res[node][<span class="hljs-string">&#x27;cpu&#x27;</span>] / self.svc_objs[svc][<span class="hljs-string">&#x27;res&#x27;</span>][<span class="hljs-string">&#x27;cpu&#x27;</span>])<br>KeyError: <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><ul><li><p><input disabled type="checkbox"> stablebaseline3采用HER模型（不行！似乎我的环境不支持-HER要求连续空间）</p><p>HER经验池可以配合其他算法比如DQN一起使用</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230405173925943.png" class title="image-20230405173925943"></li></ul><p>PPO_SiLu3</p><p>DQN</p><p>DQN_HER</p><p>QR_DQN</p><p>A2C</p><p>MaskablePPO</p><ul><li><input disabled type="checkbox"> ​让所有的数据都跑一遍</li></ul><h3 id="2023-4-6"><a href="#2023-4-6" class="headerlink" title="2023.4.6"></a>2023.4.6</h3><p>调研各个DRL框架</p><h3 id="SpinningUp———–算法太少了"><a href="#SpinningUp———–算法太少了" class="headerlink" title="SpinningUp———–算法太少了"></a><a href="https://github.com/openai/spinningup">SpinningUp</a>———–算法太少了</h3><p>DL-engine———有ICM-GNU-DIAYN都适合稀疏问题的解决！，但是还要移动env</p><p>padl–<a href="https://aistudio.baidu.com/aistudio/projectdetail/1434970">好奇心驱动的强化学习 - 飞桨AI Studio (baidu.com)</a></p><p>acme–<a href="https://dm-acme.readthedocs.io/en/latest/user/agents.html">代理 — 极致文档 (dm-acme.readthedocs.io)</a></p><p>kaggle有现成模板</p><p>DL</p><p>model文件夹权限问题load不了</p><p>上一次后台运行是因为卡在test停下来，所以我认为是在权限哪里load不了，所以停了</p><p>此后可以先不用test后台运行</p><p>测试执行时间</p><p>挺好就是比不过师兄</p><p>用同一个模型训练其他data</p><p>效果差死了</p><h3 id="2023-4-7"><a href="#2023-4-7" class="headerlink" title="2023.4.7"></a>2023.4.7</h3><ul><li><input disabled type="checkbox"> 让动态action_space:</li></ul><p>动作屏蔽（Action Masking）是一种防止智能体在某些状态下采取指定动作的技术。在强化学习中，如果某个动作在特定的状态下是无效的或不合法的，那么我们可以使用动作屏蔽来强制让智能体不采取该动作，从而提高智能体的性能。</p><p>动作屏蔽通常在 OpenAI Gym 这样的强化学习库中实现。在使用这种技术时，我们可以为每个状态指定一个动作掩码（Action Mask），这个掩码用来表示在该状态下哪些动作是合法的，哪些是不合法的。对于那些被标记为不合法的动作，智能体将不会进行尝试，直到它遇到一个合法的动作为止。</p><p>动作屏蔽在许多场景中都是必需的，例如当动作空间非常大、环境复杂或存在诸如物理约束等实际限制时</p><h1 id="实验室实验"><a href="#实验室实验" class="headerlink" title="实验室实验"></a>实验室实验</h1><p>items.sort(key&#x3D;lambda x: int(x))：对 items 这个列表进行排序，按照每个名字中的数字部分（如果有的话）从小到大的顺序](<a href="https://stackoverflow.com/questions/70373510/sort-os-listdir-with-numbers-in-string)[2](https://stackoverflow.com/questions/70373510/sort-os-listdir-with-numbers-in-string)%E3%80%82">https://stackoverflow.com/questions/70373510/sort-os-listdir-with-numbers-in-string)[2](https://stackoverflow.com/questions/70373510/sort-os-listdir-with-numbers-in-string)。</a></p><p>lambda x: int(x) 是一个匿名函数，用于将每个名字转换成整数类型</p><h2 id="专有名词解释"><a href="#专有名词解释" class="headerlink" title="专有名词解释"></a>专有名词解释</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230220123122777.png" class title="image-20230220123122777"><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230220114814179.png" class title="image-20230220114814179"><h2 id="算法2的解释"><a href="#算法2的解释" class="headerlink" title="算法2的解释"></a>算法2的解释</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230220121614089-16768665862511.png" class title="image-20230220121614089"><h1 id="代码实验"><a href="#代码实验" class="headerlink" title="代码实验"></a>代码实验</h1><h2 id="问题理解"><a href="#问题理解" class="headerlink" title="问题理解"></a>问题理解</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230228193743793.png" class title="image-20230228193743793"><p>已知：用户们发出请求多个fi,j-&gt;对应了多条Fi,j函数调用链</p><p>综合所有Fi,j构成一个DG，显示所有要调用的</p><p>-&gt;需要去部署Svc到不同的node上面</p><p>-&gt;要求用户们发出的多个请求fi,j，在我们在线部署方案之后，测出来的平均响应时间最小</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230228194302450.png" class title="image-20230228194302450"><h2 id="最终实验用来的算法"><a href="#最终实验用来的算法" class="headerlink" title="最终实验用来的算法"></a>最终实验用来的算法</h2><p>我们的算法有三种：</p><p>基于BFS的算法B-QSRFP、</p><p>基于DFS的算法D-QSRFP</p><p>B-QSRFP和D-QSRFP的组合，表示为BD-QSRFP。BD-QSRFP 分别运行 B-QSRFP 和 D-QSRFP，并返回最佳结果</p><p>平均响应时间·估计BD-QSRFP最好，毕竟是这样定义的</p><p>算法执行时间，BD-QSRFP最坏</p><h2 id="B-QSRFP算法"><a href="#B-QSRFP算法" class="headerlink" title="B-QSRFP算法"></a>B-QSRFP算法</h2><p> RAM运行内存，</p><p>CPU是中央处理器</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230221085944534.png" class title="image-20230221085944534"><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">best_value = self<span class="hljs-selector-class">.svc_objs</span><span class="hljs-selector-attr">[svc]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;ability&#x27;</span>]</span> / self<span class="hljs-selector-class">.svc_objs</span><span class="hljs-selector-attr">[svc]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;res&#x27;</span>]</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;cpu&#x27;</span>]</span><br></code></pre></td></tr></table></figure><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230221083153487.png" class title="image-20230221083153487"><p>DeploySpread(si, d γs i +γu iμi e, X, N, DG)</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">self.deploy<span class="hljs-constructor">_svc_with_best_node_considering_spread(<span class="hljs-params">best_svc</span>, <span class="hljs-params">desired_count</span>)</span><br></code></pre></td></tr></table></figure><h2 id="solve函数、"><a href="#solve函数、" class="headerlink" title="solve函数、"></a>solve函数、</h2><h3 id="其中函数"><a href="#其中函数" class="headerlink" title="其中函数"></a>其中函数</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># 检查节点剩余资源可以为服务svc部署多少个新实例<br>def node<span class="hljs-constructor">_res_for_svc(<span class="hljs-params">self</span>, <span class="hljs-params">node</span>, <span class="hljs-params">svc</span>)</span> -&gt; <span class="hljs-built_in">int</span>:<br><br>    # 将svc的count个实例部署到node<br>    def deploy<span class="hljs-constructor">_svc_on_node(<span class="hljs-params">self</span>, <span class="hljs-params">svc</span>, <span class="hljs-params">node</span>, <span class="hljs-params">count</span>)</span>:<br><br>为给定的服务找到最佳节点来弱地创建实例，即不考虑后继实例 或者没有部署的前辈<br>def find<span class="hljs-constructor">_best_node_weak(<span class="hljs-params">self</span>, <span class="hljs-params">svc</span>)</span> -&gt; <span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> None:<br><br>为给定的服务找到最佳节点来强地创建实例，即考虑后继实例 或者没有部署的前辈<br>def find<span class="hljs-constructor">_best_node_strong(<span class="hljs-params">self</span>, <span class="hljs-params">svc</span>)</span> -&gt; (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">float</span>) <span class="hljs-keyword">or</span> None:<br><br>target_node, _ = self.find<span class="hljs-constructor">_best_node_strong(<span class="hljs-params">curr_svc</span>)</span><br></code></pre></td></tr></table></figure><h3 id="计算每个服务需要的最小服务实例数"><a href="#计算每个服务需要的最小服务实例数" class="headerlink" title="计算每个服务需要的最小服务实例数"></a>计算每个服务需要的最小服务实例数</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">self.min_svc_count = scheme.cal<span class="hljs-constructor">_min_svc_count(<span class="hljs-params">self</span>.<span class="hljs-params">svc_call_graph</span>.<span class="hljs-params">graph_bak</span>, <span class="hljs-params">self</span>.<span class="hljs-params">svc_objs</span>)</span><br></code></pre></td></tr></table></figure><h3 id="X部署策略"><a href="#X部署策略" class="headerlink" title="X部署策略"></a>X部署策略</h3><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230222190856016.png" class title="image-20230222190856016"><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">self.deployment[<span class="hljs-keyword">node</span><span class="hljs-title">][svc</span>] += count<br>代表着：执行<span class="hljs-keyword">node</span><span class="hljs-title">部署svc</span>的实例count个<br><br>附带着考虑资源消耗的是<br>def deploy_svc_on_node(self, svc, <span class="hljs-keyword">node</span><span class="hljs-title">, count</span>):<br></code></pre></td></tr></table></figure><h3 id="返回当前平均响应时间的方法"><a href="#返回当前平均响应时间的方法" class="headerlink" title="返回当前平均响应时间的方法"></a>返回当前平均响应时间的方法</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment">#平均响应时间</span><br>f = scheme.evaluate(<span class="hljs-keyword">self</span>.deployment, <span class="hljs-keyword">self</span>.node_objs, <span class="hljs-keyword">self</span>.func_objs, <span class="hljs-keyword">self</span>.users, <span class="hljs-keyword">self</span>.chains,<br>                    <span class="hljs-keyword">self</span>.connections)<br></code></pre></td></tr></table></figure><p>论文里选的选取平均响应时间(ms)和算法执行时间(ms)作为指标</p><h3 id="used-time是算法实行时间"><a href="#used-time是算法实行时间" class="headerlink" title="used_time是算法实行时间"></a>used_time是算法实行时间</h3><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230220132436260.png" class title="image-20230220132436260"><h3 id="f是平均响应时间"><a href="#f是平均响应时间" class="headerlink" title=".f是平均响应时间"></a>.f是平均响应时间</h3><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230220132255066.png" class title="image-20230220132255066"><p>最终选择的优化目标为平均响应时间</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230223083946204.png" class title="image-20230223083946204"><h3 id="个人想法"><a href="#个人想法" class="headerlink" title="个人想法"></a>个人想法</h3><p>思路1：2023.2.28弃用</p><p>DRL一般不再涉及其他算法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1</span>: X ← <span class="hljs-number">0</span><br><span class="hljs-number">2</span>: <span class="hljs-keyword">while</span> not <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DG</span>.</span></span>empty<span class="hljs-literal">()</span> <span class="hljs-keyword">do</span><br>action：return 根据PPO策略选择了某Si的新X<br><span class="hljs-number">3</span>: 利用AxAlgo中的基础算法<span class="hljs-number">2</span>来部署Si : <span class="hljs-constructor">DeploySpread(<span class="hljs-params">si</span>, <span class="hljs-params">d</span> γ<span class="hljs-params">s</span> <span class="hljs-params">i</span> +γ<span class="hljs-params">u</span> <span class="hljs-params">i</span>μ<span class="hljs-params">i</span> <span class="hljs-params">e</span>, X, N, DG)</span><br><span class="hljs-number">4</span>: <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DG</span>.</span></span>remove(si)<br><span class="hljs-number">5</span>: <span class="hljs-keyword">end</span> <span class="hljs-keyword">while</span><br><span class="hljs-number">6</span>: return X<br></code></pre></td></tr></table></figure><p>思路2</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">1</span>: X ← <span class="hljs-number">0</span><br><span class="hljs-number">2</span>: <span class="hljs-keyword">while</span> not DG.empty() <span class="hljs-keyword">do</span><br>action：<span class="hljs-keyword">return</span> 根据PPO策略选择了某<span class="hljs-built_in">Si</span>，某nodej<br><span class="hljs-number">3</span>: 部署单个<span class="hljs-built_in">Si</span>实例于Nodej，<br><span class="hljs-number">4</span>: DG.remove(<span class="hljs-built_in">si</span>)<br><span class="hljs-number">5</span>: <span class="hljs-keyword">end</span> <span class="hljs-keyword">while</span><br><span class="hljs-number">6</span>: <span class="hljs-keyword">return</span> X<br><br></code></pre></td></tr></table></figure><h4 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">1</span>: X ← <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> <span class="hljs-title class_">Each</span> Si <span class="hljs-keyword">in</span> Svc<br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> min_svc_count<br>action: <br>根据PPO策略选择某nodej<br>如果当前nodej的资源等不满足部署单个svc实例要求，<br>reward = 惩罚reward值<br>否则 <br>reward = 中间reward奖励值<br>部署Si单个实例于Nodej<br>如果部署完毕<br>done=<span class="hljs-literal">true</span>,reward = 最终部署完成奖励值reward<br>否则如果没部署完毕<br>继续部署下一个<br><span class="hljs-number">6</span>: <span class="hljs-keyword">return</span> X<br></code></pre></td></tr></table></figure><p>obs &#x3D; deployment当前部署方案，以二维数组表示</p><p>action &#x3D; {0,1,2,…..,len(self.node_objs)-1}，从node_objs选择一个nodej，让当前的Si去部署单个实例在nodej上面</p><p>reward &#x3D; [原始环境reward，人工设置reward]？</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230308092128371.png" class title="image-20230308092128371"><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230228190155006.png" class title="image-20230228190155006"><p>状态空间：为多离散空间</p><p>deployment</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230222192756656.png" class title="image-20230222192756656"><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230222195036703.png" class title="image-20230222195036703"><p>动作空间：为多离散空间</p><p>执行两个动作</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">deploy<span class="hljs-constructor">_svc_on_node(<span class="hljs-params">svc1</span>,<span class="hljs-params">node1</span>,2)</span><br>deploy<span class="hljs-constructor">_svc_on_node(<span class="hljs-params">svc2</span>,<span class="hljs-params">node2</span>,5)</span><br></code></pre></td></tr></table></figure><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230222192750105.png" class title="image-20230222192750105"><p>状态空间：为多离散空间</p><p>动作空间：为多离散空间</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230222192041882.png" class title="image-20230222192041882"><h4 id="reward利用平均响应时间和算法实行时间"><a href="#reward利用平均响应时间和算法实行时间" class="headerlink" title="reward利用平均响应时间和算法实行时间"></a>reward利用平均响应时间和算法实行时间</h4><p>reward &#x3D;  -(new 整体X部署方案平均响应时间- old 整体X部署方案平均响应时间)</p><h3 id="目前问题"><a href="#目前问题" class="headerlink" title="目前问题"></a>目前问题</h3><p>1.reward &#x3D; -平均响应时间之差，在部署过程中的平均响应时间难求</p><p>reward &#x3D;  -(new 整体X部署方案平均响应时间- old 整体X部署方案平均响应时间)</p><p>​原有的scheme.evaluate（）函数不支持部署过程中执行</p><p>​</p><p>2.要解决action会重复部署svc的问题 -&gt; 引入Boolean[] hasSelect-&gt; 引入No-Op</p><p>3.调用AxAlgo的算法2的deploy_svc_with_best_node_considering_spreadFile（）选出的targetNode为Null导致抛出Exception</p><h2 id="参考A-Reinforcement-Learning-Environment-For-Job-Shop-Scheduling的思路"><a href="#参考A-Reinforcement-Learning-Environment-For-Job-Shop-Scheduling的思路" class="headerlink" title="参考A Reinforcement Learning Environment For Job-Shop Scheduling的思路"></a>参考A Reinforcement Learning Environment For Job-Shop Scheduling的思路</h2><ol><li></li></ol><p>解决重复svc部署问题–布尔</p><p>在某些情况下，我们不能在每一步分配一个作业，因为某些作业可能已经分配给机器，机器可以使用，或者我们已经完成了所有作业的操作。为了遵守这些约束，我们的环境还使用了一个布尔向量，指示哪些动作是合法的。每次代理分配作业时，它将分配的作业添加到</p><p>2.采用PPO算法</p><p>我们建议将 JSS 建模为单代理 RL 问题，其中代理是一个调度程序，需要在每一步选择要工作。特别是，我们使用actor-critic近端策略优化(PPO)算法</p><p>3.加入NO-Op</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230223112934947.png" class title="image-20230223112934947"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>HER</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230306135245363.png" class title="image-20230306135245363"><h1 id="Experiment-1-User-Count"><a href="#Experiment-1-User-Count" class="headerlink" title="Experiment 1: User Count"></a>Experiment 1: User Count</h1><p>用的是rwt_users   rwt_users2<img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230220132723183.png" class title="image-20230220132723183"></p><p>实验 1.1 有 5 个服务器和 23 个服务，</p><p>实验 1.2 有 10 个服务器和 50 个服务。</p><p>实验 1.1 和 1.2 中的用户计数在 500-1600 和 500-1500 之间。</p><p>实验1.2中没有1600个用户计数，因为服务器的计算资源甚至不足以部署每个数量最少的服务</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230220132633453.png" class title="image-20230220132633453"><h1 id="stablebaselines3"><a href="#stablebaselines3" class="headerlink" title="stablebaselines3"></a>stablebaselines3</h1><h2 id="TensorBoard查看"><a href="#TensorBoard查看" class="headerlink" title="TensorBoard查看"></a>TensorBoard查看</h2><p>tensorboard –logdir .\tensorboard\PPO_SiLu3\</p><p>tensorboard –logdir .\tensorboard\PPO_SiLu3\</p><p>tensorboard –logdir .\tensorboard\LunarLander-v2\</p><p>tensorboard –logdir  .\tensorboard\</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230307201337564.png" class title="image-20230307201337564"><h2 id="输出rollout"><a href="#输出rollout" class="headerlink" title="输出rollout"></a>输出rollout</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AE%9E%E9%AA%8C/image-20230307202442056.png" class title="image-20230307202442056"><p>bug</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h1><h2 id="pip安装指定安装源"><a href="#pip安装指定安装源" class="headerlink" title="pip安装指定安装源"></a>pip安装指定安装源</h2><p>pip install swig-i <a href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com</p><p>pip install gym[box2D] <a href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com</p><p>python.exe -m pip install –upgrade pip -i <a href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a> –trusted-host pypi.douban.com</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="面向服务大作业展示"><a href="#面向服务大作业展示" class="headerlink" title="面向服务大作业展示"></a>面向服务大作业展示</h1><p><a href="http://localhost:10010/backend/index.html">http://localhost:10010/backend/index.html</a></p><p>访问路径</p><p>理论上</p><p>http:&#x2F;&#x2F;公网ip:32210&#x2F;backend&#x2F;index.html就可以访问</p><h2 id="同时多ip部署大作业项目"><a href="#同时多ip部署大作业项目" class="headerlink" title="同时多ip部署大作业项目"></a>同时多ip部署大作业项目</h2><p>发现数据库调用很慢（只使用了一个mysql）</p><p>成功连接sentinel</p><p><a href="http://47.92.244.182:31581/#/dashboard/metric/mailemployee">http://47.92.244.182:31581/#/dashboard/metric/mailemployee</a></p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214193300402.png" class title="image-20221214193300402"><p>基于gateway与nacos集合，在目前项目中暂时不需要sentinel专门去限流</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214193814894.png" class title="image-20221214193814894"><p><a href="http://47.92.244.182:30503/nacos/#/serviceManagement?dataId=&group=&appName=&namespace=">http://47.92.244.182:30503/nacos/#/serviceManagement?dataId=&amp;group=&amp;appName=&amp;namespace=</a></p><p>成功连接nacos</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221213120043836.png" alt="image-20221213120043836"></p><p>成功放入docker运行并无问题</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214150728690.png" class title="image-20221214150728690"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214154017141.png" class title="image-20221214154017141"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214144959425.png" class title="image-20221214144959425"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214111013757.png" class title="image-20221214111013757"><p>12.14修正了原先管理端后端处理前端跨域问题的过时方法</p><p>后端Feign处理前端跨域方法改为后端网关处理</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214145849488.png" class title="image-20221214145849488"><p>残余的可以删掉，但是保留下来是为了保留Feign接口，方便以后要用时候再次利用这些Feign接口</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214150130346.png" class title="image-20221214150130346"><p>12.14准备采用nginx部署</p><p>原始80端口冲突所以一直显示不出来！！！</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214201550762.png" class title="image-20221214201550762"><h1 id="在新的k8s利用jenkins部署好之后，需要添加gateway白名单"><a href="#在新的k8s利用jenkins部署好之后，需要添加gateway白名单" class="headerlink" title="在新的k8s利用jenkins部署好之后，需要添加gateway白名单"></a>在新的k8s利用jenkins部署好之后，需要添加gateway白名单</h1><p>在这里需要nginx的公网请求ip和端口</p><p>12.14代办</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214205204586.png" class title="image-20221214205204586"><h1 id="互相合作很不错，自己部署一晚上nginx没有成功，交给苏泽楷一下子就成了"><a href="#互相合作很不错，自己部署一晚上nginx没有成功，交给苏泽楷一下子就成了" class="headerlink" title="互相合作很不错，自己部署一晚上nginx没有成功，交给苏泽楷一下子就成了"></a>互相合作很不错，自己部署一晚上nginx没有成功，交给苏泽楷一下子就成了</h1><h1 id="gateway的跨域允许"><a href="#gateway的跨域允许" class="headerlink" title="gateway的跨域允许"></a>gateway的跨域允许</h1><p>就算是本机ip是120.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="面向服务大作业分享"><a href="#面向服务大作业分享" class="headerlink" title="面向服务大作业分享"></a>面向服务大作业分享</h1><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114205121053.png" class title="image-20221114205121053"><p>管理员端：前后端资源合并设计</p><p>客户手机端：前后端分离设计</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114165458696.png" class title="image-20221114165458696"><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="1-mysql"><a href="#1-mysql" class="headerlink" title="1.mysql"></a>1.mysql</h4><p>目前设计了三条表</p><p>brand品牌</p><p>employee管理员工</p><p>good商品</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114203716493.png" class title="image-20221114203716493"><h3 id="tips1"><a href="#tips1" class="headerlink" title="tips1:"></a>tips1:</h3><p>如果小组内都想同时开发共用同一个数据库，可以利用云服务器docker部署一个mysql，然后使用这个云服务器上的mysql</p><h3 id="tips2："><a href="#tips2：" class="headerlink" title="tips2："></a>tips2：</h3><p>想要实现数据库里面商品携带商品图片</p><p>可以将商品图片转化为url链接存入</p><p>然后mysql类型定义为varchar并且长度为2083</p><h3 id="tips3唯一索引："><a href="#tips3唯一索引：" class="headerlink" title="tips3唯一索引："></a>tips3唯一索引：</h3><p>想要解决good的名称唯一可以直接利用mysql的唯一索引</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114165218161.png" class title="image-20221114165218161"><p>这样就限制了存入数据库的name是唯一的</p><h2 id="前后端代码：管理员模块"><a href="#前后端代码：管理员模块" class="headerlink" title="前后端代码：管理员模块"></a>前后端代码：管理员模块</h2><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>1.采用常见的entity，mapper，service，controller层关系分类设计</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114204231439.png" class title="image-20221114204231439"><h3 id="2-登录功能"><a href="#2-登录功能" class="headerlink" title="2.登录功能"></a>2.登录功能</h3><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114205236817.png" class title="image-20221114205236817"><h3 id="3-管理界面"><a href="#3-管理界面" class="headerlink" title="3.管理界面"></a>3.管理界面</h3><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114205307391.png" class title="image-20221114205307391"><h3 id="4-添加员工，商品，品牌"><a href="#4-添加员工，商品，品牌" class="headerlink" title="4.添加员工，商品，品牌"></a>4.添加员工，商品，品牌</h3><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114205407434.png" class title="image-20221114205407434"><h2 id="前后端代码：客户手机端模块"><a href="#前后端代码：客户手机端模块" class="headerlink" title="前后端代码：客户手机端模块"></a>前后端代码：客户手机端模块</h2><h3 id="介绍：采用的是单页面vue3设计"><a href="#介绍：采用的是单页面vue3设计" class="headerlink" title="介绍：采用的是单页面vue3设计"></a>介绍：采用的是单页面vue3设计</h3><p>这里实现前后分离，基本利用vue实现逻辑</p><p>整体思路是通过mail_good暴露出来的接口获取到商品数据</p><p>然后根据获取到的数据进行页面展示</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114165000162.png" class title="image-20221114165000162"><h2 id="运维打包放入docker部署k8s模块"><a href="#运维打包放入docker部署k8s模块" class="headerlink" title="运维打包放入docker部署k8s模块"></a>运维打包放入docker部署k8s模块</h2><p>docker在虚拟机192.168.217.128配置好了</p><p>同时在本机windows也配置了docker</p><p>利用idea集成docker来打包</p><p>alt+8快捷键打开docker</p><p>docker build -t 944613709&#x2F;mail-employee:3.0 .<br>docker build -t 944613709&#x2F;mail-brand:3.0 .</p><p>docker build -t 944613709&#x2F;mail-good:3.0 .</p><p>docker build -t 944613709&#x2F;gateway:3.0 .</p><p>docker push 944613709&#x2F;mail-employee:3.0<br>docker push 944613709&#x2F;mail-brand:3.0<br>docker push 944613709&#x2F;mail-good:3.0</p><p>docker push 944613709&#x2F;gateway:3.0</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114201103721.png" class title="image-20221114201103721"><h2 id="sentinel"><a href="#sentinel" class="headerlink" title="sentinel"></a>sentinel</h2><p>在云服务器要打开对应的防火墙端口</p><p>不然访问不到</p><h2 id="后端跨域问题"><a href="#后端跨域问题" class="headerlink" title="后端跨域问题"></a>后端跨域问题</h2><p>后端跨域由springcloud组件解决了</p><p>SpringCloudApiGateway之支持Cors跨域请求</p><p> 配置代理可解决使用Axios不能直接进行跨域的问题。</p><h2 id="手机端购物车"><a href="#手机端购物车" class="headerlink" title="手机端购物车"></a>手机端购物车</h2><p>后端在给定一个接口</p><p>localhost:8082&#x2F;good&#x2F;list</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114115855526.png" class title="image-20221114115855526"><h2 id="k8s使用kubesphere"><a href="#k8s使用kubesphere" class="headerlink" title="k8s使用kubesphere"></a>k8s使用kubesphere</h2><p>1.直接利用kubesphere进行k8s部署以及管理，这里图形化操作做得比原生的操作界面好</p><p>2,在模拟了实际公司开发中，模拟本程序是有wuhan企业空间</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114112448806.png" class title="image-20221114112448806"><p>3.在wuhan企业空间就有本次项目</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="遇上的问题1：阿里云经常重启之后失效"><a href="#遇上的问题1：阿里云经常重启之后失效" class="headerlink" title="遇上的问题1：阿里云经常重启之后失效"></a>遇上的问题1：阿里云经常重启之后失效</h3><p>发现阿里云重启需要十多分钟</p><p>Q1 ：阿里云服务器密码</p><p>root</p><p>Szf!250772730</p><h3 id="Q2：kubesphere经常忘记密码"><a href="#Q2：kubesphere经常忘记密码" class="headerlink" title="Q2：kubesphere经常忘记密码"></a>Q2：kubesphere经常忘记密码</h3><p>直接用命令改密码</p><p>kubectl patch users admin -p ‘{“spec”:{“password”:”123456”}}’ –type&#x3D;’merge’ &amp;&amp; kubectl annotate users admin iam.kubesphere.io&#x2F;password-encrypted-</p><p>现在密码是</p><p>admin</p><p>Szf!250772730</p><h3 id="Q3：前端的手机端跨域问题"><a href="#Q3：前端的手机端跨域问题" class="headerlink" title="Q3：前端的手机端跨域问题"></a>Q3：前端的手机端跨域问题</h3><p>由于手机端是localhost3000</p><p>所以访问localhost8082时候有cors警告跨域问题</p><p>使用前端axios代理服务器解决跨域问题失败</p><p>前端要访问localhost10010通过网关解决跨域问题</p><h3 id="通过后端springcloud-nacos解决了前端跨域问题"><a href="#通过后端springcloud-nacos解决了前端跨域问题" class="headerlink" title="通过后端springcloud nacos解决了前端跨域问题"></a>通过后端springcloud nacos解决了前端跨域问题</h3><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221115141551454.png" class title="image-20221115141551454"><p>A在dev时候利用apifox暂时跳过</p><p>Q4：怎么在goods存入对应图片</p><p>数据库插入img网址</p><p>mysql的img应该设置类型varchar,长度设置为2083</p><p>否则会发生过长警告</p><p>Q4：虚拟机ifconfig没有出来ip地址</p><p>nat切换桥联再切换回nat</p><h2 id="gateway网关的使用"><a href="#gateway网关的使用" class="headerlink" title="gateway网关的使用"></a>gateway网关的使用</h2><p><a href="http://localhost:10010/backend/index.html">http://localhost:10010/backend/index.html</a></p><p>改为访问这个网站</p><h3 id="localhost和127-0-0-1虽然都指向本机，但也属于跨域"><a href="#localhost和127-0-0-1虽然都指向本机，但也属于跨域" class="headerlink" title="localhost和127.0.0.1虽然都指向本机，但也属于跨域"></a><strong>localhost和127.0.0.1虽然都指向本机，但也属于跨域</strong></h3><h2 id="图片的存放"><a href="#图片的存放" class="headerlink" title="图片的存放"></a>图片的存放</h2><p>存放在resource通过浏览器可以直接访问到</p><p>resourece&#x2F;images&#x2F;goods</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="短信登录服务"><a href="#短信登录服务" class="headerlink" title="短信登录服务"></a>短信登录服务</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221117194924621.png" class title="image-20221117194924621"><p>直接用aliyun给出的api</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221117195421941.png" class title="image-20221117195421941"><h2 id="vue可视化推荐"><a href="#vue可视化推荐" class="headerlink" title="vue可视化推荐"></a>vue可视化推荐</h2><p><a href="https://vform666.com/vform3.html?from=element_plus">https://vform666.com/vform3.html?from=element_plus</a></p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221203214551261.png" class title="image-20221203214551261"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221203215211736.png" class title="image-20221203215211736"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221204140853062.png" class title="image-20221204140853062"><p>合适的vant组件，已经给定了type&#x3D;tel自动检验是否为手机号</p><h2 id="vue动态引入依赖"><a href="#vue动态引入依赖" class="headerlink" title="vue动态引入依赖"></a>vue动态引入依赖</h2><p><a href="https://element-plus.gitee.io/zh-CN/guide/quickstart.html#%E6%8C%89%E9%9C%80%E5%AF%BC%E5%85%A5">https://element-plus.gitee.io/zh-CN/guide/quickstart.html#按需导入</a></p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221203214357539.png" class title="image-20221203214357539"><p>自动引入vant和element plus依赖</p><p>非常好用</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221203214900976.png" class title="image-20221203214900976"><h2 id="小心bug"><a href="#小心bug" class="headerlink" title="小心bug"></a>小心bug</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221204142025199.png" class title="image-20221204142025199"><h2 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h2><h3 id="watch实现步骤美化"><a href="#watch实现步骤美化" class="headerlink" title="watch实现步骤美化"></a>watch实现步骤美化</h3><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221204145825346.png" class title="image-20221204145825346"><h2 id="k8s安装jenkins"><a href="#k8s安装jenkins" class="headerlink" title="k8s安装jenkins"></a>k8s安装jenkins</h2><p>1.在csdn找非官方教程吃了很多亏</p><p>2.我最后在官网教程一下子就搞好了yyds</p><p><a href="https://www.jenkins.io/doc/book/installing/kubernetes/">https://www.jenkins.io/doc/book/installing/kubernetes/</a></p><h1 id="后端接口导出至postman"><a href="#后端接口导出至postman" class="headerlink" title="后端接口导出至postman"></a>后端接口导出至postman</h1><p>直接利用easyAPi</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221208154220470.png" class title="image-20221208154220470"><h1 id="部署对接出现问题"><a href="#部署对接出现问题" class="headerlink" title="部署对接出现问题"></a>部署对接出现问题</h1><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221208160622644.png" class title="image-20221208160622644"><h1 id="管理端前端跨域问题，其实没解决"><a href="#管理端前端跨域问题，其实没解决" class="headerlink" title="管理端前端跨域问题，其实没解决"></a>管理端前端跨域问题，其实没解决</h1><p>当时我用了临时解决措施：</p><p>就是前端没有跨域，借助了同一个端口的后端接口，后端接口再去调用feign来跨过端口调用真正的后端访存数据库接口</p><h1 id="安装nacos"><a href="#安装nacos" class="headerlink" title="安装nacos"></a>安装nacos</h1><p>因为安装nacos比较麻烦还需要依赖mysql数据库</p><p>官网失败</p><p>kubesphere失败</p><p>最后用的helm安装一键完成</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221213115002337.png" class title="image-20221213115002337"><h1 id="loginMessage模块不需要连接数据库，但是springboot的druid依赖默认要求连接数据库"><a href="#loginMessage模块不需要连接数据库，但是springboot的druid依赖默认要求连接数据库" class="headerlink" title="loginMessage模块不需要连接数据库，但是springboot的druid依赖默认要求连接数据库"></a>loginMessage模块不需要连接数据库，但是springboot的druid依赖默认要求连接数据库</h1><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221213115448241.png" class title="image-20221213115448241"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221213115858272.png" class title="image-20221213115858272"><p>由于Springboot我加了druid依赖</p><p>最后选择加入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@SpringBootApplication(<span class="hljs-params">exclude = &#123;</span></span><br><span class="hljs-params"><span class="hljs-meta">        DataSourceAutoConfiguration.<span class="hljs-keyword">class</span>,</span></span><br><span class="hljs-params"><span class="hljs-meta">        DataSourceTransactionManagerAutoConfiguration.<span class="hljs-keyword">class</span>,</span></span><br><span class="hljs-params"><span class="hljs-meta">        DruidDataSourceAutoConfigure.<span class="hljs-keyword">class</span> ,</span></span><br><span class="hljs-params"><span class="hljs-meta">        HibernateJpaAutoConfiguration.<span class="hljs-keyword">class</span>&#125;</span>)</span><br></code></pre></td></tr></table></figure><h1 id="新增手机客户端后，前端设计要求数据库中的表额外多出good-count-goods-state，且要求某些数据的类型作出调整"><a href="#新增手机客户端后，前端设计要求数据库中的表额外多出good-count-goods-state，且要求某些数据的类型作出调整" class="headerlink" title="新增手机客户端后，前端设计要求数据库中的表额外多出good_count,goods_state，且要求某些数据的类型作出调整"></a>新增手机客户端后，前端设计要求数据库中的表额外多出good_count,goods_state，且要求某些数据的类型作出调整</h1><p>因为当时已经完成了管理员端的前后端部分，最后认定不应该再去调整数据库，否则前面的也都得改动</p><p>于是只在手机客户端中根据传入的数据，自行作出调整，（新增数据属性，修改数据类型）</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221214102953933.png" class title="image-20221214102953933"><h1 id="由于axios的异步调用，created和mounted无法使用async"><a href="#由于axios的异步调用，created和mounted无法使用async" class="headerlink" title="由于axios的异步调用，created和mounted无法使用async"></a>由于axios的异步调用，created和mounted无法使用async</h1><p>于是采用了换函数执行位置</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221214110755760.png" class title="image-20221214110755760"><h1 id="服务器内存问题，导致服务器爆炸"><a href="#服务器内存问题，导致服务器爆炸" class="headerlink" title="服务器内存问题，导致服务器爆炸"></a>服务器内存问题，导致服务器爆炸</h1><p>在同时部署了多个pods之后，内存又不够了，导致我服务器已经卡死，ssh命令都特别慢</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%89%93%E5%8D%B0%E7%9B%AE%E5%BD%95/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%89%93%E5%8D%B0%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="第二章开发技术"><a href="#第二章开发技术" class="headerlink" title="第二章开发技术"></a>第二章开发技术</h1><h2 id="1-面向服务开发基础"><a href="#1-面向服务开发基础" class="headerlink" title="1. 面向服务开发基础"></a><strong>1.</strong> <strong>面向服务开发基础</strong></h2><p><strong>1.1 Web</strong>开发基础</p><p>Web系统体系结构 2</p><p>Web容器 3</p><p>1.2 Web开发技术演进</p><p>​HTTP</p><p>​CGI</p><p>​模板引擎</p><p>​JAVAEE</p><p><strong>1.3 Spring Boot</strong>  13</p><h2 id="2-RPC"><a href="#2-RPC" class="headerlink" title="2. RPC"></a><strong>2.</strong> <strong>RPC</strong></h2><p><strong>1.RPC是什么</strong></p><p>​RPC是什么 3</p><p>​RPC分类 4-7</p><p><strong>2.RPC的发展</strong></p><p><strong>3.XML-RPC</strong></p><p><strong>4.JSON-RPC</strong></p><h2 id="3-Web-Service（WSDL、SOAP、UDDI）"><a href="#3-Web-Service（WSDL、SOAP、UDDI）" class="headerlink" title="3. Web Service（WSDL、SOAP、UDDI）"></a><strong>3.</strong> <strong>Web Service</strong>（<strong>WSDL</strong>、<strong>SOAP</strong>、<strong>UDDI</strong>）</h2><p><strong>1.</strong> <strong>什么是WebService</strong> 3</p><p>​WebServicee体系结构 4</p><p>​WebService三种基本元素 7</p><p><strong>2.</strong> <strong>WebService与RPC</strong></p><p><strong>3.</strong> <strong>WSDL</strong></p><p><strong>4.</strong> <strong>UDDI</strong></p><p><strong>5.</strong> <strong>SOAP</strong></p><p><strong>6.</strong> <strong>举例</strong></p><h2 id="4-RESTful-Web-Service"><a href="#4-RESTful-Web-Service" class="headerlink" title="4. RESTful Web Service"></a><strong>4.</strong> <strong>RESTful Web Service</strong></h2><h1 id="第三章SOA"><a href="#第三章SOA" class="headerlink" title="第三章SOA"></a>第三章SOA</h1><h2 id="SOA的基本概念"><a href="#SOA的基本概念" class="headerlink" title="SOA的基本概念"></a>SOA的基本概念</h2><p>SOA解决问题 4</p><p>SOA特性 7</p><p>SOA服务设计原则 9</p><h2 id="SOMA开发方法"><a href="#SOMA开发方法" class="headerlink" title="SOMA开发方法"></a>SOMA开发方法</h2><p>敏捷开发 23</p><p>服务外包和众包 28</p><h2 id="ESB原理与机制"><a href="#ESB原理与机制" class="headerlink" title="ESB原理与机制"></a>ESB原理与机制</h2><p>ESB概念 37</p><p>ESB功能 42</p><p>ESB关键技术 47</p><p>ESB优势 50</p><h2 id="服务组合与BPEL"><a href="#服务组合与BPEL" class="headerlink" title="服务组合与BPEL"></a>服务组合与BPEL</h2><p>服务编制与编排 53</p><p>通过BPEL实现服务组合（编制与编排） 56</p><h3 id="BPEL待学"><a href="#BPEL待学" class="headerlink" title="BPEL待学"></a>BPEL待学</h3><h2 id="Web2-0与Web3-0"><a href="#Web2-0与Web3-0" class="headerlink" title="Web2.0与Web3.0"></a>Web2.0与Web3.0</h2><p>Web2.0 主要技术 95</p><p>Web 3.0 102</p><h2 id="服务Mashup"><a href="#服务Mashup" class="headerlink" title="服务Mashup"></a>服务Mashup</h2><p>Mashup实现技术 107</p><h1 id="第四章分布式"><a href="#第四章分布式" class="headerlink" title="第四章分布式"></a>第四章分布式</h1><h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><p>分布式技术演进 2</p><p>dubbo框架图 10</p><p>springcloud框架图 11</p><p>分布式服务框架特性 13</p><p>分布式服务性能特性 16</p><h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><p>znode树 24</p><p>znode 操作指令，操作原语 29</p><p>zookeeper 的 server-client 31</p><p>zookeeper 的Leader-Follower 32</p><p>Leader功能 33</p><p>Leader 选举 34</p><p>Follower 36</p><p>zookeeper的消息同步watcher 37</p><p>zookeeper的服务注册 43</p><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p>dubbo解决的问题 49</p><p>dubbo 架构图 50</p><p>dubbo 提供者和消费者调用关系 51</p><p>dubbo 特性 52</p><p><strong>Dubbo</strong>与Spring Cloud 53</p><p>dubbo总体架构10层设计图 54</p><p>dubbo的伸缩和扩展 57</p><p>spring的 IOC控制反转 60</p><p>控制反转好处 62</p><p>使用dubbo 的spring xml配置 66</p><h2 id="Netty-76-有资料打印"><a href="#Netty-76-有资料打印" class="headerlink" title="Netty 76   -有资料打印"></a>Netty 76   -有资料打印</h2><p>对比Java NIO, Netty的性能优势 81</p><p>阻塞IO 82</p><p>线程管理的selector的io复用 83</p><p>Netty的io复用 84</p><p>事件处理模型 85</p><p>Reactor 线程模型 86</p><p>Reactors多线程模型88</p><p>Netty主要模块组件89</p><p>Netty工作流程 90</p><p>Netty的性能 94</p><h1 id="第五章微服务"><a href="#第五章微服务" class="headerlink" title="第五章微服务"></a>第五章微服务</h1><h2 id="微服务理论"><a href="#微服务理论" class="headerlink" title="微服务理论"></a>微服务理论</h2><p>为什么要微服务 1</p><p>什么是微服务 4</p><p>微服务需要做到哪些 6</p><p>微服务的复杂来源于哪 8</p><p>微服务与SOA 12</p><p>​SOA关注点</p><p>​微服务关注点</p><p>微服务设计原则 16</p><h2 id="微服务消息机制"><a href="#微服务消息机制" class="headerlink" title="微服务消息机制"></a>微服务消息机制</h2><p>微服务的消息代理 26</p><p>同步消息与异步消息 27 28</p><p>消息中间件 29</p><p>服务定义接口31</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Http Server 33</p><p>Application Server 34</p><p>Soap Engine 35</p><p>什么是LXC 39</p><p>docker和OS对比 40</p><p>docker 特点 43</p><p>docker对比虚拟机存在的缺点 45</p><p>docker引擎 46</p><p>docker架构 47</p><p>docker镜像 48</p><p>docker仓库 50</p><p>docker容器 52</p><h2 id="Docker调度工具"><a href="#Docker调度工具" class="headerlink" title="Docker调度工具"></a>Docker调度工具</h2><p>为什么要调度工具 56</p><p>主流调度工具 57</p><p>k8s 58</p><p>k8s基本组成部分 60</p><p>k8s谓词 优先级 65</p><h2 id="devops"><a href="#devops" class="headerlink" title="devops"></a>devops</h2><p>devops定义 72</p><p>devops 六大原则 73</p><p>CICD 74</p><p>持续集成的最佳实践 76</p><p>持续交付流程 78</p><p>jenkins 81</p><h1 id="第六章服务质量"><a href="#第六章服务质量" class="headerlink" title="第六章服务质量"></a>第六章服务质量</h1><p>什么是服务质量 2</p><p>服务质量的两个方面，四大特征 4</p><p>商务服务质量维度 5</p><p>IT服务系统中的质量评价指标 7</p><p>5GAP服务质量差距 11</p><p>服务等级协议SLA 13</p><p>5个Gap出现的原因15</p><p>服务系统设计要经历的阶段 15</p><p>如何消除Gap 15</p><h1 id="打印网页资料目录"><a href="#打印网页资料目录" class="headerlink" title="打印网页资料目录"></a>打印网页资料目录</h1><p>Bpel</p><p>docker架构设计</p><p>dubbo简介</p><p>SOA和微服务区别</p><p>SOA架构和微服务架构区别</p><p>springcloud和dubbo区别</p><p>Web服务器，Http服务器，应用程序服务器，区别</p><p>zookeeper的watcher</p><p>zookeeper的选举算法</p><p>Netty</p><p>Netty工作流程</p><p>服务编制和编排</p><p>什么是SOA</p><p>什么是负载均衡</p><p>微服务组织架构</p><p>SLA</p><h1 id="实验报告目录"><a href="#实验报告目录" class="headerlink" title="实验报告目录"></a>实验报告目录</h1><h2 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h2><p>1、 项目中的pom.xml中的dependencies是什么？有什么作用？</p><p>1、 服务接口中方法参数中@webparam注解用与不用的实验结果是否会有变化？</p><p>1、 方法实现中@webservice注解中的参数endpointInterface和serviceName分别代表了什么？</p><p>1、 注解@RequestParam和@PathVariable分别表示什么？</p><p>1、 用以下URL：<a href="http://localhost:8080/hallo/2%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%AE%9E%E9%AA%8C%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%BC%9A%E5%BE%97%E5%88%B0%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%9C%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E9%87%8A%E8%AF%A5%E7%BB%93%E6%9E%9C%EF%BC%9F">http://localhost:8080/hallo/2访问本实验的服务会得到什么结果？如何解释该结果？</a></p><p>Ø 结合本次实验感受，试分析基于服务的软件系统与你以往做过的软件有何区别？可以从软件结构、开发过程、调试方法等方面阐述。</p><h2 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h2><p>1、 Dubbo框架与Zookeeper框架之间的关系是什么？如何将Zookeeper框架与Dubbo框架进行集成？</p><p>1、 Dubbo框架中的Dubbo-master的作用是什么？</p><p>1、 Dubbo框架下Service Provider发布服务的过程，及过程中的关键点。</p><p>1、 Dubbo框架下Service Consumer消费服务的过程，及过程中的关键点。</p><p>1、 详细描述你的服务的发布过程和被消费方式。</p><h2 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h2><p>1、 容器虚拟化和传统虚拟化的区别是什么？</p><p>1、 如何实现 Kubernetes 自动化部署？</p><p>1、 Kubernetes有哪些核心组件，其功能是什么？</p><p>1、 Kubernetes搭建过程中遇到的问题，与解决办法。</p><h2 id="实验4"><a href="#实验4" class="headerlink" title="实验4"></a>实验4</h2><p>1、 如果你要从头开发一个基于微服务架构的项目，项目中的服务最终要部署在k8s管理的镜像环境中，你认为应如何创建项目？与本次实验过程相比，哪些改进可以让开发更加合理高效？</p><p>1、 如何将实验中多个provider服务实例的负载均衡策略改为轮询调用？即在多次反复调用时轮流调用各个服务实例。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="分布式微服务"><a href="#分布式微服务" class="headerlink" title="分布式微服务"></a>分布式微服务</h1><h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221029105633076.png" alt="image-20221029105633076"></p><h2 id="log4j-properties"><a href="#log4j-properties" class="headerlink" title="log4j.properties"></a>log4j.properties</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">log4j.rootLogger</span>=debug, stdout, R<br><span class="hljs-comment">#log4j.rootLogger = [ level ] , appenderName, appenderName, …</span><br><span class="hljs-comment">#OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL</span><br><span class="hljs-comment">#Log4j有一个规则：只输出级别不低于设定级别的日志信息，假设Loggers级别设定为INFO，则INFO</span><br><span class="hljs-comment">#、WARN、ERROR和FATAL级别的日志信息都会输出，而级别比INFO低的DEBUG则不会输出。</span><br><br><span class="hljs-attr">log4j.appender.stdout</span>=org.apache.log4j.ConsoleAppender<br><span class="hljs-attr">log4j.appender.stdout.layout</span>=org.apache.log4j.PatternLayout<br><br><span class="hljs-comment"># Pattern to output the caller&#x27;s file name and line number.</span><br><span class="hljs-attr">log4j.appender.stdout.layout.ConversionPattern</span>=%<span class="hljs-number">5</span>p [%t] (%F:%L) - %m%n<br><br><span class="hljs-attr">log4j.appender.R</span>=org.apache.log4j.RollingFileAppender<br><span class="hljs-attr">log4j.appender.R.File</span>=example.log<br><br><span class="hljs-attr">log4j.appender.R.MaxFileSize</span>=<span class="hljs-number">100</span>KB<br><span class="hljs-comment"># Keep one backup file</span><br><span class="hljs-attr">log4j.appender.R.MaxBackupIndex</span>=<span class="hljs-number">5</span><br><br><span class="hljs-attr">log4j.appender.R.layout</span>=org.apache.log4j.PatternLayout<br><span class="hljs-attr">log4j.appender.R.layout.ConversionPattern</span>=%p %t %c - %m%n<br><br><span class="hljs-comment">#org.apache.log4j.ConsoleAppender（控制台），</span><br><span class="hljs-comment">#org.apache.log4j.FileAppender（文件），  </span><br><span class="hljs-comment">#org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</span><br><span class="hljs-comment">#org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），  </span><br><span class="hljs-comment">#org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</span><br></code></pre></td></tr></table></figure><h2 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/b92cafea69b1419bbf88dbe687b4deb2.png" class title="2.png"><p>SOA（全称：Service Oriented Architecture），中文意思为 “面向服务的架构”，你可以将它理解为一个架构模型或者一种设计方法，而并不是服务解决方案。</p><p>其中包含多个服务， 服务之间通过相互依赖或者通过通信机制，来完成相互通信的，最终提供一系列的功能。一个服务通常以独立的形式存在与操作系统进程中。各个服务之间通过网络调用 。</p><p>跟 SOA 相提并论的还有一个 ESB（企业服务总线），简单来说ESB就是一根管道，用来连接各个服务节点。为了集成不同系统，不同协议的服务，ESB 可以简单理解为：它做了消息的转化解释和路由工作，让不同的服务互联互通；</p><p>我们将各个应用之间彼此的通信全部去掉，在中间引入一个ESB企业总线，各个服务之间，只需要和ESB进行通信，这个时候，各个应用之间的交互就会变得更加的清晰，业务架构&#x2F;逻辑等，也会变得很清楚。</p><p>原本杂乱没有规划的系统，梳理成了一个有规划可治理的系统，在这个过程中，最大的变化，就是引入了ESB企业总线。</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/f94d72cc1b4e441fb57cff5d78625857.png" class title="3.png"><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>微服务架构其实和SOA架构类似，微服务是在SOA上做的升华。微服务架构重点强调的一个是”业务需要彻底的组件化和服务化”，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这样的小应用和其他各个应用之间，相互去协作通信，来完成一个交互和集成，这就是微服务架构。</p><p><strong>每个微服务有自己私有的数据库持久化业务数据。</strong></p><p>• <strong>每个微服务只能访问自己的数据库，而不能访问其它服</strong></p><p><strong>务的数据库。</strong></p><p>• <strong>数据的去中心化，进一步降低了微服务之间的耦合度，</strong></p><p><strong>不同服务可采用不同数据库技术（<strong><strong>SQL</strong></strong>、<strong><strong>NoSQL</strong></strong>等）。</strong></p><p><strong>在复杂的业务场景下，如果包含多个微服务，通常在客</strong></p><p><strong>户端或者中间层（网关）处理。</strong></p><p>微服务的特征<br>1.通过服务实现组件化<br>2.按业务能力来划分服务和开发团队<br>3.去中心化<br>4.基础设施自动化（devops、自动化部署）</p><h2 id="SOA-和微服务架构的差别"><a href="#SOA-和微服务架构的差别" class="headerlink" title="SOA 和微服务架构的差别"></a>SOA 和微服务架构的差别</h2><p>1.微服务去中心化，去掉ESB企业总线。微服务不再强调传统SOA架构里面比较重的ESB企业服务总线，同时SOA的思想进入到单个业务系统内部实现真正的组件化</p><p>2.Docker容器技术的出现，为微服务提供了更便利的条件，比如更小的部署单元，每个服务可以通过类似Node或者Spring Boot等技术跑在自己的进程中。</p><p>3.SOA注重的是系统集成方面，而微服务关注的是完全分离</p><h1 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h1><h2 id="SOAP规定了哪些（部分）"><a href="#SOAP规定了哪些（部分）" class="headerlink" title="SOAP规定了哪些（部分）"></a>SOAP规定了哪些（部分）</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218135845978.png" class title="image-20230218135845978"><h2 id="zookeeper的follower和Leader"><a href="#zookeeper的follower和Leader" class="headerlink" title="zookeeper的follower和Leader"></a>zookeeper的follower和Leader</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215143435218.png" class title="image-20230215143435218"><h2 id="ESB包括哪些服务"><a href="#ESB包括哪些服务" class="headerlink" title="ESB包括哪些服务"></a>ESB包括哪些服务</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215224853879.png" class title="image-20230215224853879"><h2 id="什么是ESB"><a href="#什么是ESB" class="headerlink" title="什么是ESB"></a>什么是ESB</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215230810134.png" class title="image-20230215230810134"><h2 id="SOA是一种具体的技术吗"><a href="#SOA是一种具体的技术吗" class="headerlink" title="SOA是一种具体的技术吗"></a>SOA是一种具体的技术吗<img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215230823919.png" class title="image-20230215230823919"></h2><h2 id="在SOA中为什么要用ESB，而不是点对点发消息"><a href="#在SOA中为什么要用ESB，而不是点对点发消息" class="headerlink" title="在SOA中为什么要用ESB，而不是点对点发消息"></a>在SOA中为什么要用ESB，而不是点对点发消息</h2><p>应用A发送消息给ESB，ESB再将消息转换给应用B，那么应用A直接通过SOAP协议发送给B，效率不是应该更高吗？而且如果这些IT系统都在一个网络中，提供的WebService都在统一命名空间下，就可以相互通信，为什么还要加上这一层？有两点需要考虑。第一点。点对点做服务的时候，通常需要考虑日志记录，服务访问安全、传输安全、数据安全、路由分发等一系列问题，而这些完全可以统一管理，统一验证，灵活配置，；如果应用A调用了应用B，在调用了应用C等具有逻辑流程的调用时，还可以在ESB上实现流程引擎；第二点，ESB是一个中间件平台，包含了消息中间件的全部功能，有异步消息处理机制，可以实现业务系统之间真正的松耦合的结构。</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="为什么ESB是SOA重要架构部分，而Dubbo却不使用ESB"><a href="#为什么ESB是SOA重要架构部分，而Dubbo却不使用ESB" class="headerlink" title="为什么ESB是SOA重要架构部分，而Dubbo却不使用ESB"></a>为什么ESB是SOA重要架构部分，而Dubbo却不使用ESB</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215231233261.png" class title="image-20230215231233261"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215231442676.png" class title="image-20230215231442676"><h2 id="负载均衡的意义"><a href="#负载均衡的意义" class="headerlink" title="负载均衡的意义"></a>负载均衡的意义</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215231652520.png" class title="image-20230215231652520"><h2 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218104603238.png" class title="image-20230218104603238"><h2 id="持续集成CI"><a href="#持续集成CI" class="headerlink" title="持续集成CI"></a>持续集成CI<img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215232516175.png" class title="image-20230215232516175"></h2><h2 id="CICD"><a href="#CICD" class="headerlink" title="CICD"></a>CICD<img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215232552469.png" class title="image-20230215232552469"></h2><h2 id="什么是CICD"><a href="#什么是CICD" class="headerlink" title="什么是CICD"></a>什么是CICD</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215232633514.png" class title="image-20230215232633514"><h2 id="幂等性，分布式服务系统中有哪些服务需要幂等性"><a href="#幂等性，分布式服务系统中有哪些服务需要幂等性" class="headerlink" title="幂等性，分布式服务系统中有哪些服务需要幂等性"></a>幂等性，分布式服务系统中有哪些服务需要幂等性</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215232856025.png" class title="image-20230215232856025"><h2 id="分布式服务系统中有哪些服务"><a href="#分布式服务系统中有哪些服务" class="headerlink" title="分布式服务系统中有哪些服务"></a>分布式服务系统中有哪些服务</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218140818842.png" class title="image-20230218140818842"><h2 id="CAP-1"><a href="#CAP-1" class="headerlink" title="CAP"></a>CAP</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215232940356.png" class title="image-20230215232940356"><h2 id="服务雪崩效应"><a href="#服务雪崩效应" class="headerlink" title="服务雪崩效应"></a>服务雪崩效应<img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215233517621.png" class title="image-20230215233517621"></h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215233550837.png" class title="image-20230215233550837"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215233654160.png" class title="image-20230215233654160"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218132230813.png" class title="image-20230218132230813"><h2 id="单体架构应用和微服务架构应用区别"><a href="#单体架构应用和微服务架构应用区别" class="headerlink" title="单体架构应用和微服务架构应用区别"></a>单体架构应用和微服务架构应用区别<img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215234141735.png" class title="image-20230215234141735"></h2><h2 id="单体架构到SOA到微服务"><a href="#单体架构到SOA到微服务" class="headerlink" title="单体架构到SOA到微服务"></a>单体架构到SOA到微服务</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215232421659.png" class title="image-20230215232421659"><h2 id="dependecies作用"><a href="#dependecies作用" class="headerlink" title="dependecies作用"></a>dependecies作用<img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216213917677.png" class title="image-20230216213917677"></h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216214110594.png" class title="image-20230216214110594"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216214124335.png" class title="image-20230216214124335"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216214231684.png" class title="image-20230216214231684"><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218114512116.png" class title="image-20230218114512116"><h2 id="消息代理架构"><a href="#消息代理架构" class="headerlink" title="消息代理架构"></a>消息代理架构</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216220959251.png" class title="image-20230216220959251"><h2 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216221354457.png" class title="image-20230216221354457"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216221412566.png" class title="image-20230216221412566"><h2 id="WSDL"><a href="#WSDL" class="headerlink" title="WSDL"></a>WSDL</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216221428225.png" class title="image-20230216221428225"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216221452712.png" class title="image-20230216221452712"><h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216222101456.png" class title="image-20230216222101456"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216222144591.png" class title="image-20230216222144591"><h2 id="DevOps理念"><a href="#DevOps理念" class="headerlink" title="DevOps理念"></a>DevOps理念</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216222725075.png" class title="image-20230216222725075"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216222839230.png" class title="image-20230216222839230"><h2 id="Docker会全面取代KVM吗"><a href="#Docker会全面取代KVM吗" class="headerlink" title="Docker会全面取代KVM吗"></a>Docker会全面取代KVM吗<img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215231027326.png" class title="image-20230215231027326"></h2><h2 id="docker调度工具"><a href="#docker调度工具" class="headerlink" title="docker调度工具"></a>docker调度工具</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216221943667.png" class title="image-20230216221943667"><h2 id="docker的C-x2F-S"><a href="#docker的C-x2F-S" class="headerlink" title="docker的C&#x2F;S"></a>docker的C&#x2F;S</h2><p>docker本身其实是一个server的形式存在着的，叫做docker daemon，也叫做dockerd，那么怎么与这个server进行通信呢？当然想到要用一个client客户端，client客户端有很多种形式，比如我们经常在命令行敲的docker工具，它就是一个client，另外比如windows或mac系统装的桌面版docker，那也是客户端（这个也可以操控dockerd），总之有很多形式的客户端。所以docker工作本身是一个client&#x2F;server架构，客户端通过unix socket进程间通信的方式与服务端做信息交互（默认如果是与本地的dockerd交互的话是这么交互，如果是与远端的dockerd交互需要重新指定host及协议）</p><h2 id="docker容器和镜像区别"><a href="#docker容器和镜像区别" class="headerlink" title="docker容器和镜像区别"></a>docker容器和镜像区别</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218094156630.png" class title="image-20230218094156630"><h2 id="Springcloud的优点"><a href="#Springcloud的优点" class="headerlink" title="Springcloud的优点"></a>Springcloud的优点</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230217234709072.png" class title="image-20230217234709072"><h2 id="Jenkins优点"><a href="#Jenkins优点" class="headerlink" title="Jenkins优点"></a>Jenkins优点</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218103826787.png" class title="image-20230218103826787"><h2 id="docker的优点"><a href="#docker的优点" class="headerlink" title="docker的优点"></a>docker的优点</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218094234689.png" class title="image-20230218094234689"><h2 id="k8s的优点"><a href="#k8s的优点" class="headerlink" title="k8s的优点"></a>k8s的优点</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218094402432.png" class title="image-20230218094402432"><h2 id="SpringBoot优点"><a href="#SpringBoot优点" class="headerlink" title="SpringBoot优点"></a>SpringBoot优点<img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215232256634.png" class title="image-20230215232256634"></h2><h2 id="应用部署方式演变"><a href="#应用部署方式演变" class="headerlink" title="应用部署方式演变"></a>应用部署方式演变</h2><p>在部署应用程序的方式上，主要经历了三个时代：</p><ul><li><p><strong>传统部署</strong>：互联网早期，会直接将应用程序部署在物理机上</p><blockquote><p>优点：简单，不需要其它技术的参与</p><p>缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响</p></blockquote></li><li><p><strong>虚拟化部署</strong>：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境</p><blockquote><p>优点：程序环境不会相互产生影响，提供了一定程度的安全性</p><p>缺点：增加了操作系统，浪费了部分资源</p></blockquote></li><li><p><strong>容器化部署</strong>：与虚拟化类似，但是共享了操作系统</p><blockquote><p>优点：</p><p>​    可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等</p><p>​    运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦</p><p>​    容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署</p></blockquote></li></ul><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20200505183738289.png" class title="image-20200505183738289"><p>容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：</p><ul><li>一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器</li><li>当并发访问量变大的时候，怎么样做到横向扩展容器数量</li></ul><p>这些容器管理的问题统称为<strong>容器编排</strong>问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：</p><ul><li><strong>Swarm</strong>：Docker自己的容器编排工具</li><li><strong>Mesos</strong>：Apache的一个资源统一管控的工具，需要和Marathon结合使用</li><li><strong>Kubernetes</strong>：Google开源的的容器编排工具</li></ul><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20200524150339551.png" alt="image-20200524150339551" style="border:1px solid;zoom:110%;"><h2 id="如何配置jenkins和k8s的集成"><a href="#如何配置jenkins和k8s的集成" class="headerlink" title="如何配置jenkins和k8s的集成"></a>如何配置jenkins和k8s的集成</h2><h2 id="-1"><a href="#-1" class="headerlink" title></a><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218095835686.png" class title="image-20230218095835686"></h2><h2 id="什么是瀑布模型"><a href="#什么是瀑布模型" class="headerlink" title="什么是瀑布模型"></a>什么是瀑布模型</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218100210599.png" class title="image-20230218100210599"><h2 id="什么是敏捷开发"><a href="#什么是敏捷开发" class="headerlink" title="什么是敏捷开发"></a>什么是敏捷开发</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218100339530.png" class title="image-20230218100339530"><h2 id="SOA架构中分库分表的原理和实践方法"><a href="#SOA架构中分库分表的原理和实践方法" class="headerlink" title="SOA架构中分库分表的原理和实践方法"></a>SOA架构中分库分表的原理和实践方法</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218103256766.png" class title="image-20230218103256766"><h2 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218103309644.png" class title="image-20230218103309644"><h2 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218103415951.png" class title="image-20230218103415951"><h2 id="以-rabbitMQ-为代表的现代消息中间件在微服务系统中主要解决了什么问题？"><a href="#以-rabbitMQ-为代表的现代消息中间件在微服务系统中主要解决了什么问题？" class="headerlink" title="以 rabbitMQ 为代表的现代消息中间件在微服务系统中主要解决了什么问题？"></a>以 rabbitMQ 为代表的现代消息中间件在微服务系统中主要解决了什么问题？</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218103617413.png" class title="image-20230218103617413"><h2 id="SLA的好处-可见资料"><a href="#SLA的好处-可见资料" class="headerlink" title="SLA的好处-可见资料"></a>SLA的好处-可见资料</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218130935223.png" class title="image-20230218130935223"><h2 id="传统服务的质量评价和软件服务的质量评价"><a href="#传统服务的质量评价和软件服务的质量评价" class="headerlink" title="传统服务的质量评价和软件服务的质量评价"></a>传统服务的质量评价和软件服务的质量评价</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218140357960.png" class title="image-20230218140357960"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218140239112.png" class title="image-20230218140239112"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218140618212.png" class title="image-20230218140618212"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218140623441.png" class title="image-20230218140623441"><p>分布式服务系统中有哪些服务，详细一点</p><h1 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h1><h2 id="基于服务的软件系统与你以往做过的软件有何区别？可以从软件结构、开发过程、调试方法等方面阐述。"><a href="#基于服务的软件系统与你以往做过的软件有何区别？可以从软件结构、开发过程、调试方法等方面阐述。" class="headerlink" title="基于服务的软件系统与你以往做过的软件有何区别？可以从软件结构、开发过程、调试方法等方面阐述。"></a>基于服务的软件系统与你以往做过的软件有何区别？可以从软件结构、开发过程、调试方法等方面阐述。</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218100620807.png" class title="image-20230218100620807"><h2 id="1、-Dubbo框架与Zookeeper框架之间的关系是什么？如何将Zookeeper框架与Dubbo框架进行集成？"><a href="#1、-Dubbo框架与Zookeeper框架之间的关系是什么？如何将Zookeeper框架与Dubbo框架进行集成？" class="headerlink" title="1、 Dubbo框架与Zookeeper框架之间的关系是什么？如何将Zookeeper框架与Dubbo框架进行集成？"></a>1、 Dubbo框架与Zookeeper框架之间的关系是什么？如何将Zookeeper框架与Dubbo框架进行集成？</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218100725938.png" class title="image-20230218100725938"><h2 id="1、-Dubbo框架中的Dubbo-master的作用是什么？"><a href="#1、-Dubbo框架中的Dubbo-master的作用是什么？" class="headerlink" title="1、 Dubbo框架中的Dubbo-master的作用是什么？"></a>1、 Dubbo框架中的Dubbo-master的作用是什么？</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218101240421.png" class title="image-20230218101240421"><h2 id="1、-Dubbo框架下Service-Provider发布服务的过程，及过程中的关键点。"><a href="#1、-Dubbo框架下Service-Provider发布服务的过程，及过程中的关键点。" class="headerlink" title="1、 Dubbo框架下Service Provider发布服务的过程，及过程中的关键点。"></a>1、 Dubbo框架下Service Provider发布服务的过程，及过程中的关键点。</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218101347388.png" class title="image-20230218101347388"><h2 id="1、-Dubbo框架下Service-Consumer消费服务的过程，及过程中的关键点。"><a href="#1、-Dubbo框架下Service-Consumer消费服务的过程，及过程中的关键点。" class="headerlink" title="1、 Dubbo框架下Service Consumer消费服务的过程，及过程中的关键点。"></a>1、 Dubbo框架下Service Consumer消费服务的过程，及过程中的关键点。</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218101454061.png" class title="image-20230218101454061"><h2 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h2><h2 id="1、-容器虚拟化和传统虚拟化的区别是什么？"><a href="#1、-容器虚拟化和传统虚拟化的区别是什么？" class="headerlink" title="1、 容器虚拟化和传统虚拟化的区别是什么？"></a>1、 容器虚拟化和传统虚拟化的区别是什么？</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218101850785.png" class title="image-20230218101850785"><h2 id="如何实现k8s自动部署"><a href="#如何实现k8s自动部署" class="headerlink" title="如何实现k8s自动部署"></a>如何实现k8s自动部署</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218095625712.png" class title="image-20230218095625712"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218095647111.png" class title="image-20230218095647111"><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218095808936.png" class title="image-20230218095808936"><h2 id="1、-Kubernetes有哪些核心组件，其功能是什么？"><a href="#1、-Kubernetes有哪些核心组件，其功能是什么？" class="headerlink" title="1、 Kubernetes有哪些核心组件，其功能是什么？"></a>1、 Kubernetes有哪些核心组件，其功能是什么？</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218102001596.png" class title="image-20230218102001596"><h2 id="实验4"><a href="#实验4" class="headerlink" title="实验4"></a>实验4</h2><h2 id="1、-如果你要从头开发一个基于微服务架构的项目，项目中的服务最终要部署在k8s管理的镜像环境中，你认为应如何创建项目？与手动部署实验过程相比，哪些改进可以让开发更加合理高效？"><a href="#1、-如果你要从头开发一个基于微服务架构的项目，项目中的服务最终要部署在k8s管理的镜像环境中，你认为应如何创建项目？与手动部署实验过程相比，哪些改进可以让开发更加合理高效？" class="headerlink" title="1、 如果你要从头开发一个基于微服务架构的项目，项目中的服务最终要部署在k8s管理的镜像环境中，你认为应如何创建项目？与手动部署实验过程相比，哪些改进可以让开发更加合理高效？"></a>1、 如果你要从头开发一个基于微服务架构的项目，项目中的服务最终要部署在k8s管理的镜像环境中，你认为应如何创建项目？与手动部署实验过程相比，哪些改进可以让开发更加合理高效？</h2><h2 id="-2"><a href="#-2" class="headerlink" title></a><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218102531002.png" class title="image-20230218102531002"></h2><h2 id="1、-如何将k8s中多个provider服务实例的负载均衡策略改为轮询调用？即在多次反复调用时轮流调用各个服务实例。"><a href="#1、-如何将k8s中多个provider服务实例的负载均衡策略改为轮询调用？即在多次反复调用时轮流调用各个服务实例。" class="headerlink" title="1、 如何将k8s中多个provider服务实例的负载均衡策略改为轮询调用？即在多次反复调用时轮流调用各个服务实例。"></a>1、 如何将k8s中多个provider服务实例的负载均衡策略改为轮询调用？即在多次反复调用时轮流调用各个服务实例。</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218102750666.png" class title="image-20230218102750666">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E5%BB%BA%E8%AE%AE%E9%98%BF%E9%87%8C%E4%BA%91ACK%EF%BC%8C%E7%9B%B4%E6%8E%A5%E8%B4%AD%E4%B9%B0%E6%88%90%E5%93%81k8s%E9%9B%86%E7%BE%A4/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E5%BB%BA%E8%AE%AE%E9%98%BF%E9%87%8C%E4%BA%91ACK%EF%BC%8C%E7%9B%B4%E6%8E%A5%E8%B4%AD%E4%B9%B0%E6%88%90%E5%93%81k8s%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<p>建议阿里云ACK，直接购买成品k8s集群</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E5%BB%BA%E8%AE%AE%E9%98%BF%E9%87%8C%E4%BA%91ACK%EF%BC%8C%E7%9B%B4%E6%8E%A5%E8%B4%AD%E4%B9%B0%E6%88%90%E5%93%81k8s%E9%9B%86%E7%BE%A4/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221209201012331.png" alt="image-20221209201012331"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="盖伦"><a href="#盖伦" class="headerlink" title="盖伦"></a>盖伦</h1><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017195102157.png" alt="image-20221017195102157"></p><p>1B&#x3D;8bit</p><p>1bps&#x3D;1bit&#x2F;s</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221015194408396.png" alt="image-20221015194408396"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015194854414.png" alt="image-20221015194854414"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015195210240.png" alt="image-20221015195210240"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015195428398.png" alt="image-20221015195428398"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015195907366.png" alt="image-20221015195907366"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015200330833.png" alt="image-20221015200330833"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015202240615.png" alt="image-20221015202240615">1</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015202824495.png" alt="image-20221015202824495"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015203518340.png" alt="image-20221015203518340"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015211129781.png" alt="image-20221015211129781"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015211145845.png" alt="image-20221015211145845"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015211314532.png" alt="image-20221015211314532"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015211539077.png"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015211550563.png" alt="image-20221015211550563"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015211806860.png" alt="image-20221015211806860"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015214103306.png" alt="image-20221015214103306"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017154204745.png"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017154415622.png" alt="image-20221017154415622"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017155341312.png" alt="image-20221017155341312"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017160503331.png" alt="image-20221017160503331"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221018190252034.png" alt="image-20221018190252034"></p><h1 id="讲座1（概述）"><a href="#讲座1（概述）" class="headerlink" title="讲座1（概述）"></a>讲座1（概述）</h1><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109202051817.png" class title="image-20221109202051817"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109202847129.png" class title="image-20221109202847129"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109202931862.png" class title="image-20221109202931862"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109204013198.png" class title="image-20221109204013198"><p>1MB &#x3D; 1024KB</p><p>因为是1B&#x3D;8b，所以从10^3变成2^10</p><p>1Mb &#x3D; 1000 000 b</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109204108824.png" class title="image-20221109204108824"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109210426723.png" class title="image-20221109210426723"><p>带宽就是最大吞吐量(类似最大速度)</p><p>吞吐量就是当前实际的mb&#x2F;s（类似速度）  </p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109210628930.png" class title="image-20221109210628930"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109211159594.png" class title="image-20221109211159594"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109211323949.png" class title="image-20221109211323949"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109212200044.png" class title="image-20221109212200044"><p>讲座1（应用层）</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109213915683.png" class title="image-20221109213915683"><p><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE.assets/image-20221110110012645.png" alt="image-20221110110012645"><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE.assets/image-20221110110019772.png" alt="image-20221110110019772"></p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221110161209999.png" class title="image-20221110161209999"><h1 id="讲座2（网络层）"><a href="#讲座2（网络层）" class="headerlink" title="讲座2（网络层）"></a>讲座2（网络层）</h1><h2 id="可靠传输（一般的方式）"><a href="#可靠传输（一般的方式）" class="headerlink" title="可靠传输（一般的方式）"></a>可靠传输（一般的方式）</h2><h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE.assets/image-20221115160853860.png" alt="image-20221115160853860"><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE.assets/image-20221115162419970.png" alt="image-20221115162419970"></p><p>对于GBN的信道利用率</p><p>N越大信道利用率越大</p><h3 id="GBN"><a href="#GBN" class="headerlink" title="GBN"></a>GBN</h3><p><strong>发送方对于：</strong></p><p>收到ACK累计确认</p><p>在GBN 协议中，对序号为n的分组的确认采取累积确认的方式，表明接收方已正确接收到序号为n的以前且包括n在内的所有分组</p><p>发送方仅使用一个定时器</p><p>如果收到 ACK, 但仍有已发送但未被确认的分组，则定时器被重新启动；如果没有巳发送但未被确认的分组，停止该定时器；如果出现超时，发送方重传所有已发送但还未被确认过的分组</p><p><strong>接收方</strong></p><p>对于乱序到达的分组直接丢弃    ACK机制：发送序列号最大的按序的ACK序号</p><h3 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h3><p><strong>发送方：</strong></p><p>每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个分组</p><p>GBN和SR窗口</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115161829329.png" class title="image-20221115161829329"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115162018350.png" class title="image-20221115162018350"><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>包括了TCP如何实现可靠传输</p><p>TCP拥塞控制</p><h3 id="TCp可靠传输的方式"><a href="#TCp可靠传输的方式" class="headerlink" title="TCp可靠传输的方式"></a>TCp可靠传输的方式</h3><p>TCP序号是以字节为单位</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115170536527.png" class title="image-20221115170536527"><p>SR和gBN和停等协议都是确认号&#x3D;序号，且都是以报文段分组为单位</p><p>TCP协议是确认号&#x3D;序号+1，且是以字节Byte为单位</p><p>TCp协议就像是接收方可以缓存的GBN协议（发送方接收到的累计确认）</p><p>且接收方每次发回ACK都会告诉发送方自己的接收窗口实时还可以接收多少，会让发送方自己的发送窗口在每次收到ack之后都会调整自己的发送窗口（发送窗口上限值 &#x3D; MIn（发送方得知的接收窗口rwnd，拥塞窗口cwnd）</p><p>且发送方收到3次重复ACK之后也会重传，这时候的是rwnd减半（快重传）</p><p>TCP发送方在收到ACK确认之后才会将拥塞窗口增大！！！！</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115192721241.png" class title="image-20221115192721241"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115191945696.png" class title="image-20221115191945696"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115192115551.png" class title="image-20221115192115551"><p>TCP的拥塞控制</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115193832654.png" class title="image-20221115193832654"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115193847376.png" class title="image-20221115193847376"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115194108601.png" class title="image-20221115194108601"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115194358700.png" class title="image-20221115194358700"><h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p>连接建立三次握手</p><p>连接关闭四次握手 </p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115203153490.png" class title="image-20221115203153490"><h1 id="考研408真题"><a href="#考研408真题" class="headerlink" title="考研408真题"></a>考研408真题</h1><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230208143418790.png" class title="image-20230208143418790">1<img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210102804066.png" class title="image-20230210102804066"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210103721830.png" class title="image-20230210103721830">  <img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210163834280.png" class title="image-20230210163834280"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210163829625.png" class title="image-20230210163829625">1<img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210170251613.png" class title="image-20230210170251613"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210172807019.png" class width="1">11<img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210205930681.png" class title="image-20230210205930681"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210210711241.png" class title="image-20230210210711241"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210212831848.png" class title="image-20230210212831848"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210213610641.png" class title="image-20230210213610641"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210213812671.png" class title="image-20230210213812671"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230211095643352.png" class title="image-20230211095643352">还有多少分配地址，这里也不要忘了-2，全0和全1<img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230212155051206.png" class title="image-20230212155051206"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230212161643526.png" class title="image-20230212161643526"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230212193753452.png" class title="image-20230212193753452"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230212194406109.png" class title="image-20230212194406109"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230212194749945.png" class title="image-20230212194749945"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213112304043.png" class title="image-20230213112304043"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213113620569.png" class title="image-20230213113620569"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213113647649.png" class title="image-20230213113647649"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213115556720.png" class title="，"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213115830202.png" class title="image-20230213115830202">9<p><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE.assets/image-20230213121838857.png" alt="image-20230213121838857"><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE.assets/image-20230213122843922.png" alt="image-20230213122843922"></p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213123439789.png" class title="image-20230213123439789"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213124559345.png" class title="image-20230213124559345"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213130629056.png" class title="image-20230213130629056"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213222411059.png" class title="image-20230213222411059"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213223719178.png" class title="image-20230213223719178"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213224051940.png" class title="image-20230213224051940"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213224631691.png" class title="image-20230213224631691"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213225254748.png" class title="image-20230213225254748"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213231523154.png" class title="image-20230213231523154"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213234107330.png" class title="image-20230213234107330"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230214104304513.png" class title="image-20230214104304513"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230214115317532.png" class title="image-20230214115317532"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230214121513262.png" class title="image-20230214121513262"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230215103056975.png" class title="image-20230215103056975"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230215103544998.png" class title="image-20230215103544998"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230215103627668.png" class title="image-20230215103627668"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230215104753879.png" class title="image-20230215104753879"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230215105137106.png" class title="image-20230215105137106"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230215114731972.png" class title="image-20230215114731972"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230215135658710.png" class title="image-20230215135658710"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230217110151618.png" class title="image-20230217110151618"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230219111752934.png" class title="image-20230219111752934"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230219111813322.png" class title="image-20230219111813322"><p>D</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230219113000565.png" class title="image-20230219113000565"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBY2tfY2hlbjAzMDk=,size_16,color_FFFFFF,t_70.jpeg" class title="在这里插入图片描述"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230219114155993.png" class title="image-20230219114155993"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/SouthEast.png" class title="img"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230219115010612.png" class title="image-20230219115010612"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230219120210097.png" class title="image-20230219120210097">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/</url>
    
    <content type="html"><![CDATA[<h1 id="计网考前一天2-17"><a href="#计网考前一天2-17" class="headerlink" title="计网考前一天2.17"></a>计网考前一天2.17</h1><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20230217170536396.png" alt="image-20230217170536396"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20230217171627539.png" alt="image-20230217171627539"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20230217171637664.png" alt="image-20230217171637664"></p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230212194406109.png" class title="image-20230212194406109"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230212194406109-16766259236602.png" class title="image-20230212194406109"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230217202153762.png" class title="image-20230217202153762"><p>2012年<img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218202159161.png" class title="image-20230218202159161"></p><p>1.看ip分组是否小于的是46而不是64</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218202151756.png" class title="image-20230218202151756"><p>看标识看出是哪个帧</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218202557336.png" class title="image-20230218202557336"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218202853230.png" class title="image-20230218202853230"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218203330057.png" class title="image-20230218203330057"><h2 id="计算问题"><a href="#计算问题" class="headerlink" title="计算问题"></a>计算问题<img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218204330934.png" class title="image-20230218204330934"></h2><p><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17.assets/image-20230218204317260.png" alt="image-20230218204317260"><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17.assets/image-20230218205332891.png" alt="image-20230218205332891"></p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218205505214.png" class title="image-20230218205505214"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218205600477.png" class title="image-20230218205600477"><p>此图中不是数据帧会挑最短路，而是因为求最少时间所以按照最短路计算</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218210810308.png" class title="image-20230218210810308"><p>有笔记</p><p><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17.assets/image-20230218210911370.png" alt="image-20230218210911370"><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17.assets/image-20230218210915026.png" alt="image-20230218210915026"></p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218211041117.png" class title="image-20230218211041117"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218211101690.png" class title="image-20230218211101690"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218211222027.png" class title="image-20230218211222027"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218211427367.png" class title="image-20230218211427367"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218212231716.png" class title="image-20230218212231716"><p>注意KB，拥塞控制阈值 名词</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218212401712.png" class title="image-20230218212401712"><p>（16,1) 拥塞窗口16KB，不影响发送窗口1KB</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218212506458.png" class title="image-20230218212506458"><p>DF是禁止分片，分片时候DF&#x3D;0</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218224418132.png" class title="image-20230218224418132"><p>Cable Modem接入是在混合光纤同轴电缆网（HFC）上实现的宽带接入技术</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218224637158.png" class title="image-20230218224637158"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218224640797.png" class title="image-20230218224640797"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218224711993.png" class title="image-20230218224711993"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218225034673.png" class title="image-20230218225034673"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230219105239488.png" class title="image-20230219105239488">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221118151242522.png" class title="image-20221118151242522"><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221103101058752.png" alt="image-20221103101058752"></p><h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221110114745464.png" class title="image-20221110114745464"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112143013568.png" class title="image-20221112143013568"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112143024422.png" class title="image-20221112143024422"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112144126212.png" class title="image-20221112144126212"><p>CPI平均指令周期数</p><p>MIPS百万级指令每秒</p><p>CPU的CPI与时钟频率无关</p><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>定点数：</p><p>1.纯整数</p><p>2.纯小数</p><p>有符号数：</p><p>原码，不适合加法运算，发现[a+-b]原  ！&#x3D;[a]原+-[b]原</p><p><strong>1,001   &#x3D;&gt; -(1)</strong></p><p>反码</p><p>没有实际意义，只是过渡阶段</p><p>补码,补码适合加减法，发现[a+-b]补 &#x3D;[a]补+-[b]补<br>实际上补码减法也是通过换成加法来的</p><p><strong>1,001 &#x3D;&gt; (-8 + 1) &#x3D; -7</strong></p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112145719565.png" class title="image-20221112145719565"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112145925998.png" class title="image-20221112145925998"><p>.</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112145820440.png" class title="image-20221112145820440"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112144946911.png" class title="image-20221112144946911"><p>因为有2^8&#x3D;256</p><p><strong>原码有正负0，补码没有正负0</strong></p><p>但是+0（0,000 0000）和-0（1,000 0000）多了</p><p>所以256-1</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112150650696.png" class title="image-20221112150650696"><p><strong>移码</strong></p><p>从补码一一对应过来的，用于方便比较数字大小</p><p>补码+2^n &#x3D; 移码</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112150857283.png" class title="image-20221112150857283"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112151626897.png" class title="image-20221112151626897"><h2 id="逻辑移位算术移位"><a href="#逻辑移位算术移位" class="headerlink" title="逻辑移位算术移位"></a>逻辑移位算术移位</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112151956097.png" class title="image-20221112151956097"><p>算数左移不应该改变符号位，符号位不动</p><h2 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h2><p>现代计算机都是用补码加减法</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112204331145.png" class title="image-20221112204331145"><p>溢出的判断：</p><p>双符号位的意义：</p><p>10</p><p>真正的符号是1，本来的符号位是0</p><p>所以是负溢出</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112210601205.png" class title="image-20221112210601205"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112210829284.png" class title="image-20221112210829284"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221117205251763.png" class title="image-20221117205251763"><h1 id="计算机讲座2"><a href="#计算机讲座2" class="headerlink" title="计算机讲座2"></a>计算机讲座2</h1><p>题目：</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221119102458280.png" class title="image-20221119102458280"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113095200788.png" class title="image-20221113095200788"><p><strong>特权指令：</strong></p><pre><code class="hljs">  1）允许和禁止中断，控制中断禁止屏蔽位  2）在进程间切换处理  3）存取用于主存保护的寄存器  4）执行I/O操作  5）停止一个中央处理器的工作  6）清理内存  7）设置时钟  8）建立存储键  9）加载PSW</code></pre><p><em><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113095339032.png" class title="image-20221113095339032"></em>*</p><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>这里采用特殊寻址方式则指令格式</p><p>操作码OP   寻址特征M   形式地址</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113104839891.png" class title="image-20221113104839891"><p>1.立即寻址</p><p>2直接寻址   间接寻址。。。。</p><p>间接寻址{</p><p>一次间接<img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113095817334.png" class title="image-20221113095817334"></p><p>多次间接<img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113095822807.png" class title="image-20221113095822807"></p><p>多次间接就需要1个标志位</p><p>}</p><p>基址寻址，BX用户不可修改</p><p>变址寻址，IX用户可修改</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113100100026.png" class title="image-20221113100100026"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113100455612.png" class title="image-20221113100455612"><p>相对寻址，是以下一条指令的PC为基准</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113100515317.png" class title="image-20221113100515317"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113101921513.png" class title="image-20221113101921513"><h2 id="指令格式设置"><a href="#指令格式设置" class="headerlink" title="指令格式设置"></a>指令格式设置</h2><p>想要端操作吗和长操作码同时存在于指令系统</p><p>则需要让短操作码不能是长操作码的前缀</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113104141360.png" class title="image-20221113104141360"><p>0000~1110是4位操作码</p><p>1111 0000 ~ 1111 1110是8位操作码</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113104439578.png" class title="image-20221113104439578"><p><strong>短操作码不断变成长操作码</strong></p><p><strong>每次增长必须是多占用一个操作数长度</strong></p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113105415872.png" class title="image-20221113105415872"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113105747167.png" class title="image-20221113105747167"><h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><p>唐书的和csapp不一样</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113105845591.png" class title="image-20221113105845591"><p>唐书说通过取指阶段从存储器取出指令</p><p>执行阶段从存储器取出数据</p><p>由于控制器的控制知道是啥阶段，所以控制器可以区分拿到指令还是数据</p><p>唐叔认为，CPU想要响应中断一定是等到上一条指令结束执行周期</p><p>且唐书认为PC++必须在取指阶段</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113110021261.png" class title="image-20221113110021261"><p><strong>指令周期</strong></p><p><strong>机器周期：比如取指周期</strong></p><p><strong>时钟周期；比如T0</strong></p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113111005703.png" class title="image-20221113111005703"><p>指令周期{</p><p> 机器周期1-取指周期：{</p><p>  时钟周期1-T0</p><p>  时钟周期2-T1</p><p>}</p><p>机器周期2-间址周期：</p><p>{</p><p>}</p><p>}</p><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113114819271.png" class title="image-20221113114819271"><h3 id="结构相关"><a href="#结构相关" class="headerlink" title="结构相关"></a>结构相关</h3><p>有两个想要同时使用访存主存（但只能同一时间允许最高一个）</p><p>暂停</p><p>指令和数据分开储存</p><h3 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h3><p>先写后读</p><p>旁路技术</p><h3 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h3><p>跳转所以会使得流水线不能按照原先预想的那样流水</p><p>所以流水线（一直按照PC+1流水的顺序）会错</p><p>暂停+分支预测</p><h3 id="流水线性能指标"><a href="#流水线性能指标" class="headerlink" title="流水线性能指标"></a>流水线性能指标</h3><p>直接做题理解</p><p>看天勤P222</p><h2 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h2><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113155658907.png" class title="image-20221113155658907"><p>天勤206</p><h1 id="理解流程"><a href="#理解流程" class="headerlink" title="理解流程"></a>理解流程</h1><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221117210937166.png" class title="image-20221117210937166"><h1 id="速成"><a href="#速成" class="headerlink" title="速成"></a>速成</h1><p>P9</p><p>1.DMA是每传送完一个数据块就中断一次作为后处理，中断过程不包括穿字节</p><p>每一份数据块就有预处理数据传输后处理</p><p>​    程序中断是每次通过一次中断来传送一字节，中断过程包括穿字节包括数据传输</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221118105218932.png" class title="image-20221118105218932"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221118105744561.png" class title="image-20221118105744561"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221118110058881.png" class title="image-20221118110058881"><p>首选位扩展</p><p>1KB&#x3D;1024B</p><h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221120172013370.png" class title="image-20221120172013370"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221120195755215.png" class title="image-20221120195755215">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017193826030.png" alt="image-20221017193826030"></p><h2 id="面向连接服务"><a href="#面向连接服务" class="headerlink" title="面向连接服务"></a>面向连接服务</h2><p>​TCP，双方必须建立连接，传输结束之后释放连接和所占的资源</p><h2 id="无连接服务"><a href="#无连接服务" class="headerlink" title="无连接服务"></a>无连接服务</h2><p>  UDP，通信双方无需建立连接</p><h2 id="数据交换的类型"><a href="#数据交换的类型" class="headerlink" title="数据交换的类型"></a>数据交换的类型</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081447025.png" alt="image-20220826081447025"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081535366.png" alt="image-20220826081535366"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081542641.png" alt="image-20220826081542641"></p><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081606479.png" alt="image-20220826081606479"></p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081617033.png" alt="image-20220826081617033"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081635487.png" alt="image-20220826081635487"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081644959.png" alt="image-20220826081644959"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081717591.png" alt="image-20220826081717591"></p><p><img src="/shizhuofan.GitHub.io/image-20220826143348409.png" alt="image-20220826143348409"></p><p>1B&#x3D;8bit</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826143414579.png" alt="image-20220826143414579"></p><h2 id="速率bit-rate"><a href="#速率bit-rate" class="headerlink" title="速率bit rate"></a>速率bit rate</h2><p>1Kbit&#x3D;1000bit</p><p>1Mbit&#x3D;1000Kbit</p><p>Kbit&#x3D;Kb</p><p>1Mb&#x2F;s&#x3D;1000Kb&#x2F;s</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081901619.png" alt="image-20220826081901619"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826082118131.png" alt="image-20220826082118131"></p><h2 id="时延："><a href="#时延：" class="headerlink" title="时延："></a>时延：</h2><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826083135963.png">数据从网络的一段出纳送到另一端所需要的总时间叫做时延，分为四部分，传输时延，传播时延，处理时延，排队时延</p><h3 id="分组延迟"><a href="#分组延迟" class="headerlink" title="分组延迟"></a>分组延迟</h3><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826082615781.png" alt="image-20220826082615781"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826083348973.png" alt="image-20220826083348973"></p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>可以看作把这条链路塞满bit，一共最多可以容纳多少bit</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826083757680.png" alt="image-20220826083757680"></p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826084127896.png" alt="image-20220826084127896"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826084323159.png" alt="image-20220826084323159"></p><h2 id="五层因特网协议"><a href="#五层因特网协议" class="headerlink" title="五层因特网协议"></a>五层因特网协议</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>​运输层给应用程序不同端口（进程）之间传输应用层报文</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><h1 id="第二章应用层"><a href="#第二章应用层" class="headerlink" title="第二章应用层"></a>第二章应用层</h1><h2 id="网络应用程序体系结构："><a href="#网络应用程序体系结构：" class="headerlink" title="网络应用程序体系结构："></a>网络应用程序体系结构：</h2><h3 id="CS客户服务器体系结构"><a href="#CS客户服务器体系结构" class="headerlink" title="CS客户服务器体系结构"></a>CS客户服务器体系结构</h3><p>Web浏览器网站</p><h3 id="P2P体系结构"><a href="#P2P体系结构" class="headerlink" title="P2P体系结构"></a>P2P体系结构</h3><p>文件共享，文件传输，网络电话</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826150509882.png" alt="image-20220826150509882"></p><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>不同系统之间互相通信的是进程（运行中的程序）</p><p>​通过交换报文而互相通信</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829164144803.png" alt="image-20220829164144803"></p><h3 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h3><p>​通过IP地址找到对应主机</p><p>​通过端口找到对应进程对应目的</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829165014641.png" alt="image-20220829165014641"></p><h2 id="因特网的运输层协议（TCP和UDP）"><a href="#因特网的运输层协议（TCP和UDP）" class="headerlink" title="因特网的运输层协议（TCP和UDP）"></a>因特网的运输层协议（TCP和UDP）</h2><p>发送端的应用程序通过套接字socket发送报文，然后通过运输层协议（tcp&#x2F;tdp)使得报文进入到接收进程的套接字</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829165627560.png" alt="image-20220829165627560"></p><h3 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h3><h2 id="Web应用层协议：HTTP（超文本传输协议）"><a href="#Web应用层协议：HTTP（超文本传输协议）" class="headerlink" title="Web应用层协议：HTTP（超文本传输协议）"></a>Web应用层协议：HTTP（超文本传输协议）</h2><p>HTTP是一个无状态协议，并不会保存客户信息</p><p>HTTP会建立TCP链接：客户进程-TCP-服务器进程</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829193401814.png" alt="image-20220829193401814"></p><h3 id="HTTP的非持续连接和持续连接"><a href="#HTTP的非持续连接和持续连接" class="headerlink" title="HTTP的非持续连接和持续连接"></a>HTTP的非持续连接和持续连接</h3><h4 id="非持久性"><a href="#非持久性" class="headerlink" title="非持久性"></a>非持久性</h4><p>往返时间RTT</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829193910675.png" alt="image-20220829193910675"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829193621621.png" alt="image-20220829193621621"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829193710523.png" alt="image-20220829193710523"></p><h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829143954709.png" alt="image-20220829143954709"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829144057512.png" alt="image-20220829144057512"></p><h2 id="上传输入的方法：Get，Post"><a href="#上传输入的方法：Get，Post" class="headerlink" title="上传输入的方法：Get，Post"></a>上传输入的方法：Get，Post</h2><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829145719797.png" alt="image-20220829145719797"></p><p>GET利用的request的URL，请求体为空</p><p>POST利用请求体</p><h2 id="响应消息："><a href="#响应消息：" class="headerlink" title="响应消息："></a>响应消息：</h2><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829150006488.png" alt="image-20220829150006488"></p><h2 id="cookie技术"><a href="#cookie技术" class="headerlink" title="cookie技术"></a>cookie技术</h2><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829150630853.png" alt="image-20220829150630853"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829150657308.png" alt="image-20220829150657308"></p><p>session 是基于 cookie 实现的，session 存储在服务器端，sessionID 会被存储到客户端的 cookie 中</p><p>服务端执行session机制时候会生成 sessionID 值，这个ID值会发送给客户端，客户端每次请求都会把这个ID值放到HTTP请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用。</p><h3 id="Cookie和Session认证流程"><a href="#Cookie和Session认证流程" class="headerlink" title="Cookie和Session认证流程"></a>Cookie和Session认证流程</h3><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829151458917.png" alt="image-20220829151458917"></p><h3 id="Cookie和Session区别"><a href="#Cookie和Session区别" class="headerlink" title="Cookie和Session区别"></a>Cookie和Session区别</h3><p>Cookie（内含SessionID）存在客户端，Session存在服务器端</p><p>Cookie长时间保存，Session短时间保存</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829151533358.png" alt="image-20220829151533358"></p><h2 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">可以不需要访问服务器就可以满足HTTP请求拿到东西看见网页内容<br></code></pre></td></tr></table></figure><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829151724321.png" alt="image-20220829151724321"></p><h3 id="机制："><a href="#机制：" class="headerlink" title="机制："></a>机制：</h3><p>web缓存器也叫代理服务器技术</p><p>请求先查看代理服务器（缓存）中是否有需要的</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829152100903.png" alt="image-20220829152100903"></p><h3 id="通过条件性GET方法"><a href="#通过条件性GET方法" class="headerlink" title="通过条件性GET方法"></a>通过条件性GET方法</h3><p>来，使用缓存或者服务器之中的最新版本</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829162853400.png" alt="image-20220829162853400"></p><h2 id="Email应用"><a href="#Email应用" class="headerlink" title="Email应用"></a>Email应用</h2><h3 id="Email的应用构成"><a href="#Email的应用构成" class="headerlink" title="Email的应用构成"></a>Email的应用构成</h3><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829163437569.png" alt="image-20220829163437569"></p><p>HTTP：请求，响应</p><p>SMTP：命令，响应</p><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829194150337.png" alt="image-20220829194150337"></p><h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h3><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829200901508.png" alt="image-20220829200901508"></p><h3 id="邮件访问协议："><a href="#邮件访问协议：" class="headerlink" title="邮件访问协议："></a>邮件访问协议：</h3><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830143957515.png" alt="image-20220830143957515"></p><h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><h4 id="IMAP3"><a href="#IMAP3" class="headerlink" title="IMAP3"></a>IMAP3</h4><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>识别主机需要主机名（cnn.com)或者IP地址</p><h3 id="DNS域名解析系统，"><a href="#DNS域名解析系统，" class="headerlink" title="DNS域名解析系统，"></a>DNS域名解析系统，</h3><p>1.可以用已知（好记又方便）主机名得到IP地址</p><p>2.主机别名</p><p>3.邮件服务器别名</p><p>4.负载均衡</p><h3 id="DNS服务器采用分布式"><a href="#DNS服务器采用分布式" class="headerlink" title="DNS服务器采用分布式"></a>DNS服务器采用分布式</h3><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830150841742.png" alt="image-20220830150841742"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830145423384.png" alt="image-20220830145423384"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830145920183.png" alt="image-20220830145920183"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830151052936.png" alt="image-20220830151052936"></p><h3 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h3><h4 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h4><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830151817618.png" alt="image-20220830151817618"></p><h4 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询<img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830151830814.png" alt="image-20220830151830814"></h4><h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830152021284.png" alt="image-20220830152021284"></p><h1 id="第三章，应用层-下"><a href="#第三章，应用层-下" class="headerlink" title="第三章，应用层-下"></a>第三章，应用层-下</h1><h2 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h2><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904134251513.png" alt="image-20220904134251513"></p><h3 id="P2P应用1-文件分发："><a href="#P2P应用1-文件分发：" class="headerlink" title="P2P应用1-文件分发："></a>P2P应用1-文件分发：</h3><h4 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS<img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904134345111.png" alt="image-20220904134345111"></h4><p>最短完成时间，是等到同步开始的上传和下载都得完成</p><h4 id="P2P-1"><a href="#P2P-1" class="headerlink" title="P2P"></a>P2P</h4><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904134936557.png" alt="image-20220904134936557"></p><h4 id="对比图"><a href="#对比图" class="headerlink" title="对比图"></a>对比图</h4><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904134924526.png" alt="image-20220904134924526"></p><h3 id="文件分发具体例子："><a href="#文件分发具体例子：" class="headerlink" title="文件分发具体例子："></a>文件分发具体例子：</h3><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904135244821.png" alt="image-20220904135244821"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904135259784.png" alt="image-20220904135259784"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904135340832.png" alt="image-20220904135340832"></p><p>一边下载一边上传发送给别人</p><h3 id="P2P应用2-索引"><a href="#P2P应用2-索引" class="headerlink" title="P2P应用2-索引"></a>P2P应用2-索引</h3><h4 id="索引的作用"><a href="#索引的作用" class="headerlink" title="索引的作用"></a>索引的作用</h4><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904135806678.png" alt="image-20220904135806678"></p><p>集中式索引</p><p>洪泛式查询</p><p>层次式覆盖网络</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904135939292.png" alt="image-20220904135939292"></p><h2 id="套接字socket编程"><a href="#套接字socket编程" class="headerlink" title="套接字socket编程"></a>套接字socket编程</h2><ul><li>socket：应用层、传输层之间的。**&#x3D;&#x3D;属于传输层&#x3D;&#x3D;**</li><li>通信段点对外：IP+端口号</li><li>内对：套接字描述符</li></ul><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904140248033.png" alt="image-20220904140248033"></p><h3 id="套接字描述符："><a href="#套接字描述符：" class="headerlink" title="套接字描述符："></a>套接字描述符：</h3><p>创建套接字时候返回套接字描述符</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904140912573.png" alt="image-20220904140912573"></p><h3 id="SOcket-API"><a href="#SOcket-API" class="headerlink" title="SOcket API"></a>SOcket API</h3><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904110205377.png" alt="image-20220904110205377"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904111702789.png" alt="image-20220904111702789"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904111714801.png" alt="image-20220904111714801"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904111758165.png" alt="image-20220904111758165"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904111839346.png" alt="image-20220904111839346"></p><p>生成新套接字</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904112045577.png" alt="image-20220904112045577"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904112225360.png" alt="image-20220904112225360"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904112547914.png" alt="image-20220904112547914"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904112552719.png" alt="image-20220904112552719"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904112607715.png" alt="image-20220904112607715"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904113310213.png" alt="image-20220904113310213"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904113331169.png" alt="image-20220904113331169"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904113357749.png" alt="image-20220904113357749"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904113545996.png" alt="image-20220904113545996"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904113849517.png" alt="image-20220904113849517"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904113931816.png" alt="image-20220904113931816"></p><p>4种</p><h1 id="第四章，传输层"><a href="#第四章，传输层" class="headerlink" title="第四章，传输层"></a>第四章，传输层</h1><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220912203606030.png" alt="image-20220912203606030"></p><h1 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h1><p>DF&#x3D;0允许分组</p><p>MF&#x3D;0代表这是最后一个分组</p><p>127.0.0.1本机地址（我自己知道我的IP是135.2xxxxxxxxx这个是代称</p><p>0.0.0.0代表本机地址，（我不知道我的IP地址，还没被分配，）</p><p>DHCP服务器是给用户分配【IP地址、子网掩码、默认网关地址、DNS服务器名称与IP地址】 </p><p>片偏移地址（offset&#x3D;1，代表8B，以8B为一个单位）</p><p>最大分片数据必须8的整数倍向下取整</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017151738350.png" alt="image-20221017151738350"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017152317844.png" alt="image-20221017152317844"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017153653809.png" alt="image-20221017153653809"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017160750946.png" alt="image-20221017160750946"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c3d98fa93f7a9d7371185e578de0dcb5.png" alt="OSI模型通信过程1"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017165740786.png" alt="image-20221017165740786"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221018185619436.png" alt="image-20221018185619436"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221018185638412.png" alt="image-20221018185638412"></p><p>1.主机有域名DNS缓存</p><p>2.本地域名服务器也有DNS缓存</p><p>3.权限下面还可以有多个权限域名服务器！！！！！！！！！！！</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221018185831617.png" alt=""></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221018185930281.png" alt="image-20221018185930281"></p><p>权限下面还可以有多个权限域名服务器！！！！！！！！！！！</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221018201016403.png" alt="image-20221018201016403"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="/shizhuofan.GitHub.io/2023/03/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220822172411688.png" alt="image-20220822172411688"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220825082822588.png" alt="image-20220825082822588"></p><p>sklearn.datasets是数据集</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220825084948541.png" alt="image-20220825084948541"></p><h1 id="遇见笔记："><a href="#遇见笔记：" class="headerlink" title="遇见笔记："></a>遇见笔记：</h1><p>1.window路径可以用\也可以用&#x2F;，在代码文件中写的路径使用”\\“是为了防止”\n”区别转义字符，代码文件路径也可以直接用”&#x2F;“</p><p>说是，在不同系统的情况系 windows下是,linux和unix下是&#x2F; 但在win中没有本质区别。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="个人改动"><a href="#个人改动" class="headerlink" title="个人改动"></a>个人改动</h1><p>完成了nginx动静分离，但是没有做FarsMall的域名.<br>我的流程:localhost:8888-&gt;nginx-&gt;nginx设置Header为FarsMall-&gt;nginx转给GateWay localhost:88 -&gt;GateWay只对Head为FarsMall的进行路由静态资源</p><h1 id="谷粒商城个人笔记"><a href="#谷粒商城个人笔记" class="headerlink" title="谷粒商城个人笔记"></a>谷粒商城个人笔记</h1><p><packaging>pom</packaging>      用在父级工程或聚合工程中。用来做jar包的版本控制。</p><p><packaging>jar</packaging>      将会打包成jar用作jar包使用，packaging默认类型。</p><p><packaging>war</packaging>      将会打包成war，发布在服务器上的工程。如网站或服务。</p><p>maven的父类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xuecheng-plus-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../xuecheng-plus-parent<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xuecheng-plus-base<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br></code></pre></td></tr></table></figure><p>跨域问题，服务器对浏览器发起的OPTION询问返回的响应标头，如果有两个filter就会加两遍Access-Control标头内容，也会出错</p><h2 id="docker容器内部使用vim"><a href="#docker容器内部使用vim" class="headerlink" title="docker容器内部使用vim"></a>docker容器内部使用vim</h2><p>1.[linux文件创建命令是什么-linux运维-PHP中文网](<a href="https://www.php.cn/linux-490062.html#:~:text=%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4%E6%98%AF%EF%BC%9A1%E3%80%81%E2%80%9Cvi">https://www.php.cn/linux-490062.html#:~:text=文件创建命令是：1、“vi</a> 文件名”命令，该命令输入保存之后文件才被创建；2、“touch 文件名”命令，该命令用于更改文件或目录的时间，若文件不存在会自动创建；3、“echo,文件内容 &gt; 文件名”命令，该命令会将指定内容写入文件中。)</p><p>用echo命令新建&#x2F;etc&#x2F;apt&#x2F;sources.list，并赋值</p><p>(非必须，一般sources.list都默认有源仓库地址)</p><p>2.apt update</p><p>3.apt install vim</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vim">rm /etc/apt/sources.<span class="hljs-keyword">list</span><br><span class="hljs-keyword">cat</span> sources.<span class="hljs-keyword">list</span><br><span class="hljs-keyword">echo</span> <span class="hljs-comment">&quot;</span><br><span class="hljs-keyword">deb</span> http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal main restricted universe multiverse<br><span class="hljs-keyword">deb</span> http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-security main restricted universe multiverse<br><span class="hljs-keyword">deb</span> http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-updates main restricted universe multiverse<br><span class="hljs-keyword">deb</span> http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-backports main restricted universe multiverse<br>##測試版源<br><span class="hljs-keyword">deb</span> http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-proposed main restricted universe multiverse<br># 源碼<br><span class="hljs-keyword">deb</span>-src http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal main restricted universe multiverse<br><span class="hljs-keyword">deb</span>-src http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-security main restricted universe multiverse<br><span class="hljs-keyword">deb</span>-src http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-updates main restricted universe multiverse<br><span class="hljs-keyword">deb</span>-src http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-backports main restricted universe multiverse<br>##測試版源<br><span class="hljs-keyword">deb</span>-src http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-proposed main restricted universe multiverse<br><span class="hljs-comment">&quot; &gt; sources.list</span><br>apt install <span class="hljs-keyword">vim</span><br>apt <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><h2 id="wsl打开wsl硬盘"><a href="#wsl打开wsl硬盘" class="headerlink" title="wsl打开wsl硬盘"></a>wsl打开wsl硬盘</h2><p>法1.资源管理器中输入\\wsl$</p><p>法2.</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/image-20230224170030681.png" class title="image-20230224170030681"><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/image-20230224170038323.png" class title="image-20230224170038323"><h2 id="打开jvisualvm"><a href="#打开jvisualvm" class="headerlink" title="打开jvisualvm"></a>打开jvisualvm</h2><p>cmd输入jvisualvm</p><h2 id="WSL和win互通"><a href="#WSL和win互通" class="headerlink" title="WSL和win互通"></a>WSL和win互通</h2><p>1、在WSL子系统中，使用下面的命令。获取WSL的ip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip addr | grep eth0<br></code></pre></td></tr></table></figure><p>wsl 172.29.64.13</p><p>在win查看自己win的ip可以供win和wsl访问</p><p>ipconfig</p><p>172.20.175.49</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/image-20230301131343209.png" class title="image-20230301131343209"><p>主要是防火墙</p><h2 id="powshell和cmd不一样"><a href="#powshell和cmd不一样" class="headerlink" title="powshell和cmd不一样"></a>powshell和cmd不一样</h2><h2 id="sql索引会加快速度"><a href="#sql索引会加快速度" class="headerlink" title="sql索引会加快速度"></a>sql索引会加快速度</h2><h2 id="nginx的配置"><a href="#nginx的配置" class="headerlink" title="nginx的配置"></a>nginx的配置</h2><p><strong>用的是wsl的虚拟机，就是每次都是动态ip需要自己去修改才能启动</strong></p><p>启动命令是</p><p>前面是ubuntu，后面是nginx容器</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> --name nginx <br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/conf/</span>nginx.conf:<span class="hljs-regexp">/etc/</span>nginx/nginx.conf <br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/conf/</span>conf.d:<span class="hljs-regexp">/etc/</span>nginx/conf.d <br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/log:/</span>var<span class="hljs-regexp">/log/</span>nginx <br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/html:/u</span>sr<span class="hljs-regexp">/share/</span>nginx/html <br>-d nginx:latest<br></code></pre></td></tr></table></figure><p>在容器中是&#x2F;etc&#x2F;nginx</p><p>在宿主Ubuntu中是</p><p>&#x2F;home&#x2F;nginx&#x2F;</p><p>&#x2F;home&#x2F;nginx&#x2F;html&#x2F;</p><h2 id="HOST域名配置问题"><a href="#HOST域名配置问题" class="headerlink" title="HOST域名配置问题"></a>HOST域名配置问题</h2><p>本机.HOSTS中 FarsMall和farsmall同属于一个</p><p>同时输入网站<a href="http://www.baidu.com和www.baidu.com都同属于一个,转为www.baidu.com/">www.BAIDU.com和www.baidu.com都同属于一个，转为www.baidu.com</a></p><p>gateway验证时候的HOST的FarsMall和farsmall又不同属于一个,应该写farsmall</p><p>1.不要重复配置farsmall.com和FarsMall.com冲突</p><p>2.chrome:&#x2F;&#x2F;net-internals&#x2F;?#dns   更新HOST之后要清理以前的DNS缓存</p><h2 id="githug远程仓库add之后出现嵌套仓库"><a href="#githug远程仓库add之后出现嵌套仓库" class="headerlink" title="githug远程仓库add之后出现嵌套仓库"></a>githug远程仓库add之后出现嵌套仓库</h2><p>.git是隐藏文件，只有在资源管理器才可以见到</p><p>idea看不见.git文件夹</p><img src="/shizhuofan.GitHub.io/2023/03/29/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/image-20230301190614534.png" class title="image-20230301190614534"><p>如果你添加了一个已经是git仓库的文件夹，那么git会认为它是一个submodule，并且只会记录它的路径和版本号，而不会跟踪它的内容 。这样做的目的是为了保持子模块和父项目之间的独立性和灵活性。所以这个警告只是提醒你如果你想添加一个子模块，应该使用<code>git submodule add</code>命令，并且如果你想删除一个子模块，应该使用<code>git rm --cached</code>命令 。</p><ul><li><a href="https://www.jianshu.com/p/30d2ff4ebc6a">一种是删除本地新建module中的.git文件夹，这样git就不会把它当作一个独立的仓库了</a><a href="https://www.jianshu.com/p/30d2ff4ebc6a">2</a>。然后再重新执行add、commit和push命令。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="谷粒商城"><a href="#谷粒商城" class="headerlink" title="谷粒商城"></a>谷粒商城</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>Es6</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">       <span class="hljs-regexp">//</span> var 声明的变量往往会越域<br>       <span class="hljs-regexp">//</span> let 声明的变量有严格局部作用域<br><span class="hljs-regexp">//</span>         &#123;<br><span class="hljs-regexp">//</span>             var a = <span class="hljs-number">1</span>;<br><span class="hljs-regexp">//</span>             let b = <span class="hljs-number">2</span>;<br><span class="hljs-regexp">//</span>         &#125;<br><span class="hljs-regexp">//</span>         console.log(a);  <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br><span class="hljs-regexp">//</span>         console.log(b);  <span class="hljs-regexp">//</span> ReferenceError: b is not defined<br><br>    <span class="hljs-regexp">//</span> var 可以声明多次<br>            <span class="hljs-regexp">//</span> let 只能声明一次<br><span class="hljs-regexp">//</span>         var m = <span class="hljs-number">1</span><br><span class="hljs-regexp">//</span>         var m = <span class="hljs-number">2</span><br><span class="hljs-regexp">//</span>         let n = <span class="hljs-number">3</span><br><span class="hljs-regexp">//</span> <span class="hljs-regexp">//</span>         let n = <span class="hljs-number">4</span><br><span class="hljs-regexp">//</span>         console.log(m)  <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br><span class="hljs-regexp">//</span>         console.log(n)  <span class="hljs-regexp">//</span> Identifier <span class="hljs-string">&#x27;n&#x27;</span> has already been declared<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E6%9C%8D%E5%8A%A1%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E6%9C%8D%E5%8A%A1%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="服务科学与工程"><a href="#服务科学与工程" class="headerlink" title="服务科学与工程"></a>服务科学与工程</h1><p><img src="/shizhuofan.GitHub.io/2023/03/29/%E6%9C%8D%E5%8A%A1%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20230228100454088.png" alt="image-20230228100454088"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="保研复习"><a href="#保研复习" class="headerlink" title="保研复习"></a>保研复习</h1><p>概率论、高数、线代、数据结构、操作系统、计算机网络、软件工程、计算机组成原理等</p><p>408</p><p>科研经历&gt;&#x3D;项目经历&gt;&gt;专业课复习</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/SpringCloud/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/SpringCloud/</url>
    
    <content type="html"><![CDATA[<h1 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h1><p>在yml中某个具体属性值前面要空格！！！</p><p> application:</p><p>  name:  <strong>（这里要空格）</strong>orderservice</p><p>小心这个配置</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/SpringCloud/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220831203412409.png" alt="image-20220831203412409"></p><p>这个Data Id需要带后缀.yaml</p><p><strong>是.yaml不是.yml</strong></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/SpringCloud/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220831211715567.png" alt="image-20220831211715567"></p><h1 id="同源与跨域"><a href="#同源与跨域" class="headerlink" title="同源与跨域"></a>同源与跨域</h1><p><img src="/shizhuofan.GitHub.io/2023/03/29/SpringCloud/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220901102506106.png" alt="image-20220901102506106"></p><h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><h2 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h2><h1 id="注册中心Eureka"><a href="#注册中心Eureka" class="headerlink" title="注册中心Eureka"></a>注册中心Eureka</h1><p><img src="/shizhuofan.GitHub.io/2023/03/29/SpringCloud/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829214241081.png" alt="image-20220829214241081"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/SpringCloud/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829214326675.png" alt="image-20220829214326675"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/SpringCloud/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829214403631.png" alt="image-20220829214403631"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>合理分配任务，保证所有后端服务器都将性能充分发挥，从而保持服务器集群的整体性能最优，这就是负载均衡问题</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p><img src="/shizhuofan.GitHub.io/2023/03/29/SpringCloud/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829215026960.png" alt="image-20220829215026960"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/SpringCloud/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830110854507.png" alt="image-20220830110854507"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/RabbitMq/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/RabbitMq/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMq"><a href="#RabbitMq" class="headerlink" title="RabbitMq"></a>RabbitMq</h1><ol><li></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --hostname my-rabbit --name my-rabbit -e RABBITMQ_DEFAULT_USER=root -e RABBITMQ_DEFAULT_PASS=<span class="hljs-number">250772730</span> -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> -p <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span> -p <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span> rabbitmq:<span class="hljs-number">3</span>-management<br></code></pre></td></tr></table></figure><p>docker里面的-p暴露端口是确确实实写了才会映射到主机</p><ol start="2"><li></li></ol><p>15672才是RabbitMq的控制台</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">package</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.macs</span><span class="hljs-selector-class">.order</span><span class="hljs-selector-class">.message</span>;<br><br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">lombok</span><span class="hljs-selector-class">.extern</span><span class="hljs-selector-class">.slf4j</span><span class="hljs-selector-class">.Slf4j</span>;<br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.amqp</span><span class="hljs-selector-class">.rabbit</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Exchange</span>;<br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.amqp</span><span class="hljs-selector-class">.rabbit</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Queue</span>;<br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.amqp</span><span class="hljs-selector-class">.rabbit</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.QueueBinding</span>;<br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.amqp</span><span class="hljs-selector-class">.rabbit</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.RabbitListener</span>;<br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.stereotype</span><span class="hljs-selector-class">.Component</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收mq消息</span><br><span class="hljs-comment"> * @author antma</span><br><span class="hljs-comment"> */</span><br>@<span class="hljs-selector-tag">Slf4j</span><br>@<span class="hljs-selector-tag">Component</span><br><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">MqReceiver</span> &#123;<br><br>    <span class="hljs-comment">//1. 手动创建，需在RabbitMQ中手动创建myQueue1 队列，否则报错</span><br>    <span class="hljs-variable">@RabbitListener</span>(queues = <span class="hljs-string">&quot;myQueue1&quot;</span>)<br>    public void <span class="hljs-built_in">process1</span>(String message)&#123;<br>        <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>(<span class="hljs-string">&quot;MqReceiver1: &#123;&#125;&quot;</span>, message);<br>    &#125;<br><br>    <span class="hljs-comment">//2. 自动创建队列</span><br>    @<span class="hljs-selector-tag">RabbitListener</span>(queuesToDeclare = <span class="hljs-variable">@Queue</span>(<span class="hljs-string">&quot;myQueue2&quot;</span>))<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">process2</span>(String message)&#123;<br>        <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>(<span class="hljs-string">&quot;MqReceiver2: &#123;&#125;&quot;</span>, message);<br><br>    &#125;<br><br>    <span class="hljs-comment">//3. 自动创建队列，Exchange 与 Queue绑定</span><br>    @<span class="hljs-selector-tag">RabbitListener</span>(bindings = <span class="hljs-variable">@QueueBinding</span>(<br>            value = <span class="hljs-variable">@Queue</span>(<span class="hljs-string">&quot;myQueue3&quot;</span>),<br>            exchange = <span class="hljs-variable">@Exchange</span>(<span class="hljs-string">&quot;testExChange&quot;</span>)<br>    ))<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">process3</span>(String message)&#123;<br>        <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.info</span>(<span class="hljs-string">&quot;MqReceiver3: &#123;&#125;&quot;</span>, message);<br>    &#125;<br><br><br><span class="hljs-comment">//    @RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-comment">//            exchange = @Exchange(&quot;myOrder&quot;),</span><br><span class="hljs-comment">//            key = &quot;computer&quot;,</span><br><span class="hljs-comment">//            value = @Queue(&quot;computerOrder&quot;)</span><br><span class="hljs-comment">//    ))</span><br><span class="hljs-comment">//    public void processComputer(String message)&#123;</span><br><span class="hljs-comment">//        log.info(&quot;computer MqReceiver: &#123;&#125;&quot;, message);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    @RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-comment">//            exchange = @Exchange(&quot;myOrder&quot;),</span><br><span class="hljs-comment">//            key = &quot;fruit&quot;,</span><br><span class="hljs-comment">//            value = @Queue(&quot;fruitOrder&quot;)</span><br><span class="hljs-comment">//    ))</span><br><span class="hljs-comment">//    public void processFruit(String message)&#123;</span><br><span class="hljs-comment">//        log.info(&quot;fruit MqReceiver: &#123;&#125;&quot;, message);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    &#125;</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/Online_Microservice_Orchestration_for_IoT_via_Multiobjective_Deep_Reinforcemen/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/Online_Microservice_Orchestration_for_IoT_via_Multiobjective_Deep_Reinforcemen/</url>
    
    <content type="html"><![CDATA[<h1 id="Online-Microservice-Orchestration-for-IoT-via-Multiobjective-Deep-Reinforcemen"><a href="#Online-Microservice-Orchestration-for-IoT-via-Multiobjective-Deep-Reinforcemen" class="headerlink" title="Online_Microservice_Orchestration_for_IoT_via_Multiobjective_Deep_Reinforcemen"></a>Online_Microservice_Orchestration_for_IoT_via_Multiobjective_Deep_Reinforcemen</h1><p>reward被定义为一个向量</p><p>这个向量包括两个部分：native rewards和artificial shaping rewards。Native rewards是环境提供的原始奖励信号，而artificial shaping rewards是人工设计的奖励信号，</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/Online_Microservice_Orchestration_for_IoT_via_Multiobjective_Deep_Reinforcemen/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20230307212854008.png" alt="image-20230307212854008"></p><p><img src="/shizhuofan.GitHub.io/2023/03/29/Online_Microservice_Orchestration_for_IoT_via_Multiobjective_Deep_Reinforcemen/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20230307213159310.png" alt="image-20230307213159310"></p><p>其中</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/Online_Microservice_Orchestration_for_IoT_via_Multiobjective_Deep_Reinforcemen/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20230307213210727.png" alt="image-20230307213210727"></p><p>涉及线程，没有现成的函数供我计算，</p><img src="/shizhuofan.GitHub.io/2023/03/29/Online_Microservice_Orchestration_for_IoT_via_Multiobjective_Deep_Reinforcemen/image-20230308192516078.png" class title="image-20230308192516078">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/nginx/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/nginx/</url>
    
    <content type="html"><![CDATA[<p>关闭win的nginx</p><p>taskkill &#x2F;f &#x2F;t &#x2F;im nginx.exe</p><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="1-nginx部署vue"><a href="#1-nginx部署vue" class="headerlink" title="1.nginx部署vue"></a>1.nginx部署vue</h1><p>首先npm run build打包</p><p>然后把生成的dist放入nginx&#x2F;html中</p><p>然后就可以</p><p>可以修改配置nginx&#x2F;conf</p><p>2.k8s部署nginx</p><p>打算利用HostPath</p><img src="/shizhuofan.GitHub.io/2023/03/29/nginx/image-20221214212912748.png" class title="image-20221214212912748">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/Linux%E5%91%BD%E4%BB%A4/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/Linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><p>env直接看环境变量配置</p><p>有JAVA_HOME</p><p><img src="/shizhuofan.GitHub.io/2023/03/29/Linux%E5%91%BD%E4%BB%A4/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221207212822629.png" alt="image-20221207212822629"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/LeetCode/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/LeetCode/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h2><pre><code class="hljs">  访问修饰符public,private,protected    类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。</code></pre><p>总结如下表</p><img src="/shizhuofan.GitHub.io/2023/03/29/LeetCode/Center.png" class title="img"><p>版权声明：本文为CSDN博主「所谓简爱」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_33342248/article/details/54090038">https://blog.csdn.net/qq_33342248/article/details/54090038</a></p><h2 id="1-二分查找法"><a href="#1-二分查找法" class="headerlink" title="1.二分查找法"></a>1.二分查找法</h2><p>思路一：</p><p><strong>while(left&lt;&#x3D;right)</strong></p><p><strong>直接找出目标元素</strong></p><p>public class Solution {</p><pre><code class="hljs">// 「力扣」第 704 题：二分查找  public int search(int[] nums, int target) &#123;    int len = nums.length;    int left = 0;    int right = len - 1;    // 目标元素可能存在在区间 [left, right]    while (left &lt;= right) &#123;        // 推荐的写法是 int mid = left + (right - left) / 2;        int mid = (left + right) / 2;        if (nums[mid] == target) &#123;            return mid;        &#125; else if (nums[mid] &lt; target) &#123;            // 目标元素可能存在在区间 [mid + 1, right]            left = mid + 1;        &#125; else &#123;            // 目标元素可能存在在区间 [left, mid - 1]            right = mid - 1;        &#125;    &#125;    return -1;&#125;</code></pre><p>}</p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/xsz9zc/">https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/xsz9zc/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><strong>2.排除不可能区间</strong></p><p>思路二时候</p><p><strong>1.while(left&lt;right)</strong></p><p><strong>2.如果有left&#x3D;mid,则向上取整mid &#x3D; (left+right+1) &#x2F;2</strong></p><p>public class Solution {</p><pre><code class="hljs">// 「力扣」第 704 题：二分查找public int search(int[] nums, int target) &#123;    int len = nums.length;    int left = 0;    int right = len - 1;    // 目标元素可能存在在区间 [left, right]    while (left &lt; right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) &#123;            // 下一轮搜索区间是 [mid + 1, right]            left = mid + 1;        &#125; else &#123;            // 下一轮搜索区间是 [left, mid]            right = mid;        &#125;    &#125;    if (nums[left] == target) &#123;        return left;    &#125;    return -1;&#125;</code></pre><p>}</p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/xs41qg/">https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/xs41qg/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="2-HashMap"><a href="#2-HashMap" class="headerlink" title="2.HashMap"></a>2.HashMap</h2><p>时间复杂度o（1）</p><p>因为是数组</p><h2 id="3-排序·"><a href="#3-排序·" class="headerlink" title="3.排序·"></a>3.排序·</h2><h3 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1.选择排序"></a>1.选择排序</h3><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h3><p>public class Solution {</p><pre><code class="hljs">// 「力扣」第 912 题：排序数组public int[] sortArray(int[] nums) &#123;    int len = nums.length;    // 循环不变量：将 nums[i] 插入到区间 [0, i) 使之成为有序数组    for (int i = 1; i &lt; len; i++) &#123;        for (int j = i; j &gt; 0; j--) &#123;            if (nums[j - 1] &gt; nums[j]) &#123;                swap(nums, j - 1, j);            &#125; else &#123;                break;            &#125;        &#125;    &#125;    return nums;&#125;private void swap(int[] nums, int index1, int index2) &#123;    int temp = nums[index1];    nums[index1] = nums[index2];    nums[index2] = temp;&#125;</code></pre><p>}</p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/556rgm/">https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/556rgm/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3.希尔排序"></a>3.希尔排序</h3><p>升级版的插入排序</p><p>import java.util.Arrays;</p><p>public class Solution {</p><pre><code class="hljs">// 「力扣」第 912 题：排序数组// 希尔排序，使用 Shell 建议的序列 N/2,N/4,...,2,1public int[] sortArray(int[] nums) &#123;    int len = nums.length;    int h = 1;    int gap = len / 2;    while (gap &gt;= 1) &#123;        // 缩小增量的插入排序        for (int i = h; i &lt; len; i++) &#123;            insertionForDelta(nums, gap, i);        &#125;        gap /= 2;    &#125;    return nums;&#125;/** * 将 nums[end] 插入到对应分组的正确位置上，其实就是将原来 1 的部分改成 gap * * @param nums * @param gap  间隔 * @param end */private void insertionForDelta(int[] nums, int gap, int end) &#123;    int temp = nums[end];    int j = end;    while (j &gt;= gap &amp;&amp; nums[j - gap] &gt; temp) &#123;        nums[j] = nums[j - gap];        j -= gap;    &#125;    nums[j] = temp;&#125;</code></pre><p>}</p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55k961/">https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55k961/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="4-归并"><a href="#4-归并" class="headerlink" title="4.归并"></a>4.归并</h3><p>编写递归函数，通常要遵守下面的编写模式：</p><p><strong>先写递归终止条件；</strong><br><strong>再假定小规模的问题已经解决（是通过递归解决的）；</strong><br><strong>最后处理小规模问题已经解决的情况下，与当前问题之间的逻辑联系。</strong></p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55ghq7/">https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55ghq7/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> sort<span class="hljs-constructor">Array(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> len = nums.length;<br>        merge<span class="hljs-constructor">Sort(<span class="hljs-params">nums</span>, 0, <span class="hljs-params">len</span> - 1)</span>;<br>        return nums;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> void merge<span class="hljs-constructor">Sort(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(left<span class="hljs-operator"> == </span>right) &#123;<br>            return;<br>        &#125;<br>        <span class="hljs-built_in">int</span> mid = left + (right - left)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>        merge<span class="hljs-constructor">Sort(<span class="hljs-params">nums</span>, <span class="hljs-params">left</span>, <span class="hljs-params">mid</span>)</span>;<br>        merge<span class="hljs-constructor">Sort(<span class="hljs-params">nums</span>, <span class="hljs-params">mid</span> + 1, <span class="hljs-params">right</span>)</span>;<br>        merge<span class="hljs-constructor">OfTwoSortedArray(<span class="hljs-params">nums</span>, <span class="hljs-params">left</span>, <span class="hljs-params">mid</span>, <span class="hljs-params">right</span>)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> void merge<span class="hljs-constructor">OfTwoSortedArray(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">mid</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span>)</span> &#123;<br>        <span class="hljs-comment">// 合并后数组长度</span><br>        <span class="hljs-built_in">int</span> len = right - left + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 定义新的临时数组</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">len</span>]</span>;<br><br>        <span class="hljs-built_in">int</span> i = left;<br>        <span class="hljs-built_in">int</span> j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 从左到右比较两数组的大小，将较小的值添加到temp中</span><br>        <span class="hljs-keyword">while</span>(i &lt;= mid<span class="hljs-operator"> &amp;&amp; </span>j &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt;= nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>) &#123;<br>                temp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">i</span><span class="hljs-operator">++</span>]</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                temp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">j</span><span class="hljs-operator">++</span>]</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 剩下的数组元素，可以依次赋值</span><br>        <span class="hljs-keyword">while</span>(i &lt;= mid) &#123;<br>            temp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">i</span><span class="hljs-operator">++</span>]</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j &lt;= right) &#123;<br>            temp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">j</span><span class="hljs-operator">++</span>]</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将temp排好序的依次赋值给nums</span><br>        <span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> a = left; a &lt;= right; a++) &#123;<br>            nums<span class="hljs-literal">[<span class="hljs-identifier">a</span>]</span> = temp<span class="hljs-literal">[<span class="hljs-identifier">b</span><span class="hljs-operator">++</span>]</span>;<br>        &#125;<br>    &#125;<br><br>作者：豚豚<br>链接：https:<span class="hljs-comment">//leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55ghq7/?discussion=ngEXjW</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>优化 1：在小区间里使用插入排序<br>如果区间里只有 22 个元素，例如 [4, 3][4,3]，只要把它们直接交换一下位置就可以了。但是这种情况还太特殊，对于区间里有 33 个元素、44 个元素的情况就不奏效了，一个更直接且有效的做法是：在小区间里使用插入排序。</p><p>事实上，在归并排序的子过程里，可以使用插入排序的原因是：</p><p>首先，操作的指令数更少；<br>其次，插入排序也是稳定的排序算法，修改成插入排序并不影响归并排序的稳定性。<br>当然这个子区间不能很大，子区间在多长的时候转而使用插入排序，这需要通过实验才能知道。学习过机器学习的朋友，就会知道它是一个超参数，目前 Java 语言的库函数将它定义成 4747。</p><p>优化 2：子区间本身有序则无需归并<br>如果这个子区间本身就是有序的，我们没有必要执行归并的过程。</p><p>例如：[1, 3, 4, 5, 6, 7, 8, 9]。 在上一节介绍的分治算法的时候，需要将它一分为二，前半部分是 [1, 3, 4, 5]，后半部分是 [6, 7, 8, 9]，事实上这一步是没有必要的。</p><p><strong>优化 3：在整个归并的过程中，使用同一个辅助数组</strong><br>上一节的做法，我们每次归并之前都得创建一个临时数组，在 Java 语言中，使用完以后就会被垃圾回收机制回收。</p><p><strong>这个频繁创建数组和销毁数组的过程，有一定性能消耗；</strong><br>不管是复制数组，还是把归并的结果赋值回去，都得计算偏移量。而事实上，当我们全局使用一个临时数组用于归并的时候，可以省略偏移量的计算。<br>下面我们就从代码层面讲解如何优化归并排序。</p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55gb35/">https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55gb35/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h4 id="优化归并"><a href="#优化归并" class="headerlink" title="优化归并"></a>优化归并</h4><p>public class Solution {</p><pre><code class="hljs">/** * 列表大小等于或小于该大小，将优先于 mergesort 使用插入排序 */private static final int INSERTION_SORT_THRESHOLD = 47;public int[] sortArray(int[] nums) &#123;    int len = nums.length;    // 优化 3：全局使用一份临时数组    int[] temp = new int[len];    mergeSort(nums, 0, len - 1, temp);    return nums;&#125;private void mergeSort(int[] nums, int left, int right, int[] temp) &#123;    // 优化 1：小区间使用插入排序    if (right - left &lt;= INSERTION_SORT_THRESHOLD) &#123;        insertionSort(nums, left, right);        return;    &#125;    int mid = left + (right - left) / 2;    mergeSort(nums, left, mid, temp);    mergeSort(nums, mid + 1, right, temp);    // 优化 2：数组已经有序的情况下，不再合并    if (nums[mid] &lt;= nums[mid + 1]) &#123;        return;    &#125;    mergeOfTwoSortedArray(nums, left, mid, right, temp);&#125;private void mergeOfTwoSortedArray(int[] nums, int left, int mid, int right, int[] temp) &#123;    for (int i = left; i &lt;= right; i++) &#123;        temp[i] = nums[i];    &#125;    int i = left;    int j = mid + 1;    for (int k = left; k &lt;= right; k++) &#123;        if (i == mid + 1) &#123;            nums[k] = temp[j];            j++;        &#125; else if (j == right + 1) &#123;            nums[k] = temp[i];            i++;        &#125; else if (temp[i] &lt;= temp[j]) &#123;            // 注意：这里一定要写成 &lt;=，否则就变成了非稳定排序            nums[k] = temp[i];            i++;        &#125; else &#123;            nums[k] = temp[j];            j++;        &#125;    &#125;&#125;/** * 对数组给定的部分使用插入排序 * * @param arr   给定数组 * @param left  左边界，能取到 * @param right 右边界，能取到 */private void insertionSort(int[] arr, int left, int right) &#123;    for (int i = left + 1; i &lt;= right; i++) &#123;        int temp = arr[i];        int j = i;        while (j &gt; left &amp;&amp; arr[j - 1] &gt; temp) &#123;            arr[j] = arr[j - 1];            j--;        &#125;        arr[j] = temp;    &#125;&#125;</code></pre><p>}</p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55gb35/">https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55gb35/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="滑动窗口（双指针）"><a href="#滑动窗口（双指针）" class="headerlink" title="滑动窗口（双指针）"></a>滑动窗口（双指针）</h2><p>时间复杂度：O(n)</p><p>right一直往右移动</p><p>如果碰上条件，left就收缩</p><p>所以是</p><p>时间复杂度是o（n）</p><p>空间复杂度是O（1）</p><p>1.从暴力解法优化，类似于剪枝法从O(n2)-&gt;O(n1)</p><p>2.利用的是left固定住之后，right一直向右，只要遇上了重复字符，当前的res就再也不可能变大，于是可以left当前值的循环可以跳过，可以直接left+1</p><p>3.滑动窗口问题如果一下子没有思路，先考虑暴力解法，然后再纸上写写画画，进而考虑优化的解法，通常考虑「剪枝」或者「空间换时间」。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> length<span class="hljs-constructor">OfLongestSubstring(String <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> len  =s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            return <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//[left,right]</span><br>        <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> right = <span class="hljs-number">0</span>;<br>        HashMap&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(right = <span class="hljs-number">0</span>;right&lt;len;right++)<br>        &#123;<br>            <span class="hljs-comment">// right右移</span><br>            map.put(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>,map.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">right</span>)</span>,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">//如果需要，则收缩</span><br>            <span class="hljs-keyword">while</span>(left &lt; right<span class="hljs-operator"> &amp;&amp; </span>map.get(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>)&gt;=<span class="hljs-number">2</span>)<br>            &#123;<br>                map.put(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>,map.get(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>)-<span class="hljs-number">1</span>);<br>                left++;<br>            &#125;<br>            res= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(res,right-left+<span class="hljs-number">1</span>);<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs awk">public class Solution &#123;<br><br>    public String minWindow(String s, String t) &#123;<br>        <span class="hljs-regexp">//</span> 同方向移动，起始的时候，都位于 <span class="hljs-number">0</span>，表示我们定义搜索区间为 [left, right) ，此时区间为空区间<br>        int left = <span class="hljs-number">0</span>;<br>        int right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; sLen) &#123;<br><br>            <span class="hljs-keyword">if</span> ( 在右移的过程中检测是否满足条件 ) &#123;<br>                <span class="hljs-regexp">//</span> 对状态做修改，好让程序在后面检测到满足条件<br>            &#125;<br><br>            <span class="hljs-regexp">//</span> 右边界右移 <span class="hljs-number">1</span> 格<br>            right++;<br><br>            <span class="hljs-keyword">while</span> ( 满足条件 ) &#123;<br><br>                <span class="hljs-regexp">//</span> ① 走到这里是满足条件的，左边界逐渐逐渐左移，可以取最小值<br><br>                <span class="hljs-keyword">if</span> ( 在左移的过程中检测是否不满足条件 ) &#123;<br>                    <span class="hljs-regexp">//</span> 对状态做修改，好让程序在后面检测到不满足条件<br>                &#125;<br><br>                <span class="hljs-regexp">//</span> 左边界左移 <span class="hljs-number">1</span> 格<br>                left++;<br>            &#125;<br>            <span class="hljs-regexp">//</span> ② 走到这里是不满足条件的，右边界逐渐右移，可以取最大值<br>        &#125;<br>        return 需要的结果变量;<br>    &#125;<br>&#125;<br><br>作者：liweiwei1419<br>链接：https:<span class="hljs-regexp">//</span>leetcode.cn<span class="hljs-regexp">/leetbook/</span>read<span class="hljs-regexp">/learning-algorithms-with-leetcode/</span>x1vsvd/<br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public <span class="hljs-built_in">int</span> numRescueBoats(<span class="hljs-built_in">int</span>[] people, <span class="hljs-built_in">int</span> limit) &#123;<br>        Arrays.sort(people);<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span> = people.length;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = <span class="hljs-built_in">len</span>-<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        while(<span class="hljs-built_in">left</span>&lt;<span class="hljs-built_in">right</span>)<br>        &#123;<br>            //最轻的可以带上最重的<br>            <span class="hljs-built_in">if</span>(people[<span class="hljs-built_in">left</span>]+people[<span class="hljs-built_in">right</span>] &lt;=limit)<br>            &#123;<br>                <span class="hljs-built_in">left</span>++;<br>                <span class="hljs-built_in">right</span>--;<br>                res++;<br>            &#125;<br>            //最轻的带不上最重的<br>            else//最重的只能自己走<br>            &#123;<br>                <span class="hljs-built_in">right</span>--;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">left</span>==<span class="hljs-built_in">right</span>)<br>        &#123;<br>            res++;<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><img src="/shizhuofan.GitHub.io/2023/03/29/LeetCode/image-20230201112153877.png" class title="image-20230201112153877"><img src="/shizhuofan.GitHub.io/2023/03/29/LeetCode/image-20230201112208420.png" class title="image-20230201112208420">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/k8s%E5%AE%89%E8%A3%85jenkins/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/k8s%E5%AE%89%E8%A3%85jenkins/</url>
    
    <content type="html"><![CDATA[<p>k8s安装jenkins</p><p>1.在csdn找非官方教程吃了很多亏</p><p>2.我最后在官网教程一下子就搞好了yyds</p><p><a href="https://www.jenkins.io/doc/book/installing/kubernetes/">https://www.jenkins.io/doc/book/installing/kubernetes/</a></p><p>jenkins账号a944613709</p><p>密码250772730</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/k8s%E5%AE%89%E8%A3%85helm/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/k8s%E5%AE%89%E8%A3%85helm/</url>
    
    <content type="html"><![CDATA[<p>k8s安装helm</p><p><a href="https://cloud.tencent.com/developer/article/1694640">https://cloud.tencent.com/developer/article/1694640</a></p><p>#根据操作系统去获取最新二进制安装包<a href="https://github.com/helm/helm/releases">https://github.com/helm/helm/releases</a>        </p><p>wget <a href="https://get.helm.sh/helm-v3.3.1-linux-amd64.tar.gz">https://get.helm.sh/helm-v3.3.1-linux-amd64.tar.gz</a>        </p><p>#由于helm包在国外,我通过ss拉到了腾讯云cos,国内可通过以下地址访问:<a href="https://download.osichina.net/tools/k8s/helm/helm-v3.3.1-linux-amd64.tar.gz">https://download.osichina.net/tools/k8s/helm/helm-v3.3.1-linux-amd64.tar.gz</a>        </p><p>tar -zxvf helm-v3.3.1-linux-amd64.tar.gz        </p><p>cp linux-amd64&#x2F;helm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/GO%E8%AF%AD%E8%A8%80/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/GO%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 单行注释</span><br><span class="hljs-comment">/* 多行</span><br><span class="hljs-comment">   注释 */</span><br><span class="hljs-comment">// go的IDE我推荐Vscode，Goland也不错，前者我自用，后者同同事都在用</span><br><span class="hljs-comment">// 用 go 开发时注释中也会经常见到文档注解，如 @Version 1.0.0</span><br><br><span class="hljs-comment">// 导入包的子句在每个源文件的开头。</span><br><span class="hljs-comment">// Main比较特殊，它用来声明可执行文件，而不是一个库。</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">// Import语句声明了当前文件引用的包。</span><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span>       <span class="hljs-comment">// Go语言标准库中的包</span><br>   <span class="hljs-string">&quot;net/http&quot;</span>  <span class="hljs-comment">// 一个web服务器包</span><br>   <span class="hljs-string">&quot;strconv&quot;</span>   <span class="hljs-comment">// 字符串转换</span><br>   <span class="hljs-string">&quot;strings&quot;</span>   <span class="hljs-comment">// 字符串标准库</span><br>)<br><span class="hljs-comment">// 等你写习惯了go不带分好，写Java会很变扭</span><br><br><span class="hljs-comment">// 函数声明：Main是程序执行的入口。</span><br><span class="hljs-comment">// 不管你喜欢还是不喜欢，反正Go就用了花括号来包住函数体，花括号配合严格的缩进，代码非常易读。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// 往标准输出打印一行。</span><br>   <span class="hljs-comment">// 用包名fmt限制打印函数。</span><br>   fmt.Println(<span class="hljs-string">&quot;Hello world!&quot;</span>)<br>   <span class="hljs-comment">// 写项目时用 log.Println(&quot;Hello world!&quot;) 会更多</span><br><br>   <span class="hljs-comment">// 调用当前包的另一个函数。</span><br>   beyondHello()<br>&#125;<br><br><span class="hljs-comment">// 函数可以在括号里加参数。</span><br><span class="hljs-comment">// 如果没有参数的话，也需要一个空括号。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">beyondHello</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> x <span class="hljs-type">int</span>   <span class="hljs-comment">// 变量声明，变量必须在使用之前声明。</span><br>   x = <span class="hljs-number">3</span>       <span class="hljs-comment">// 变量赋值。</span><br>   <span class="hljs-comment">// 可以用:=来偷懒，它自动把变量类型、声明和赋值都搞定了，这个在项目中最常用。</span><br>   y := <span class="hljs-number">4</span><br>   sum, prod := learnMultiple(x, y)        <span class="hljs-comment">// 返回多个变量的函数</span><br>   fmt.Println(<span class="hljs-string">&quot;sum:&quot;</span>, sum, <span class="hljs-string">&quot;prod:&quot;</span>, prod) <span class="hljs-comment">// 简单输出</span><br>   learnTypes()                            <span class="hljs-comment">// 少于y分钟，学的更多！</span><br>&#125;<br><br><span class="hljs-comment">// 多变量和多返回值的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">learnMultiple</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> (sum, prod <span class="hljs-type">int</span>) &#123;<br>   <span class="hljs-keyword">return</span> x + y, x * y <span class="hljs-comment">// 返回两个值</span><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">      // 因为这里返回值不仅有类型，还写了名称，因此函数体其实还可以这么写</span><br><span class="hljs-comment">      sum = x + y // 注意这里不是 :=</span><br><span class="hljs-comment">      prod = x * y</span><br><span class="hljs-comment">      return</span><br><span class="hljs-comment">   */</span><br>&#125;<br><br><span class="hljs-comment">// 内置变量类型和关键词</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">learnTypes</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// 短声明给你所想。</span><br>   s := <span class="hljs-string">&quot;Learn Go!&quot;</span> <span class="hljs-comment">// String类型</span><br><br>   s2 := <span class="hljs-string">`A &quot;raw&quot; string literal</span><br><span class="hljs-string">can include line breaks.`</span> <span class="hljs-comment">// 同样是String类型</span><br><br>   <span class="hljs-comment">// 非ascii字符。Go使用UTF-8编码。</span><br>   g := <span class="hljs-string">&#x27;Σ&#x27;</span> <span class="hljs-comment">// rune类型，int32的别名，使用UTF-8编码</span><br><br>   f := <span class="hljs-number">3.14195</span> <span class="hljs-comment">// float64类型，IEEE-754 64位浮点数</span><br>   c := <span class="hljs-number">3</span> + <span class="hljs-number">4i</span>  <span class="hljs-comment">// complex128类型，内部使用两个float64表示</span><br><br>   <span class="hljs-comment">// Var变量可以直接初始化。</span><br>   <span class="hljs-keyword">var</span> u <span class="hljs-type">uint</span> = <span class="hljs-number">7</span>  <span class="hljs-comment">// unsigned 无符号变量，但是实现依赖int型变量的长度</span><br>   <span class="hljs-keyword">var</span> pi <span class="hljs-type">float32</span> = <span class="hljs-number">22.</span> / <span class="hljs-number">7</span><br><br>   <span class="hljs-comment">// 字符转换</span><br>   n := <span class="hljs-type">byte</span>(<span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-comment">// byte是uint8的别名</span><br><br>   <span class="hljs-comment">// 数组类型编译的时候大小固定。</span><br>   <span class="hljs-keyword">var</span> a4 [<span class="hljs-number">4</span>] <span class="hljs-type">int</span>              <span class="hljs-comment">// 有4个int变量的数组，初始为0</span><br>   a3 := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;     <span class="hljs-comment">// 有3个int变量的数组，同时进行了初始化</span><br><br>   <span class="hljs-comment">// Slice 可以动态的增删。Array和Slice各有千秋，但是使用slice的地方更多些。</span><br>   s3 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>&#125;        <span class="hljs-comment">// 和a3相比，这里没有省略号</span><br>   s4 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">4</span>)        <span class="hljs-comment">// 分配一个有4个int型变量的slice，全部被初始化为0</span><br><br>   <span class="hljs-comment">// 常见操作</span><br>   str := <span class="hljs-string">&quot;带加豪，偶稀渣渣辉&quot;</span><br>   bs := []<span class="hljs-type">byte</span>(str) <span class="hljs-comment">// 字符串转化为byte切片</span><br>   str2 := <span class="hljs-type">string</span>(bs) <span class="hljs-comment">// byte切片转字符串</span><br>   <span class="hljs-built_in">println</span>(str, <span class="hljs-built_in">len</span>(str), bs, <span class="hljs-built_in">len</span>(bs), str2, strings.Count(str, <span class="hljs-string">&quot;&quot;</span>)<span class="hljs-number">-1</span>) <span class="hljs-comment">// println函数更像 Java的 sysout</span><br>   fmt.Println(str, <span class="hljs-built_in">len</span>(str), bs, <span class="hljs-built_in">len</span>(bs), str2, strings.Count(str2, <span class="hljs-string">&quot;渣&quot;</span>)) <span class="hljs-comment">// 这个效果更好</span><br><br>   <span class="hljs-keyword">var</span> d2 [][]<span class="hljs-type">float64</span>          <span class="hljs-comment">// 声明而已，什么都没有分配</span><br>   bs := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;a slice&quot;</span>)     <span class="hljs-comment">// 类型转换的语法</span><br><br>   p, q := learnMemory()       <span class="hljs-comment">// 声明p,q为int型变量的指针</span><br>   fmt.Println(*p, *q)         <span class="hljs-comment">// * 取值</span><br><br>   <span class="hljs-comment">// Map是动态可增长关联数组，和其他语言中的hash或者字典相似。</span><br>   m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;three&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;four&quot;</span>: <span class="hljs-number">4</span>&#125;<br>   m[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-number">1</span><br><br>   <span class="hljs-comment">// 在Go语言中未使用的变量在编译的时候会报错，而不是warning。</span><br>   <span class="hljs-comment">// 下划线 _ 可以使你“使用”一个变量，但是丢弃它的值。</span><br>   _,_,_,_,_,_,_,_,_ = s2, g, f, u, pi, n, a3, s4, bs<br>   <span class="hljs-comment">// 输出变量, 从结果可知上面这种操作并不会清除变量</span><br>   fmt.Println(s, c, a4, s3, d2, m)<br><br>   learnFlowControl() <span class="hljs-comment">// 回到流程控制 </span><br>&#125;<br><br><span class="hljs-comment">// Go全面支持垃圾回收。Go有指针，但是不支持指针运算。</span><br><span class="hljs-comment">// 你会因为空指针而犯错，但是不会因为增加指针而犯错。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">learnMemory</span><span class="hljs-params">()</span></span> (p, q *<span class="hljs-type">int</span>) &#123;<br>   <span class="hljs-comment">// 返回int型变量指针p和q</span><br>   p = <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)    <span class="hljs-comment">// 内置函数new分配内存</span><br>   <span class="hljs-comment">// 自动将分配的int赋值0，p不再是空的了。</span><br>   s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">20</span>)    <span class="hljs-comment">// 给20个int变量分配一块内存</span><br>   s[<span class="hljs-number">3</span>] = <span class="hljs-number">7</span>                <span class="hljs-comment">// 赋值</span><br>   r := <span class="hljs-number">-2</span>                 <span class="hljs-comment">// 声明另一个局部变量</span><br>   <span class="hljs-keyword">return</span> &amp;s[<span class="hljs-number">3</span>], &amp;r        <span class="hljs-comment">// &amp; 取地址</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">expensiveComputation</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">1e6</span> <span class="hljs-comment">// 1 * 10^6</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">learnFlowControl</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// If需要花括号，括号就免了</span><br>   <span class="hljs-keyword">if</span> <span class="hljs-literal">true</span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;told ya&quot;</span>)<br>   &#125;<br>   <span class="hljs-comment">// 用go fmt 命令可以帮你格式化代码，所以不用怕被人吐槽代码风格了，</span><br>   <span class="hljs-comment">// 也不用容忍被人的代码风格。</span><br>   <span class="hljs-keyword">if</span> <span class="hljs-literal">false</span> &#123;<br>      <span class="hljs-comment">// pout</span><br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// gloat</span><br>   &#125;<br>   <span class="hljs-comment">// 如果太多嵌套的if语句，推荐使用switch</span><br>   x := <span class="hljs-number">1</span><br>   <span class="hljs-keyword">switch</span> x &#123;<br>   <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>   <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>      <span class="hljs-comment">// 隐式调用break语句，匹配上一个即停止</span><br>   <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      <span class="hljs-comment">// 不会运行</span><br>   <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>      <span class="hljs-comment">// 如果非要匹配上一个不停止，也不是不可</span><br>      <span class="hljs-keyword">fallthrough</span> <span class="hljs-comment">// 但是不建议使用</span><br>   <span class="hljs-keyword">default</span>:<br>      <span class="hljs-comment">// 都没匹配上执行</span><br>   &#125;<br><br>   <span class="hljs-comment">// 和if一样，for也不用括号</span><br>   <span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">3</span>; x++ &#123; <span class="hljs-comment">// ++ 自增</span><br>      fmt.Println(<span class="hljs-string">&quot;iteration&quot;</span>, x)<br>   &#125;<br>   <span class="hljs-comment">// x在这里还是1。为什么？</span><br><br>   <span class="hljs-comment">// for 是go里唯一的循环关键字，不过它有很多变种</span><br>   <span class="hljs-keyword">for</span> &#123; <span class="hljs-comment">// 死循环</span><br>      <span class="hljs-keyword">break</span>    <span class="hljs-comment">// 骗你的 </span><br>      <span class="hljs-keyword">continue</span> <span class="hljs-comment">// 不会运行的</span><br>   &#125;<br>   <span class="hljs-comment">// 和for一样，if中的:=先给y赋值，然后再和x作比较。</span><br>   <span class="hljs-keyword">if</span> y := expensiveComputation(); y &gt; x &#123;<br>      x = y<br>   &#125;<br><br>   <span class="hljs-comment">// 闭包函数</span><br>   xBig := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> &#123;<br>      <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">100</span> <span class="hljs-comment">// x是上面声明的变量引用</span><br>   &#125;<br>   fmt.Println(<span class="hljs-string">&quot;xBig:&quot;</span>, xBig()) <span class="hljs-comment">// true （上面把y赋给x了） </span><br>   x /= <span class="hljs-number">1e5</span>                     <span class="hljs-comment">// x变成10</span><br>   fmt.Println(<span class="hljs-string">&quot;xBig:&quot;</span>, xBig()) <span class="hljs-comment">// 现在是false</span><br><br>   <span class="hljs-comment">// 当你需要goto的时候，你会爱死它的！</span><br>   <span class="hljs-keyword">goto</span> love<br>love:<br><br>   learnInterfaces() <span class="hljs-comment">// 好东西来了！</span><br>&#125;<br><br><span class="hljs-comment">// 定义Stringer为一个接口类型，有一个方法String</span><br><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>   String() <span class="hljs-type">string</span> <span class="hljs-comment">// 这里可以有多个方法声明</span><br>&#125;<br><br><span class="hljs-comment">// 定义pair为一个结构体，有x和y两个int型变量。</span><br><span class="hljs-comment">// 这个pair相当于Java中的一个类</span><br><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span> &#123;<br>   x, y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// 定义pair类型的成员方法，实现Stringer接口，这里不需要显示指定 Stringer</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p pair)</span></span> String() <span class="hljs-type">string</span> &#123; <span class="hljs-comment">// p被叫做“接收器”</span><br>   <span class="hljs-comment">// Sprintf是fmt包中的另一个公有函数。</span><br>   <span class="hljs-comment">// 用 . 调用p中的元素。</span><br>   <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;(%d, %d)&quot;</span>, p.x, p.y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">learnInterfaces</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// 花括号用来定义结构体变量，:=在这里将一个结构体变量赋值给p。</span><br>   p := pair&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>   fmt.Println(p.String()) <span class="hljs-comment">// 调用pair类型p的String方法 </span><br>   <span class="hljs-keyword">var</span> i Stringer          <span class="hljs-comment">// 声明i为Stringer接口类型 </span><br>   i = p                   <span class="hljs-comment">// 有效！因为p实现了Stringer接口（类似java中的塑型） </span><br>   <span class="hljs-comment">// 调用i的String方法，输出和上面一样</span><br>   fmt.Println(i.String())<br><br>   <span class="hljs-comment">// fmt包中的Println函数向对象要它们的string输出，实现了String方法就可以这样使用了。</span><br>   <span class="hljs-comment">// （类似java中的序列化）</span><br>   fmt.Println(p) <span class="hljs-comment">// 输出和上面一样，自动调用String函数。</span><br>   fmt.Println(i) <span class="hljs-comment">// 输出和上面一样。</span><br><br>   learnErrorHandling()<br>&#125;<br><br><span class="hljs-comment">// 你可以定义别的结构体作为接收器来实现 String() string 方法，实现多态，</span><br><span class="hljs-comment">// 在实例化时以Stringer作为其类型 (var obj Stringer)， 赋值赋不同的结构体</span><br><span class="hljs-comment">// 可详细参考 https://www.jianshu.com/p/1227c5145cd8</span><br><span class="hljs-comment">// 我认为 Golang勉强可以面向对象，但是没必要对Java那套太挂念</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">learnErrorHandling</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// 一开始不适应没 try catch，习惯了你会爱上她</span><br>   <span class="hljs-comment">// &quot;, ok&quot;用来判断有没有正常工作 </span><br>   m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-number">3</span>: <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&quot;four&quot;</span>&#125;<br>   <span class="hljs-keyword">if</span> x, ok := m[<span class="hljs-number">1</span>]; !ok &#123; <span class="hljs-comment">// ok 为false，因为m中没有1</span><br>      fmt.Println(<span class="hljs-string">&quot;no one there&quot;</span>)<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>      fmt.Print(x) <span class="hljs-comment">// 如果x在map中的话，x就是那个值喽。</span><br>   &#125;<br>   <span class="hljs-comment">// 错误可不只是ok，它还可以给出关于问题的更多细节。</span><br>   <span class="hljs-keyword">if</span> _, err := strconv.Atoi(<span class="hljs-string">&quot;non-int&quot;</span>); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// _ discards value</span><br>      <span class="hljs-comment">// 输出&quot;strconv.ParseInt: parsing &quot;non-int&quot;: invalid syntax&quot;</span><br>      fmt.Println(err)<br>   &#125;<br>   <span class="hljs-comment">// 待会再说接口吧。同时，</span><br>   learnConcurrency()<br>&#125;<br><br><span class="hljs-comment">// c是channel类型，一个并发安全的通信对象。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inc</span><span class="hljs-params">(i <span class="hljs-type">int</span>, c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>   c &lt;- i + <span class="hljs-number">1</span> <span class="hljs-comment">// &lt;-把右边的发送到左边的channel。</span><br>&#125;<br><br><span class="hljs-comment">// 我们将用inc函数来并发地增加一些数字。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">learnConcurrency</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// 用make来声明一个slice，make会分配和初始化slice，map和channel。</span><br>   c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>   <span class="hljs-comment">// 用go关键字开始三个并发的goroutine，如果机器支持的话，还可能是并行执行。</span><br>   <span class="hljs-comment">// 三个都被发送到同一个channel。</span><br>   <span class="hljs-keyword">go</span> inc(<span class="hljs-number">0</span>, c) <span class="hljs-comment">// go is a statement that starts a new goroutine.</span><br>   <span class="hljs-keyword">go</span> inc(<span class="hljs-number">10</span>, c)<br>   <span class="hljs-keyword">go</span> inc(<span class="hljs-number">-805</span>, c)<br>   <span class="hljs-comment">// 从channel中独处结果并打印。</span><br>   <span class="hljs-comment">// 打印出什么东西是不可预知的。</span><br>   fmt.Println(&lt;-c, &lt;-c, &lt;-c) <span class="hljs-comment">// channel在右边的时候，&lt;-是读操作。</span><br><br>   cs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)       <span class="hljs-comment">// 操作string的channel</span><br>   cc := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)  <span class="hljs-comment">// 操作channel的channel</span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; c &lt;- <span class="hljs-number">84</span> &#125;()       <span class="hljs-comment">// 开始一个goroutine来异步发送一个新的数字 </span><br>   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; cs &lt;- <span class="hljs-string">&quot;wordy&quot;</span> &#125;() <span class="hljs-comment">// 发送给cs</span><br><br>   <span class="hljs-comment">// Select类似于switch，但是每个case包括一个channel操作。</span><br>   <span class="hljs-comment">// 它随机选择一个准备好通讯的case。</span><br>   <span class="hljs-keyword">select</span> &#123;<br>   <span class="hljs-keyword">case</span> i := &lt;-c: <span class="hljs-comment">// 从channel接收的值可以赋给其他变量</span><br>      fmt.Println(<span class="hljs-string">&quot;it&#x27;s a&quot;</span>, i)<br>   <span class="hljs-keyword">case</span> &lt;-cs: <span class="hljs-comment">// 或者直接丢弃</span><br>      fmt.Println(<span class="hljs-string">&quot;it&#x27;s a string&quot;</span>)<br>   <span class="hljs-keyword">case</span> &lt;-cc: <span class="hljs-comment">// 空的，还没作好通讯的准备 </span><br>      fmt.Println(<span class="hljs-string">&quot;didn&#x27;t happen.&quot;</span>)<br>   &#125;<br>   <span class="hljs-comment">// 上面c或者cs的值被取到，其中一个goroutine结束，另外一个一直阻塞。</span><br><br>   learnWebProgramming() <span class="hljs-comment">// Go很适合web编程，我知道你也想学！</span><br>&#125;<br><span class="hljs-comment">// 上述函数可是涉及到了 多线程，多线程通信，但是却简单明了</span><br><br><span class="hljs-comment">// http包中的一个简单的函数就可以开启web服务器。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">learnWebProgramming</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// ListenAndServe第一个参数指定了监听端口，第二个参数是一个接口，特定是http.Handler。</span><br>   err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, pair&#123;&#125;)<br><br>   fmt.Println(err) <span class="hljs-comment">// 不要无视错误。</span><br>   <span class="hljs-comment">// 如何优雅的关闭 http server: https://www.cnblogs.com/oxspirt/p/7058812.html</span><br>&#125;<br><br><span class="hljs-comment">// 使pair实现http.Handler接口的ServeHTTP方法。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p pair)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br>   <span class="hljs-comment">// 使用http.ResponseWriter返回数据</span><br>   w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;You learned Go in Y minutes!&quot;</span>))<br>   <span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;最后一个执行&quot;</span>)<br>   <span class="hljs-comment">// defer 语句常用于处理 io的关闭，在函数内代码执行完之后依次执行</span><br>   <span class="hljs-comment">// 执行顺序遵循压栈出栈顺序</span><br>   <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>      fmt.Println(<span class="hljs-string">&quot;倒数第二个执行&quot;</span>)<br>   &#125;()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/Es%E5%AE%89%E8%A3%85/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/Es%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Es安装"><a href="#Es安装" class="headerlink" title="Es安装"></a>Es安装</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d     --name es     -e <span class="hljs-string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span>     -v es-data:/usr/share/elasticsearch/data     -v es-plugins:/usr/share/elasticsearch/plugins     --privileged     --network es-net     -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span>    -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> elasticsearch:<span class="hljs-number">7</span>.<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><br><br><span class="hljs-attribute">docker</span> run -d --name kibana -e ELASTICSEARCH_HOSTS=http://es:<span class="hljs-number">9200</span> --network=es-net -p <span class="hljs-number">5601</span>:<span class="hljs-number">5601</span>  kibana:<span class="hljs-number">7</span>.<span class="hljs-number">12</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/CCF%E2%80%94%E2%80%94CSP/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/CCF%E2%80%94%E2%80%94CSP/</url>
    
    <content type="html"><![CDATA[<h1 id="CCF——CSP"><a href="#CCF——CSP" class="headerlink" title="CCF——CSP"></a>CCF——CSP</h1><p>模板</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-type">int</span>[] nums;<br>    <span class="hljs-type">int</span> max = Integer.MIN_VALUE;<br>    <span class="hljs-type">int</span> min = Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> sum_max =<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> sum_min = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> len = sc.<span class="hljs-built_in">nextInt</span>();<br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i &lt; len; i++)<br>        &#123;<br>            nums[i] =  sc.<span class="hljs-built_in">nextInt</span>();<br>            sum_max += nums[i];<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; max) <span class="hljs-comment">//</span><br>            &#123;<br>                sum_min += nums[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                sum_min += <span class="hljs-number">0</span>;<br>            &#125;<br>            max = Math.<span class="hljs-built_in">max</span>(max,nums[i]);<br>            min = Math.<span class="hljs-built_in">min</span>(min,nums[i]);<br>        &#125;<br>        System.out.<span class="hljs-built_in">println</span>(sum_max);<br>        System.out.<span class="hljs-built_in">println</span>(sum_min);<br>    &#125;<br>  <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-built_in">Main</span>().<span class="hljs-built_in">run</span>();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><img src="/shizhuofan.GitHub.io/2023/03/29/CCF%E2%80%94%E2%80%94CSP/image-20230315095728746.png" class title="image-20230315095728746"><img src="/shizhuofan.GitHub.io/2023/03/29/CCF%E2%80%94%E2%80%94CSP/image-20230315194658296.png" class title="image-20230315194658296">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/shizhuofan.GitHub.io/2023/03/29/hello-world/"/>
    <url>/shizhuofan.GitHub.io/2023/03/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
