<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Idea,Pycharm新手入门常用快捷键以及使用技巧，jetBrain系列通用</title>
    <link href="/shizhuofan.GitHub.io/2023/04/28/Idea,Pycharm%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%8CjetBrain%E7%B3%BB%E5%88%97%E9%80%9A%E7%94%A8/"/>
    <url>/shizhuofan.GitHub.io/2023/04/28/Idea,Pycharm%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%8CjetBrain%E7%B3%BB%E5%88%97%E9%80%9A%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>引言：</strong><br>我学了Java基础一直到Springcloud项目，断断续续快有2年了。分享一下最开始入门时候一步步积累的Idea使用技巧。我当时苦于没有一个总结快捷键教程的，找了很久Idea该怎么用啊，是不是每次都要打System.out.println()这样一大串啊，当时就很傻，这就硬打，后来才知道有很简单的方法</p><hr><p>@[TOC]</p><h2 id="1-Ctrl-o快速找方法"><a href="#1-Ctrl-o快速找方法" class="headerlink" title="1. Ctrl+o快速找方法"></a>1. Ctrl+o快速找方法</h2><h2 id="2-Alt-EnTER"><a href="#2-Alt-EnTER" class="headerlink" title="2. Alt + EnTER"></a>2. Alt + EnTER</h2><p>对这个代码快速智能补全trycatch<br>对这个快速加入要写的接口方法show</p><h2 id="3-使用Ctrl-x2F-，-添加行注释"><a href="#3-使用Ctrl-x2F-，-添加行注释" class="headerlink" title="3. 使用Ctrl+ &#x2F;， 添加行注释"></a>3. 使用Ctrl+ &#x2F;， 添加行注释</h2><h2 id="4-输入psvm-按Tab，自动生成void-main"><a href="#4-输入psvm-按Tab，自动生成void-main" class="headerlink" title="4. 输入psvm + 按Tab，自动生成void main"></a>4. 输入psvm + 按Tab，自动生成void main</h2><p>输入souf 按Tab就是System.out.printf()</p><h2 id="5-Ctrl-F12-查看参考代码内部方法"><a href="#5-Ctrl-F12-查看参考代码内部方法" class="headerlink" title="5. Ctrl+F12 查看参考代码内部方法"></a>5. Ctrl+F12 查看参考代码内部方法</h2><p><img src="https://img-blog.csdnimg.cn/48235238de974e7bb9a0b4b7acaea0f6.png" alt="在这里插入图片描述"></p><h2 id="6-CTRL-Alt-t"><a href="#6-CTRL-Alt-t" class="headerlink" title="6. CTRL + Alt+t"></a>6. CTRL + Alt+t</h2><p>if快速包围<br><img src="https://img-blog.csdnimg.cn/a751758ca6774673ab46ade3f8d10c06.png" alt="在这里插入图片描述"></p><h2 id="7-CTRL-P"><a href="#7-CTRL-P" class="headerlink" title="7. CTRL + P"></a>7. CTRL + P</h2><p>提示参数展示<br><img src="https://img-blog.csdnimg.cn/56f1ff02cb8f4f828d4e0f2344ea430c.png" alt="在这里插入图片描述"></p><h2 id="8-Ctrl-art-1智能提示方法（自己改的）"><a href="#8-Ctrl-art-1智能提示方法（自己改的）" class="headerlink" title="8.Ctrl + art + 1智能提示方法（自己改的）"></a>8.Ctrl + art + 1智能提示方法（自己改的）</h2><p><img src="https://img-blog.csdnimg.cn/88cc2c7e5597490eb60e06fc0d1f8dd8.png" alt="在这里插入图片描述"></p><h2 id="9-CTRL-D"><a href="#9-CTRL-D" class="headerlink" title="9 CTRL + D"></a>9 CTRL + D</h2><p>复制当前行代码快速</p><h2 id="10-可以右键翻译文档"><a href="#10-可以右键翻译文档" class="headerlink" title="10. 可以右键翻译文档"></a>10. 可以右键翻译文档</h2><p><img src="https://img-blog.csdnimg.cn/5670e407254041369fc06564708df674.png" alt="在这里插入图片描述"></p><h2 id="11-快速输出System-out-println"><a href="#11-快速输出System-out-println" class="headerlink" title="11.快速输出System.out.println"></a>11.快速输出System.out.println</h2><p>只需要输入<code>Soutv</code>，然后按下<code>Tab</code><br>即可得到System.out.println(“X&#x3D;”,x);</p><h2 id="12-输入-x2F-然后回车"><a href="#12-输入-x2F-然后回车" class="headerlink" title="12. 输入&#x2F;**然后回车"></a>12. 输入&#x2F;**然后回车</h2><p>快速注解<br><img src="https://img-blog.csdnimg.cn/c783c9460c0344098cd672d2140b54be.png" alt="在这里插入图片描述"></p><h2 id="13-CTRL-F12"><a href="#13-CTRL-F12" class="headerlink" title="13. CTRL+F12"></a>13. CTRL+F12</h2><p>提示你有哪些方法可以用<br><img src="https://img-blog.csdnimg.cn/e89c03466bc345fc925dafebad730e22.png" alt="在这里插入图片描述"></p><h2 id="14-只有将文件夹标记为-才可以右键加入JAVA文件"><a href="#14-只有将文件夹标记为-才可以右键加入JAVA文件" class="headerlink" title="14. 只有将文件夹标记为 才可以右键加入JAVA文件"></a>14. 只有将文件夹标记为 才可以右键加入JAVA文件</h2><p><img src="https://img-blog.csdnimg.cn/cba4d85c6e7c4987b56fd1dd242d36b1.png" alt="在这里插入图片描述"></p><h2 id="15-快速JUnit测试及快速单独运行-Test"><a href="#15-快速JUnit测试及快速单独运行-Test" class="headerlink" title="15.快速JUnit测试及快速单独运行@Test"></a>15.快速JUnit测试及快速单独运行@Test</h2><p>在类或者方法上面加入@Test，即可单独运行这个类或者这个方法</p><h2 id="15-Ctrl-SHIFT-T"><a href="#15-Ctrl-SHIFT-T" class="headerlink" title="15.Ctrl+SHIFT+T"></a>15.Ctrl+SHIFT+T</h2><p>快速生成测试<br><img src="https://img-blog.csdnimg.cn/487348ddbd414d3ea5319da3f8c89ea4.png" alt="在这里插入图片描述"></p><h2 id="16-双屏"><a href="#16-双屏" class="headerlink" title="16. 双屏"></a>16. 双屏</h2><p><img src="https://img-blog.csdnimg.cn/3f9f541b502c4342a7f221f66a68acf7.png" alt="在这里插入图片描述"></p><h2 id="17-idea有回收站可以恢复历史版本"><a href="#17-idea有回收站可以恢复历史版本" class="headerlink" title="17. idea有回收站可以恢复历史版本"></a>17. idea有回收站可以恢复历史版本</h2><p>呜呜呜<br><img src="https://img-blog.csdnimg.cn/e6f6db6622ac4a94a742d812759c0140.png" alt="在这里插入图片描述"></p><h2 id="18-再也不用担心怎么写路径了"><a href="#18-再也不用担心怎么写路径了" class="headerlink" title="18. 再也不用担心怎么写路径了"></a>18. 再也不用担心怎么写路径了</h2><p>在import自己写的其他包里面的CLass类，可以直接右键-&gt;复制引用<br>然后就得到了import 后面应该写的路径<br>直接右键！！！idea你是我的神！</p><p><img src="https://img-blog.csdnimg.cn/b890d57a7d81466a818bafb5388c6b79.png" alt="在这里插入图片描述"></p><h2 id="19-CTRL-SHIFT-X"><a href="#19-CTRL-SHIFT-X" class="headerlink" title="19. CTRL+SHIFT+X"></a>19. CTRL+SHIFT+X</h2><p>直接翻译并且替换注释<br><img src="https://img-blog.csdnimg.cn/7354f1a7712946259d373f6bc649bbd8.png" alt="在这里插入图片描述"></p><h2 id="20-CTRL-R才是替换查找"><a href="#20-CTRL-R才是替换查找" class="headerlink" title="20. CTRL+R才是替换查找"></a>20. CTRL+R才是替换查找</h2><p><img src="https://img-blog.csdnimg.cn/0def91fcc75b4e939f3879de55d729f8.png" alt="在这里插入图片描述"></p><p><strong>CTRL+F是本文件中查找</strong><br><strong>CTRL+SHIFT+F 是在整个项目或者整个文件夹下面的所有文件中查找</strong></p><h2 id="21-智能查看异常报错"><a href="#21-智能查看异常报错" class="headerlink" title="21.智能查看异常报错"></a>21.智能查看异常报错</h2><p>这个是当你在调试时候，悬停错误行可以看见<br><img src="https://img-blog.csdnimg.cn/bc2fd411a9e54e30937d0739b1afa51c.png" alt="在这里插入图片描述"></p><h2 id="22-鼠标停在那里一段时间规约展示"><a href="#22-鼠标停在那里一段时间规约展示" class="headerlink" title="22. 鼠标停在那里一段时间规约展示"></a>22. 鼠标停在那里一段时间规约展示</h2><p><img src="https://img-blog.csdnimg.cn/e3a390c64852406caaccb511cf8554d5.png" alt="在这里插入图片描述"></p><h2 id="22-明明在同一个包却import不了，这些不合理的错误可能是缓存炸了-清理缓存"><a href="#22-明明在同一个包却import不了，这些不合理的错误可能是缓存炸了-清理缓存" class="headerlink" title="22.明明在同一个包却import不了，这些不合理的错误可能是缓存炸了!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 清理缓存"></a>22.明明在同一个包却import不了，这些不合理的错误可能是缓存炸了!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 清理缓存</h2><p>针对奇怪的错误，如果你觉得你的项目百分百没错，你的代码没错，你的maven没错，你的improt没错，那应该就是你缓存出错了，请点击IDEA清理缓存。几分钟的事<br><img src="https://img-blog.csdnimg.cn/5d70776955dc44ebbac4a0dad6080007.png" alt="在这里插入图片描述"></p><h2 id="23-在左侧突然没有任何文件夹啦，项目结构设置导入模块"><a href="#23-在左侧突然没有任何文件夹啦，项目结构设置导入模块" class="headerlink" title="23.在左侧突然没有任何文件夹啦，项目结构设置导入模块"></a>23.在左侧突然没有任何文件夹啦，项目结构设置导入模块</h2><p><img src="https://img-blog.csdnimg.cn/a84571e9e1084eee94552f9b3b182da5.png" alt="在这里插入图片描述"></p><h2 id="24-CTRL-ALT-L-一键调整代码格式"><a href="#24-CTRL-ALT-L-一键调整代码格式" class="headerlink" title="24.CTRL+ALT+L 一键调整代码格式"></a>24.CTRL+ALT+L 一键调整代码格式</h2><p><img src="https://img-blog.csdnimg.cn/4ac55054a44c407a80e6510250970763.png" alt="在这里插入图片描述"></p><h2 id="25-CTRL-ALT-小方向左箭头-返回刚才编辑的代码地方"><a href="#25-CTRL-ALT-小方向左箭头-返回刚才编辑的代码地方" class="headerlink" title="25.CTRL+ALT+小方向左箭头 返回刚才编辑的代码地方"></a>25.CTRL+ALT+小方向左箭头 返回刚才编辑的代码地方</h2><h2 id="26-快速将类中String转为泛型"><a href="#26-快速将类中String转为泛型" class="headerlink" title="26.快速将类中String转为泛型"></a>26.快速将类中String转为泛型</h2><p><img src="https://img-blog.csdnimg.cn/fd8c08be6410442b9b651e082e5bf65f.png" alt="在这里插入图片描述"></p><h2 id="27-查看test测试样例覆盖率"><a href="#27-查看test测试样例覆盖率" class="headerlink" title="27.查看test测试样例覆盖率"></a>27.查看test测试样例覆盖率</h2><p><img src="https://img-blog.csdnimg.cn/61500850107f494f9112c55951ac074b.png" alt="在这里插入图片描述"></p><h2 id="28-git合并查看差距"><a href="#28-git合并查看差距" class="headerlink" title="28.git合并查看差距"></a>28.git合并查看差距<img src="https://img-blog.csdnimg.cn/c6f60bc344214d02876271514b8ec82e.png" alt="28.点击查看差异"></h2><h2 id="29-快速将一段代码提取出来转为方法"><a href="#29-快速将一段代码提取出来转为方法" class="headerlink" title="29.快速将一段代码提取出来转为方法"></a>29.快速将一段代码提取出来转为方法</h2><p>选中代码然后按</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">CTRL</span> + ALT + M<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>随心记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>long和Long</title>
    <link href="/shizhuofan.GitHub.io/2023/04/28/long%E5%92%8CLong/"/>
    <url>/shizhuofan.GitHub.io/2023/04/28/long%E5%92%8CLong/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>参考：Java——你知道long和Long有什么区别吗？_long long 区别_刘水镜的博客-CSDN博客</p><h1 id="java的数据类型："><a href="#java的数据类型：" class="headerlink" title="java的数据类型："></a>java的数据类型：</h1><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>long</td><td>Long</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><p>在java中有时候的运算必须是两个<a href="https://so.csdn.net/so/search?q=%E7%B1%BB%E5%AF%B9%E8%B1%A1&spm=1001.2101.3001.7020">类对象</a>之间进行的，不充许对象与数字之间进行运算。所以需要有一个对象，这个对象把数字进行了一下包装，这样这个对象就可以和另一个对象进行运算了。</p><h1 id="long与Long的关系"><a href="#long与Long的关系" class="headerlink" title="long与Long的关系"></a>long与Long的关系</h1><p>Long就是把基础类型long包装成类</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">Long</span> &#123;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">Long</span> (<span class="hljs-keyword">int</span> i)&#123;<br><span class="hljs-keyword">this</span>.i=i;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="使用时的区别"><a href="#使用时的区别" class="headerlink" title="使用时的区别"></a>使用时的区别</h1><ol><li>long l1 &#x3D;1;  long l2 &#x3D;1;</li><li>Long lc1 &#x3D; new Long(1);   Long lc2 &#x3D; 1L;</li><li>相等判断，由于long是基础类型所以可以直接l1 &#x3D;&#x3D; l2</li><li>由于Long是类，所以只能lc1.equal(l2)</li><li>long默认初始值0，Long默认初始值NULL</li></ol><p>到底是选择Long 还是long这个还得看具体环境，如果你认为这个属性不能为null,那么就用long，因为它默认初值为0，如果这个字段可以为null，那么就应该选择Long。</p>]]></content>
    
    
    <categories>
      
      <category>随心记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>portainer可视化docker</title>
    <link href="/shizhuofan.GitHub.io/2023/04/28/portainer%E5%8F%AF%E8%A7%86%E5%8C%96docker/"/>
    <url>/shizhuofan.GitHub.io/2023/04/28/portainer%E5%8F%AF%E8%A7%86%E5%8C%96docker/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>也是今天无意中发现的Portainer</p><p>之前采用的1panel和宝塔做运维可视化</p><p>现在换成docker+Portainer</p><h3 id="宝塔和1panel和portranier对比"><a href="#宝塔和1panel和portranier对比" class="headerlink" title="宝塔和1panel和portranier对比"></a>宝塔和1panel和portranier对比</h3><p>宝塔广告太多，而且不适合深入了解运维技术</p><p>1panel个人感觉无广告颜值很高，但是还是有局限，不适合深入了解运维技术</p><p>如果是后期了解了运维和docker的话，我推荐portainer</p><p>参考<a href="https://cloud.tencent.com/developer/article/1866869">Docker可视化工具——Portainer全解 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><strong>1.在本机的wsl的ubuntu执行安装命令</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#通过命令安装 Portainer</span><br><br>docker volume create portainer_data<br>docker run -d -p <span class="hljs-number">9000</span>:<span class="hljs-number">9000</span> -v <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/docker.sock:/</span>var<span class="hljs-regexp">/run/</span>docker.sock -v portainer_data:<span class="hljs-regexp">/data portainer/</span>portainer<br>cd <span class="hljs-regexp">/usr/</span>libexec<span class="hljs-regexp">/docker/</span><br>sudo ln -s docker-runc-current docker-runc<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>可以在win上面的dockerdesktop发现 启动了一个docker容器<img src="https://img-blog.csdnimg.cn/1781a70f6c5e4c3d80e02f197041686a.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><strong>2.通过本地浏览器访问：*http:&#x2F;&#x2F;服务器公网IP:9000*， 直接进入 Portainer 界面</strong></p><p><img src="https://img-blog.csdnimg.cn/dffe82c95eac4dca9d2e14f206f9f2a2.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>可以发现wsl上的docker容器都是  win下面dockerDesktop的docker</p><p><strong>这俩玩意其实就是dockerDesktop把你的win下的wsl的docker可视化了</strong></p><p><img src="https://img-blog.csdnimg.cn/2a2245e8bf474ed4b6e9a79a18fa4ff4.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> <img src="https://img-blog.csdnimg.cn/c5d7f87e5b094285b601dfb377accb27.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h3 id="wsl与docker-Desktop互通"><a href="#wsl与docker-Desktop互通" class="headerlink" title="wsl与docker Desktop互通"></a>wsl与docker Desktop互通</h3><p>实际上docker Desktop也就是跑了一个wsl，然后在这个wsl运行docker</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>外部排序&amp;&amp;败者树&amp;&amp;k路归并排序</title>
    <link href="/shizhuofan.GitHub.io/2023/04/28/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F&amp;&amp;%E8%B4%A5%E8%80%85%E6%A0%91&amp;&amp;k%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/shizhuofan.GitHub.io/2023/04/28/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F&amp;&amp;%E8%B4%A5%E8%80%85%E6%A0%91&amp;&amp;k%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p> <strong>目录</strong></p><p><a href="#%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E5%92%8C%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F">内部排序和外部排序</a></p><p><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E5%BE%97%E7%94%A8%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%EF%BC%9F">为什么外部排序得用多路归并？</a></p><p><a href="#%E6%A6%82%E8%A6%81">概要</a></p><p>[BAT 经典算法笔试题 —— 磁盘多路归并排序 - 掘金](#BAT 经典算法笔试题 —— 磁盘多路归并排序 - 掘金)</p><p><a href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B">外部排序的具体过程</a></p><p><a href="#%E6%B5%81%E7%A8%8B%E6%80%9D%E8%B7%AF%E6%A6%82%E8%BF%B0">流程思路概述</a></p><p>[ 流程具体过程](# 流程具体过程)</p><p><a href="#%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">多路归并排序的具体实现</a></p><p><a href="#%E5%86%85%E6%8E%92%E5%BA%8F---%E7%AE%80%E5%8D%95%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6%E5%8F%82%E8%80%83%E5%8A%9B%E6%89%A3">内排序—简单二路归并参考力扣</a></p><p><a href="#%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E8%B7%AF">二路归并排序的思路</a></p><p><a href="#%E5%A4%96%E6%8E%92%E5%BA%8F--k%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F--%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85">外排序–k路归并排序–相关知识补充</a></p><p><a href="#%E5%A4%96%E6%8E%92%E5%BA%8F%E9%9C%80%E8%A6%81%E6%97%B6%E9%97%B4%E4%BC%98%E5%8C%96">外排序需要时间优化</a></p><p><a href="#%E4%BC%98%E5%8C%96%E5%BD%92%E5%B9%B6%E8%BF%87%E7%A8%8B---%E5%BC%95%E5%85%A5%E8%83%9C%E8%80%85%E6%A0%91,%E8%B4%A5%E8%80%85%E6%A0%91https://www.cnblogs.com/qianye/archive/2012/11/25/2787923.html">优化归并过程—引入胜者树,败者树</a></p><p><a href="#%E8%83%9C%E8%80%85%E6%A0%91%E5%9B%BE">胜者树图</a></p><p><a href="#%E8%B4%A5%E8%80%85%E6%A0%91%E5%9B%BE">败者树图</a></p><p><a href="#%E8%B4%A5%E8%80%85%E6%A0%91%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%8Cjava%E4%BB%A3%E7%A0%81">败者树的具体实现，java代码</a></p><p>[ 辅助数据结构Chunk与Record](# 辅助数据结构Chunk与Record)</p><p>[ 败者树LoserTree，直接运行main即可](# 败者树LoserTree，直接运行main即可)</p><p><a href="#%E6%95%B4%E4%B8%AA%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81">整个外部排序的模拟实现代码</a></p><hr><h1 id="内部排序和外部排序"><a href="#内部排序和外部排序" class="headerlink" title="内部排序和外部排序"></a>内部排序和外部排序</h1><p><img src="https://img-blog.csdnimg.cn/5fe72363d676462fb151f66d3e2d14eb.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><strong>内部排序：</strong>整个的排序过程都在内存中进行排序</p><p><strong>外部排序：</strong>对大文件进行排序，无法将整个需要排序的文件复制到内存，所以会把文件存储到外村，等排序时再把数据一部分一部分地调入内存进行排序，整个排序继续多次内存和外存的交换。</p><ol><li>我们的k路归并排序，既可以作为内部排序<strong>又可以</strong>外部排序，这完全取决于使用场景，反正都行</li><li>外部排序一般都采用归并排序！</li></ol><h1 id="为什么外部排序得用多路归并？"><a href="#为什么外部排序得用多路归并？" class="headerlink" title="为什么外部排序得用多路归并？"></a>为什么外部排序得用多路归并？</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><h1 id="BAT-经典算法笔试题-——-磁盘多路归并排序-掘金"><a href="#BAT-经典算法笔试题-——-磁盘多路归并排序-掘金" class="headerlink" title="BAT 经典算法笔试题 —— 磁盘多路归并排序 - 掘金"></a><a href="https://juejin.cn/post/6844903762621005837">BAT 经典算法笔试题 —— 磁盘多路归并排序 - 掘金</a></h1><p>原文链接：<a href="https://blog.csdn.net/a574780196/article/details/122646309">https://blog.csdn.net/a574780196/article/details/122646309</a></p><p>​    假定现在有一包含大量整数的文本文件存放于磁盘中，其文件大小为10GB，而本机内存只有4GB。此时若我们要对该文件中的所有整数进行升序排序，肯定不能直接将文件中的所有数据一次性读入内存中，再使用快速、归并等排序算法对这么大规模的整数进行排序。</p><p>​    好像陷入了难题？ 我们不妨换一个思路，为何不将10GB大文件拆分为10个1GB的小文件呢？ 逐个对10个文件进行排序后，再将其写入磁盘中，此时就得到了10份已排序后的临时文件。</p><p>​    每一份文件都是一个升序序列，这时问题就转换为如何合并这10路升序序列为1路升序序列。正因为待合并的数据路数比较多，所以才有了多路归并这一说法。</p><p><strong>简单来说就是：</strong></p><p>链接：<a href="https://juejin.cn/post/6844903762621005837">https://juejin.cn/post/6844903762621005837</a></p><p>​    多路归并排序在大数据领域也是常用的算法，常用于海量数据排序。当数据量特别大时，这些数据无法被单个机器内存容纳，它需要被切分位多个集合分别由不同的机器进行内存排序（map 过程），然后再进行多路归并算法将来自多个不同机器的数据进行排序（reduce 过程），这是流式多路归并排序</p><p><img src="https://img-blog.csdnimg.cn/img_convert/83c89b668d907f1d0a474592cdb8a8b8.webp?x-oss-process=image/format,png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="外部排序的具体过程"><a href="#外部排序的具体过程" class="headerlink" title="外部排序的具体过程"></a>外部排序的具体过程</h1><p>参考天勤</p><h2 id="流程思路概述"><a href="#流程思路概述" class="headerlink" title="流程思路概述"></a>流程思路概述</h2><p><img src="https://img-blog.csdnimg.cn/d3ce9fddd6034652a8a8c6c066baf98b.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> <img src="https://img-blog.csdnimg.cn/e6945305e25a44b4a3ec3acfe1de6b30.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h2 id="流程具体过程"><a href="#流程具体过程" class="headerlink" title="流程具体过程"></a>流程具体过程</h2><p><strong>1.将外存大文件作为流输入，利用置换-选择排序算法—然后输出为多个小的已排序好的chunk（初始归并段）</strong> </p><blockquote><p>​    采用置换-选择排序算法构造初始归并段的过程;根据缓冲区大小，由外存读入记录，当记录充满缓 冲区后，选择最小的（假设升序排序）写回外存，其空缺位置由下一个读入记录来取代，输出的记录成 为当前初始归并段的一部分</p></blockquote><p><img src="https://img-blog.csdnimg.cn/0a4134b2bfd243b7ab4537f101246423.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><strong>2.用败者树归并</strong></p><ol><li>通过败者树将刚才的多个chunk归并 <ol><li>利用败者树选择所有chunk中头部最小的元素，并把它放进外存，即ls[0]对应的bq</li><li>更换刚才被选出来的元素pop，换成它的chunk的下一个元素放在bq，调整败者树</li><li>如果某个chunk空了，则剔除该chunk，然后调整败者树</li><li>循环以上1~3直到全部chunk为空</li></ol></li></ol><p><img src="https://img-blog.csdnimg.cn/646c4fce798f4ce8931592de1c4ff39f.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><strong>这一步对应的是下图过程</strong></p><p><img src="https://img-blog.csdnimg.cn/8978f709d4be4b4789a19cee18fb1f8c.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h1 id="多路归并排序的具体实现"><a href="#多路归并排序的具体实现" class="headerlink" title="多路归并排序的具体实现"></a>多路归并排序的具体实现</h1><h2 id="内排序—简单二路归并参考力扣"><a href="#内排序—简单二路归并参考力扣" class="headerlink" title="内排序—简单二路归并参考力扣"></a>内排序—简单二路归并参考<a href="https://leetcode.cn/circle/article/zeM9YK/">力扣</a></h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void merge<span class="hljs-constructor">Sort(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>)</span> &#123;<br>    <span class="hljs-comment">// 终止条件</span><br>    <span class="hljs-keyword">if</span> (l &gt;= r) return;<br>    <span class="hljs-comment">// 递归划分</span><br>    <span class="hljs-built_in">int</span> m = (l + r)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>    merge<span class="hljs-constructor">Sort(<span class="hljs-params">nums</span>, <span class="hljs-params">l</span>, <span class="hljs-params">m</span>)</span>;<br>    merge<span class="hljs-constructor">Sort(<span class="hljs-params">nums</span>, <span class="hljs-params">m</span> + 1, <span class="hljs-params">r</span>)</span>;<br>    <span class="hljs-comment">// 合并子数组</span><br>    <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">r</span> - <span class="hljs-identifier">l</span> + <span class="hljs-number">1</span>]</span>; <span class="hljs-comment">// 暂存需合并区间元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = l; k &lt;= r; k++)<br>        tmp<span class="hljs-literal">[<span class="hljs-identifier">k</span> - <span class="hljs-identifier">l</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span>;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, j = m - l + <span class="hljs-number">1</span>;       <span class="hljs-comment">// 两指针分别指向左/右子数组的首个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = l; k &lt;= r; k++) &#123;  <span class="hljs-comment">// 遍历合并左/右子数组</span><br>        <span class="hljs-keyword">if</span> (i<span class="hljs-operator"> == </span>m - l + <span class="hljs-number">1</span>)<br>            nums<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span> = tmp<span class="hljs-literal">[<span class="hljs-identifier">j</span><span class="hljs-operator">++</span>]</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j<span class="hljs-operator"> == </span>r - l + <span class="hljs-number">1</span><span class="hljs-operator"> || </span>tmp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt;= tmp<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>)<br>            nums<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span> = tmp<span class="hljs-literal">[<span class="hljs-identifier">i</span><span class="hljs-operator">++</span>]</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            nums<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span> = tmp<span class="hljs-literal">[<span class="hljs-identifier">j</span><span class="hljs-operator">++</span>]</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用</span><br><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> nums = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span> &#125;;<br>merge<span class="hljs-constructor">Sort(<span class="hljs-params">nums</span>, 0, <span class="hljs-params">len</span>(<span class="hljs-params">nums</span>)</span> - <span class="hljs-number">1</span>);<br><br>作者：Krahets<br>链接：https:<span class="hljs-comment">//leetcode.cn/circle/article/zeM9YK/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="二路归并排序的思路"><a href="#二路归并排序的思路" class="headerlink" title="二路归并排序的思路"></a>二路归并排序的思路</h1><p><img src="https://img-blog.csdnimg.cn/0a601e7708c545058bbf8a1b036f2788.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><img src="https://img-blog.csdnimg.cn/052bae8a2ac7433c96ce9c2abf6e1ccb.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>​            内排序—–简单2路归并图</p><p><img src="https://img-blog.csdnimg.cn/12952a29b47d46018b78c388b98c7e71.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>​            内排序—–简单5路归并图</p><h1 id="外排序–k路归并排序–相关知识补充"><a href="#外排序–k路归并排序–相关知识补充" class="headerlink" title="外排序–k路归并排序–相关知识补充"></a>外排序–k路归并排序–相关知识补充</h1><h2 id="外排序需要时间优化"><a href="#外排序需要时间优化" class="headerlink" title="外排序需要时间优化"></a>外排序需要时间优化</h2><p>外部排序的总时间&#x3D;内部排序所需的时间+外存信息读写的时间+内部归并所需的时间</p><p>显然，外存信息读写的时间远大于内部排序和内部归并的时间，因此应适当减少I&#x2F;O次数</p><p>可以适当,增大归并路数，可减少归并趟数，进而减少总的磁盘I&#x2F;O次数</p><h2 id="优化归并过程—引入胜者树-败者树"><a href="#优化归并过程—引入胜者树-败者树" class="headerlink" title="优化归并过程—引入胜者树,败者树"></a>优化归并过程—引入胜者树,败者树</h2><p>不能用普通的内部归并-&gt;引入败者树</p><p><img src="https://img-blog.csdnimg.cn/646c4fce798f4ce8931592de1c4ff39f.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><ol><li>一般外部排序用的是败者树</li><li>胜者树的优点：一个选手的值改变了，可以很方便的修改当前胜者树</li><li>败者树可以说是胜者树的一个变种，是胜者树的一种优化，当一个选手的值改变了，比败者树可以很方便的修改当前胜者树</li><li><strong>历史上：外部排序先用的最小堆，然后优化变种成了胜者树，再优化变种成了败者树</strong></li></ol><p> <strong>理解胜者树和败者树的关键：</strong></p><p><strong>胜者树和败者树都是拿赢家去比下一轮，但是不同的是，胜者树的中间结点记录的是胜者的标号；而败者树的中间结点记录的败者的标号。（败者树虽然记录的是败者标号，但是也依然会把胜者传给下一轮去比）</strong></p><h2 id="胜者树图"><a href="#胜者树图" class="headerlink" title="胜者树图"></a>胜者树图</h2><p><img src="https://img-blog.csdnimg.cn/de0b3ac7bd0e4d16acc0242a3040bc16.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h2 id="败者树图"><a href="#败者树图" class="headerlink" title="败者树图"></a>败者树图</h2><p><img src="https://img-blog.csdnimg.cn/80931a25d5e64f26925d15328a9e8fa9.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><img src="https://img-blog.csdnimg.cn/b10d088cd36441a0a2b3cc9c46a24472.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p> <img src="https://img-blog.csdnimg.cn/497a77b2a11246169e0fa45c4dddfd06.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑<a href="https://masterwangzx.com/2019/11/30/outer-sort/#%E8%B4%A5%E8%80%85%E6%A0%91">外排序算法 — WZX’s Blog</a></p><h1 id="败者树的具体实现，java代码"><a href="#败者树的具体实现，java代码" class="headerlink" title="败者树的具体实现，java代码"></a>败者树的具体实现，java代码</h1><p><img src="https://img-blog.csdnimg.cn/71786ecbeef34671a0bd3c774e28bb99.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><ul><li>这个按照这个图顺序定义b0,b1~b4的顺序，b0必须从第一个最小叶子结点作为b0，才符合b_parnet &#x3D; (b_index+b_size)&#x2F;2 </li><li></li></ul><p>败者树的Java实现</p><p>参考<a href="https://blog.csdn.net/bhq2010/article/details/8760356">败者树的Java实现_solari_bian的博客-CSDN博客</a></p><h3 id="辅助数据结构Chunk与Record"><a href="#辅助数据结构Chunk与Record" class="headerlink" title="辅助数据结构Chunk与Record"></a>辅助数据结构Chunk与Record</h3><p>Record就是Chunk流里面具体某个东西，这里以数值a作为排序依据</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 记录类，包含一个整数型属性A和一个字符串型属性B</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Record</span> implements Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> b;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Record</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">String</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.a = a;<br>        <span class="hljs-keyword">this</span>.b = b;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">getA</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">getB</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br><br>    @<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Record&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;a=&quot;</span> + a +<br>                <span class="hljs-string">&quot;, b=&#x27;&quot;</span> + b + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">//写compareTo</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Record o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.a &gt; o.a) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.a &lt; o.a) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> Chunk就是通过置换-选择排序，得出来的一段已排序好的初始归并段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;h4&gt;szf-lab2&lt;/h4&gt;</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : Fars</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> : 2023-04-27 23:31</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chunk</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chunk</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chunk</span><span class="hljs-params">(<span class="hljs-type">int</span> chunkId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.chunkId = chunkId;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chunk</span><span class="hljs-params">(List&lt;Record&gt; recordList, <span class="hljs-type">int</span> chunkId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.recordList = recordList;<br>        <span class="hljs-built_in">this</span>.chunkId = chunkId;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">chunkId</span> <span class="hljs-operator">=</span>-<span class="hljs-number">1</span>;<span class="hljs-comment">//未赋值默认为-1</span><br>    <span class="hljs-keyword">private</span> List&lt;Record&gt; recordList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//实现add</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Record record)</span>&#123;<br>        recordList.add(record);<br>    &#125;<br>    <span class="hljs-comment">//实现poll</span><br>    <span class="hljs-keyword">public</span> Record <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> recordList.remove(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Record&gt; <span class="hljs-title function_">getRecordList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> recordList;<br>    &#125;<br>    <span class="hljs-comment">//实现getSize</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> recordList.size();<br>    &#125;<br>    <span class="hljs-comment">//实现compareTo</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Chunk chunk)</span>&#123;<br>        <span class="hljs-type">Record</span> <span class="hljs-variable">record1</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.recordList.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">Record</span> <span class="hljs-variable">record2</span> <span class="hljs-operator">=</span> chunk.recordList.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> record1.compareTo(record2);<br>    &#125;<br>    <span class="hljs-comment">//实现isEmpty</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> recordList.isEmpty();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Chunk&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;chunkId=&quot;</span> + chunkId +<br>                <span class="hljs-string">&quot;, recordList=&quot;</span> + recordList +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getChunkId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> chunkId;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="败者树LoserTree，直接运行main即可"><a href="#败者树LoserTree，直接运行main即可" class="headerlink" title="败者树LoserTree，直接运行main即可"></a>败者树LoserTree，直接运行main即可</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.print.attribute.IntegerSyntax;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoserTree</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] ls = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 以顺序存储方式保存所有非叶子结点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;Chunk&gt; leaves = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 叶子节点</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LoserTree</span><span class="hljs-params">(ArrayList&lt;Chunk&gt; chunks)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.leaves = chunks;<span class="hljs-comment">// 叶子结点</span><br>        <span class="hljs-built_in">this</span>.size = chunks.size();<span class="hljs-comment">// 叶子结点个数 = 块数 = ls个数</span><br>        <span class="hljs-built_in">this</span>.ls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size];<span class="hljs-comment">//ls个数 = 块数 = 叶子结点个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i)<br>        &#123;<br>            ls[i] = -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>        &#123;<br>            adjust(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">     * @Description: 从chunks中删除第s块，并调整败者树</span><br><span class="hljs-comment">     * @param s </span><br><span class="hljs-comment">     * @return: void </span><br><span class="hljs-comment">     * @Author: Fars</span><br><span class="hljs-comment">     * @Date: 2023/4/27 23:28</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">del</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span><br>    &#123;<br>        leaves.remove(s);<br>        size--;<br>        ls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[size];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i)<br>        &#123;<br>            ls[i] = -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>        &#123;<br>            adjust(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Chunk leaf, <span class="hljs-type">int</span> s)</span><br>    &#123;<br>        leaves.set(s, leaf);<span class="hljs-comment">// 调整叶子结点</span><br>        adjust(s);<span class="hljs-comment">// 调整非叶子结点</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Chunk <span class="hljs-title function_">getLeaf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> leaves.get(i);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getWinnerChunkIndex</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> ls[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Chunk <span class="hljs-title function_">getWinnerChunk</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> leaves.get(ls[<span class="hljs-number">0</span>]);<br>    &#125;<br><span class="hljs-comment">//    public void adjust(int leafIndex)</span><br><span class="hljs-comment">//    &#123;</span><br><span class="hljs-comment">//        // s指向当前的值最小的叶子结点（胜者）</span><br><span class="hljs-comment">//        int parent = (leafIndex + size) / 2;// parent是leafIndex的双亲</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        while (parent &gt; 0)// 沿从叶子到根的路径比较，直到根结点</span><br><span class="hljs-comment">//        &#123;</span><br><span class="hljs-comment">//            if (leafIndex &gt;= 0 &amp;&amp; (ls[parent] == -1 || leaves.get(leafIndex).compareTo(leaves.get(ls[parent])) &gt; 0))</span><br><span class="hljs-comment">//            &#123;</span><br><span class="hljs-comment">//                // 将树中的当前结点指向其子树中值最小的叶子</span><br><span class="hljs-comment">//                int tmp = leafIndex;</span><br><span class="hljs-comment">//                leafIndex = ls[parent];</span><br><span class="hljs-comment">//                ls[parent] = tmp;</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjust</span><span class="hljs-params">(<span class="hljs-type">int</span> leafIndex)</span><br>    &#123;<br>        <span class="hljs-comment">// s指向当前的值最小的叶子结点（胜者）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (leafIndex + size) / <span class="hljs-number">2</span>;<span class="hljs-comment">// parent是leafIndex的双亲</span><br><br>        <span class="hljs-keyword">while</span> (parent &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">// 沿从叶子到根的路径比较，直到根结点</span><br>        &#123;<br>            <span class="hljs-type">int</span> winnerIndex;<br>            <span class="hljs-type">int</span> loserIndex;<br>            <span class="hljs-comment">//如果是父节点ls[parent]为-1,代表还没有比赛过，应该要和兄弟比赛</span><br>            <span class="hljs-keyword">if</span>(ls[parent] == -<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span> (leaves.get(leafIndex).compareTo(leaves.get(leafIndex - <span class="hljs-number">1</span>)) &lt; <span class="hljs-number">0</span>)&#123;<br>                    winnerIndex = leafIndex;<br>                    loserIndex = leafIndex - <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    winnerIndex = leafIndex - <span class="hljs-number">1</span>;<br>                    loserIndex = leafIndex;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果s战胜了父亲节点代表的leaf ( leave.get(s) &lt; leaves.get(ls[parent]) )，那么胜者是s</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(leaves.get(leafIndex).compareTo(leaves.get(ls[parent])) &lt; <span class="hljs-number">0</span>)&#123;<br>                winnerIndex= leafIndex;<br>                loserIndex = ls[parent];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                winnerIndex = ls[parent];<br>                loserIndex = leafIndex;<br>            &#125;<br>            <span class="hljs-comment">//将败者索引放到父亲节点</span><br>            ls[parent] = loserIndex;<br>            <span class="hljs-comment">//将胜者继续向上比较</span><br>            leafIndex = winnerIndex;<br>            parent /= <span class="hljs-number">2</span>;<br>        &#125;<br>        ls[<span class="hljs-number">0</span>] = leafIndex;<span class="hljs-comment">// 树根指向胜者</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//给定示例输入数据</span><br>        ArrayList&lt;Chunk&gt; chunks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Chunk&gt;();<br>        <span class="hljs-type">Chunk</span> <span class="hljs-variable">chunk1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chunk</span>(<span class="hljs-number">0</span>);<br>        chunk1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Record</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;record_1&quot;</span>));<br>        chunk1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Record</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&quot;record_7&quot;</span>));<br>        chunk1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Record</span>(<span class="hljs-number">8</span>,<span class="hljs-string">&quot;record_8&quot;</span>));<br>        <span class="hljs-type">Chunk</span> <span class="hljs-variable">chunk2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chunk</span>(<span class="hljs-number">1</span>);<br>        chunk2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Record</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;record_4&quot;</span>));<br>        chunk2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Record</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;record_5&quot;</span>));<br>        chunk2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Record</span>(<span class="hljs-number">6</span>,<span class="hljs-string">&quot;record_6&quot;</span>));<br>        chunks.add(chunk1);<br>        chunks.add(chunk2);<br>        <span class="hljs-comment">//利用败者树排序</span><br>        <span class="hljs-type">LoserTree</span> <span class="hljs-variable">loserTree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoserTree</span>(chunks);<br>        <span class="hljs-comment">//输出排序结果</span><br>        System.out.println(<span class="hljs-string">&quot;排序结果：&quot;</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前winner代表的chunkIndex = &quot;</span> + loserTree.getWinnerChunkIndex());<br>            System.out.println(<span class="hljs-string">&quot;该chunk = &quot;</span> + loserTree.getWinnerChunk().toString());<br>            System.out.println(<span class="hljs-string">&quot;该chunk的块首元素 = &quot;</span> + loserTree.getWinnerChunk().poll());<br>            <span class="hljs-type">int</span> <span class="hljs-variable">chunkIndex</span> <span class="hljs-operator">=</span> loserTree.getWinnerChunkIndex();<br>            <span class="hljs-type">Chunk</span> <span class="hljs-variable">winnerChunk</span> <span class="hljs-operator">=</span> loserTree.getWinnerChunk();<br>            <span class="hljs-comment">//如果该chunk为空，则去除该chunk</span><br>            <span class="hljs-keyword">if</span> (loserTree.getWinnerChunk().isEmpty())<br>            &#123;<br>                loserTree.del(chunkIndex);<br>                System.out.println(<span class="hljs-string">&quot;删除chunk，其Id:&quot;</span> + winnerChunk.getChunkId());<br>                <span class="hljs-keyword">if</span>(chunks.size() == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">else</span><span class="hljs-comment">//否则调整败者树</span><br>                loserTree.adjust(chunkIndex);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="整个外部排序的模拟实现代码"><a href="#整个外部排序的模拟实现代码" class="headerlink" title="整个外部排序的模拟实现代码"></a>整个外部排序的模拟实现代码</h1><p>有些许bug，应该无伤大雅</p><p>代码太多，就不放上来了，请看github</p><p><a href="https://github.com/944613709/external-sorting-of-k-way-multi-way-merge-sorting">外部排序完整代码<img src="https://csdnimg.cn/release/blog_editor_html/release2.2.5/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=N3I4" alt=" ">https://github.com/944613709/external-sorting-of-k-way-multi-way-merge-sorting</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>外部排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode刷题琐碎笔记</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/LeetCode/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/LeetCode/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h2><pre><code class="hljs">  访问修饰符public,private,protected    类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。</code></pre><p>总结如下表</p><img src="/shizhuofan.GitHub.io/2023/04/21/LeetCode/Center.png" class title="img"><p>版权声明：本文为CSDN博主「所谓简爱」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_33342248/article/details/54090038">https://blog.csdn.net/qq_33342248/article/details/54090038</a></p><h2 id="1-二分查找法"><a href="#1-二分查找法" class="headerlink" title="1.二分查找法"></a>1.二分查找法</h2><p>思路一：</p><p><strong>while(left&lt;&#x3D;right)</strong></p><p><strong>直接找出目标元素</strong></p><p>public class Solution {</p><pre><code class="hljs">// 「力扣」第 704 题：二分查找  public int search(int[] nums, int target) &#123;    int len = nums.length;    int left = 0;    int right = len - 1;    // 目标元素可能存在在区间 [left, right]    while (left &lt;= right) &#123;        // 推荐的写法是 int mid = left + (right - left) / 2;        int mid = (left + right) / 2;        if (nums[mid] == target) &#123;            return mid;        &#125; else if (nums[mid] &lt; target) &#123;            // 目标元素可能存在在区间 [mid + 1, right]            left = mid + 1;        &#125; else &#123;            // 目标元素可能存在在区间 [left, mid - 1]            right = mid - 1;        &#125;    &#125;    return -1;&#125;</code></pre><p>}</p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/xsz9zc/">https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/xsz9zc/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><strong>2.排除不可能区间</strong></p><p>思路二时候</p><p><strong>1.while(left&lt;right)</strong></p><p><strong>2.如果有left&#x3D;mid,则向上取整mid &#x3D; (left+right+1) &#x2F;2</strong></p><p>public class Solution {</p><pre><code class="hljs">// 「力扣」第 704 题：二分查找public int search(int[] nums, int target) &#123;    int len = nums.length;    int left = 0;    int right = len - 1;    // 目标元素可能存在在区间 [left, right]    while (left &lt; right) &#123;        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) &#123;            // 下一轮搜索区间是 [mid + 1, right]            left = mid + 1;        &#125; else &#123;            // 下一轮搜索区间是 [left, mid]            right = mid;        &#125;    &#125;    if (nums[left] == target) &#123;        return left;    &#125;    return -1;&#125;</code></pre><p>}</p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/xs41qg/">https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/xs41qg/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="2-HashMap"><a href="#2-HashMap" class="headerlink" title="2.HashMap"></a>2.HashMap</h2><p>时间复杂度o（1）</p><p>因为是数组</p><h2 id="3-排序·"><a href="#3-排序·" class="headerlink" title="3.排序·"></a>3.排序·</h2><h3 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1.选择排序"></a>1.选择排序</h3><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h3><p>public class Solution {</p><pre><code class="hljs">// 「力扣」第 912 题：排序数组public int[] sortArray(int[] nums) &#123;    int len = nums.length;    // 循环不变量：将 nums[i] 插入到区间 [0, i) 使之成为有序数组    for (int i = 1; i &lt; len; i++) &#123;        for (int j = i; j &gt; 0; j--) &#123;            if (nums[j - 1] &gt; nums[j]) &#123;                swap(nums, j - 1, j);            &#125; else &#123;                break;            &#125;        &#125;    &#125;    return nums;&#125;private void swap(int[] nums, int index1, int index2) &#123;    int temp = nums[index1];    nums[index1] = nums[index2];    nums[index2] = temp;&#125;</code></pre><p>}</p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/556rgm/">https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/556rgm/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3.希尔排序"></a>3.希尔排序</h3><p>升级版的插入排序</p><p>import java.util.Arrays;</p><p>public class Solution {</p><pre><code class="hljs">// 「力扣」第 912 题：排序数组// 希尔排序，使用 Shell 建议的序列 N/2,N/4,...,2,1public int[] sortArray(int[] nums) &#123;    int len = nums.length;    int h = 1;    int gap = len / 2;    while (gap &gt;= 1) &#123;        // 缩小增量的插入排序        for (int i = h; i &lt; len; i++) &#123;            insertionForDelta(nums, gap, i);        &#125;        gap /= 2;    &#125;    return nums;&#125;/** * 将 nums[end] 插入到对应分组的正确位置上，其实就是将原来 1 的部分改成 gap * * @param nums * @param gap  间隔 * @param end */private void insertionForDelta(int[] nums, int gap, int end) &#123;    int temp = nums[end];    int j = end;    while (j &gt;= gap &amp;&amp; nums[j - gap] &gt; temp) &#123;        nums[j] = nums[j - gap];        j -= gap;    &#125;    nums[j] = temp;&#125;</code></pre><p>}</p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55k961/">https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55k961/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h3 id="4-归并"><a href="#4-归并" class="headerlink" title="4.归并"></a>4.归并</h3><p>编写递归函数，通常要遵守下面的编写模式：</p><p><strong>先写递归终止条件；</strong><br><strong>再假定小规模的问题已经解决（是通过递归解决的）；</strong><br><strong>最后处理小规模问题已经解决的情况下，与当前问题之间的逻辑联系。</strong></p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55ghq7/">https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55ghq7/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> sort<span class="hljs-constructor">Array(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> len = nums.length;<br>        merge<span class="hljs-constructor">Sort(<span class="hljs-params">nums</span>, 0, <span class="hljs-params">len</span> - 1)</span>;<br>        return nums;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> void merge<span class="hljs-constructor">Sort(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(left<span class="hljs-operator"> == </span>right) &#123;<br>            return;<br>        &#125;<br>        <span class="hljs-built_in">int</span> mid = left + (right - left)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>        merge<span class="hljs-constructor">Sort(<span class="hljs-params">nums</span>, <span class="hljs-params">left</span>, <span class="hljs-params">mid</span>)</span>;<br>        merge<span class="hljs-constructor">Sort(<span class="hljs-params">nums</span>, <span class="hljs-params">mid</span> + 1, <span class="hljs-params">right</span>)</span>;<br>        merge<span class="hljs-constructor">OfTwoSortedArray(<span class="hljs-params">nums</span>, <span class="hljs-params">left</span>, <span class="hljs-params">mid</span>, <span class="hljs-params">right</span>)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> void merge<span class="hljs-constructor">OfTwoSortedArray(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">mid</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span>)</span> &#123;<br>        <span class="hljs-comment">// 合并后数组长度</span><br>        <span class="hljs-built_in">int</span> len = right - left + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 定义新的临时数组</span><br>        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">len</span>]</span>;<br><br>        <span class="hljs-built_in">int</span> i = left;<br>        <span class="hljs-built_in">int</span> j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 从左到右比较两数组的大小，将较小的值添加到temp中</span><br>        <span class="hljs-keyword">while</span>(i &lt;= mid<span class="hljs-operator"> &amp;&amp; </span>j &lt;= right) &#123;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt;= nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>) &#123;<br>                temp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">i</span><span class="hljs-operator">++</span>]</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                temp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">j</span><span class="hljs-operator">++</span>]</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 剩下的数组元素，可以依次赋值</span><br>        <span class="hljs-keyword">while</span>(i &lt;= mid) &#123;<br>            temp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">i</span><span class="hljs-operator">++</span>]</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j &lt;= right) &#123;<br>            temp<span class="hljs-literal">[<span class="hljs-identifier">k</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">j</span><span class="hljs-operator">++</span>]</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将temp排好序的依次赋值给nums</span><br>        <span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> a = left; a &lt;= right; a++) &#123;<br>            nums<span class="hljs-literal">[<span class="hljs-identifier">a</span>]</span> = temp<span class="hljs-literal">[<span class="hljs-identifier">b</span><span class="hljs-operator">++</span>]</span>;<br>        &#125;<br>    &#125;<br><br>作者：豚豚<br>链接：https:<span class="hljs-comment">//leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55ghq7/?discussion=ngEXjW</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>优化 1：在小区间里使用插入排序<br>如果区间里只有 22 个元素，例如 [4, 3][4,3]，只要把它们直接交换一下位置就可以了。但是这种情况还太特殊，对于区间里有 33 个元素、44 个元素的情况就不奏效了，一个更直接且有效的做法是：在小区间里使用插入排序。</p><p>事实上，在归并排序的子过程里，可以使用插入排序的原因是：</p><p>首先，操作的指令数更少；<br>其次，插入排序也是稳定的排序算法，修改成插入排序并不影响归并排序的稳定性。<br>当然这个子区间不能很大，子区间在多长的时候转而使用插入排序，这需要通过实验才能知道。学习过机器学习的朋友，就会知道它是一个超参数，目前 Java 语言的库函数将它定义成 4747。</p><p>优化 2：子区间本身有序则无需归并<br>如果这个子区间本身就是有序的，我们没有必要执行归并的过程。</p><p>例如：[1, 3, 4, 5, 6, 7, 8, 9]。 在上一节介绍的分治算法的时候，需要将它一分为二，前半部分是 [1, 3, 4, 5]，后半部分是 [6, 7, 8, 9]，事实上这一步是没有必要的。</p><p><strong>优化 3：在整个归并的过程中，使用同一个辅助数组</strong><br>上一节的做法，我们每次归并之前都得创建一个临时数组，在 Java 语言中，使用完以后就会被垃圾回收机制回收。</p><p><strong>这个频繁创建数组和销毁数组的过程，有一定性能消耗；</strong><br>不管是复制数组，还是把归并的结果赋值回去，都得计算偏移量。而事实上，当我们全局使用一个临时数组用于归并的时候，可以省略偏移量的计算。<br>下面我们就从代码层面讲解如何优化归并排序。</p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55gb35/">https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55gb35/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h4 id="优化归并"><a href="#优化归并" class="headerlink" title="优化归并"></a>优化归并</h4><p>public class Solution {</p><pre><code class="hljs">/** * 列表大小等于或小于该大小，将优先于 mergesort 使用插入排序 */private static final int INSERTION_SORT_THRESHOLD = 47;public int[] sortArray(int[] nums) &#123;    int len = nums.length;    // 优化 3：全局使用一份临时数组    int[] temp = new int[len];    mergeSort(nums, 0, len - 1, temp);    return nums;&#125;private void mergeSort(int[] nums, int left, int right, int[] temp) &#123;    // 优化 1：小区间使用插入排序    if (right - left &lt;= INSERTION_SORT_THRESHOLD) &#123;        insertionSort(nums, left, right);        return;    &#125;    int mid = left + (right - left) / 2;    mergeSort(nums, left, mid, temp);    mergeSort(nums, mid + 1, right, temp);    // 优化 2：数组已经有序的情况下，不再合并    if (nums[mid] &lt;= nums[mid + 1]) &#123;        return;    &#125;    mergeOfTwoSortedArray(nums, left, mid, right, temp);&#125;private void mergeOfTwoSortedArray(int[] nums, int left, int mid, int right, int[] temp) &#123;    for (int i = left; i &lt;= right; i++) &#123;        temp[i] = nums[i];    &#125;    int i = left;    int j = mid + 1;    for (int k = left; k &lt;= right; k++) &#123;        if (i == mid + 1) &#123;            nums[k] = temp[j];            j++;        &#125; else if (j == right + 1) &#123;            nums[k] = temp[i];            i++;        &#125; else if (temp[i] &lt;= temp[j]) &#123;            // 注意：这里一定要写成 &lt;=，否则就变成了非稳定排序            nums[k] = temp[i];            i++;        &#125; else &#123;            nums[k] = temp[j];            j++;        &#125;    &#125;&#125;/** * 对数组给定的部分使用插入排序 * * @param arr   给定数组 * @param left  左边界，能取到 * @param right 右边界，能取到 */private void insertionSort(int[] arr, int left, int right) &#123;    for (int i = left + 1; i &lt;= right; i++) &#123;        int temp = arr[i];        int j = i;        while (j &gt; left &amp;&amp; arr[j - 1] &gt; temp) &#123;            arr[j] = arr[j - 1];            j--;        &#125;        arr[j] = temp;    &#125;&#125;</code></pre><p>}</p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55gb35/">https://leetcode.cn/leetbook/read/learning-algorithms-with-leetcode/55gb35/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="滑动窗口（双指针）"><a href="#滑动窗口（双指针）" class="headerlink" title="滑动窗口（双指针）"></a>滑动窗口（双指针）</h2><p>时间复杂度：O(n)</p><p>right一直往右移动</p><p>如果碰上条件，left就收缩</p><p>所以是</p><p>时间复杂度是o（n）</p><p>空间复杂度是O（1）</p><p>1.从暴力解法优化，类似于剪枝法从O(n2)-&gt;O(n1)</p><p>2.利用的是left固定住之后，right一直向右，只要遇上了重复字符，当前的res就再也不可能变大，于是可以left当前值的循环可以跳过，可以直接left+1</p><p>3.滑动窗口问题如果一下子没有思路，先考虑暴力解法，然后再纸上写写画画，进而考虑优化的解法，通常考虑「剪枝」或者「空间换时间」。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> length<span class="hljs-constructor">OfLongestSubstring(String <span class="hljs-params">s</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> len  =s.length<span class="hljs-literal">()</span>;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            return <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//[left,right]</span><br>        <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> right = <span class="hljs-number">0</span>;<br>        HashMap&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>        <span class="hljs-keyword">for</span>(right = <span class="hljs-number">0</span>;right&lt;len;right++)<br>        &#123;<br>            <span class="hljs-comment">// right右移</span><br>            map.put(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>,map.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">right</span>)</span>,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br><br>            <span class="hljs-comment">//如果需要，则收缩</span><br>            <span class="hljs-keyword">while</span>(left &lt; right<span class="hljs-operator"> &amp;&amp; </span>map.get(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">right</span>)</span>)&gt;=<span class="hljs-number">2</span>)<br>            &#123;<br>                map.put(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>,map.get(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">left</span>)</span>)-<span class="hljs-number">1</span>);<br>                left++;<br>            &#125;<br>            res= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(res,right-left+<span class="hljs-number">1</span>);<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs awk">public class Solution &#123;<br><br>    public String minWindow(String s, String t) &#123;<br>        <span class="hljs-regexp">//</span> 同方向移动，起始的时候，都位于 <span class="hljs-number">0</span>，表示我们定义搜索区间为 [left, right) ，此时区间为空区间<br>        int left = <span class="hljs-number">0</span>;<br>        int right = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (right &lt; sLen) &#123;<br><br>            <span class="hljs-keyword">if</span> ( 在右移的过程中检测是否满足条件 ) &#123;<br>                <span class="hljs-regexp">//</span> 对状态做修改，好让程序在后面检测到满足条件<br>            &#125;<br><br>            <span class="hljs-regexp">//</span> 右边界右移 <span class="hljs-number">1</span> 格<br>            right++;<br><br>            <span class="hljs-keyword">while</span> ( 满足条件 ) &#123;<br><br>                <span class="hljs-regexp">//</span> ① 走到这里是满足条件的，左边界逐渐逐渐左移，可以取最小值<br><br>                <span class="hljs-keyword">if</span> ( 在左移的过程中检测是否不满足条件 ) &#123;<br>                    <span class="hljs-regexp">//</span> 对状态做修改，好让程序在后面检测到不满足条件<br>                &#125;<br><br>                <span class="hljs-regexp">//</span> 左边界左移 <span class="hljs-number">1</span> 格<br>                left++;<br>            &#125;<br>            <span class="hljs-regexp">//</span> ② 走到这里是不满足条件的，右边界逐渐右移，可以取最大值<br>        &#125;<br>        return 需要的结果变量;<br>    &#125;<br>&#125;<br><br>作者：liweiwei1419<br>链接：https:<span class="hljs-regexp">//</span>leetcode.cn<span class="hljs-regexp">/leetbook/</span>read<span class="hljs-regexp">/learning-algorithms-with-leetcode/</span>x1vsvd/<br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public <span class="hljs-built_in">int</span> numRescueBoats(<span class="hljs-built_in">int</span>[] people, <span class="hljs-built_in">int</span> limit) &#123;<br>        Arrays.sort(people);<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span> = people.length;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = <span class="hljs-built_in">len</span>-<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        while(<span class="hljs-built_in">left</span>&lt;<span class="hljs-built_in">right</span>)<br>        &#123;<br>            //最轻的可以带上最重的<br>            <span class="hljs-built_in">if</span>(people[<span class="hljs-built_in">left</span>]+people[<span class="hljs-built_in">right</span>] &lt;=limit)<br>            &#123;<br>                <span class="hljs-built_in">left</span>++;<br>                <span class="hljs-built_in">right</span>--;<br>                res++;<br>            &#125;<br>            //最轻的带不上最重的<br>            else//最重的只能自己走<br>            &#123;<br>                <span class="hljs-built_in">right</span>--;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">if</span>(<span class="hljs-built_in">left</span>==<span class="hljs-built_in">right</span>)<br>        &#123;<br>            res++;<br>        &#125;<br>        return res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><img src="/shizhuofan.GitHub.io/2023/04/21/LeetCode/image-20230201112153877.png" class title="image-20230201112153877"><img src="/shizhuofan.GitHub.io/2023/04/21/LeetCode/image-20230201112208420.png" class title="image-20230201112208420">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Sprigcloud个人学习笔记</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/SpringCloud/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/SpringCloud/</url>
    
    <content type="html"><![CDATA[<h1 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h1><p><strong>在yml中某个具体属性值前面要空格！！！</strong></p><p> application:</p><p>  name:  <strong>（这里要空格）</strong>orderservice</p><p>小心这个配置</p><p><img src="https://farsblog.oss-cn-beijing.aliyuncs.com/PicGo/202304242356283.png" alt="image-20220831203412409"></p><p>这个Data Id需要带后缀.yaml</p><p><strong>是.yaml不是.yml</strong></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringCloud/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220831211715567.png" alt="image-20220831211715567"></p><h1 id="同源与跨域"><a href="#同源与跨域" class="headerlink" title="同源与跨域"></a>同源与跨域</h1><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringCloud/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220901102506106.png" alt="image-20220901102506106"></p><p><strong>同源</strong>：协议，端口，域名都得一样！！！！才叫同源</p><h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><h2 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h2><p>​我评价不好用</p><h1 id="注册中心Eureka"><a href="#注册中心Eureka" class="headerlink" title="注册中心Eureka"></a>注册中心Eureka</h1><p><img src="https://farsblog.oss-cn-beijing.aliyuncs.com/PicGo/202304242357302.png" alt="image-20220829214241081"></p><p><img src="https://farsblog.oss-cn-beijing.aliyuncs.com/PicGo/202304242358428.png" alt="image-20220829214326675"></p><p><img src="https://farsblog.oss-cn-beijing.aliyuncs.com/PicGo/202304242358670.png" alt="image-20220829214403631"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>合理分配任务，保证所有后端服务器都将性能充分发挥，从而保持服务器集群的整体性能最优，这就是负载均衡问题</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p><img src="https://farsblog.oss-cn-beijing.aliyuncs.com/PicGo/202304242358705.png" alt="image-20220829215026960"></p><p><img src="https://farsblog.oss-cn-beijing.aliyuncs.com/PicGo/202304242358960.png" alt="image-20220830110854507">![image-2022083011085450</p><h1 id="注册中心nacos"><a href="#注册中心nacos" class="headerlink" title="注册中心nacos"></a>注册中心nacos</h1><p>和eureka类似但是我更推荐Nacos，还有dubbo</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot个人学习笔记</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/SpringBoot/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="1注解常用知识点"><a href="#1注解常用知识点" class="headerlink" title="1注解常用知识点"></a>1注解常用知识点</h2><h4 id="slj4"><a href="#slj4" class="headerlink" title="@slj4"></a>@slj4</h4><p>加在applicaiton（）</p><p>就可以使用log.info()用于日志</p><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>按名字注入</p><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><p>按类型注入</p><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> R&lt;Employee&gt; <span class="hljs-title function_">login</span><span class="hljs-params">(HttpServletRequest request,<span class="hljs-meta">@RequestBody</span> Employee employee)</span><br></code></pre></td></tr></table></figure><p>接受前端页面传递过来的数据，根据同名字</p><p><strong>而Body请求体只存在于POST请求</strong></p><h4 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">employee.set<span class="hljs-constructor">Password(DigestUtils.<span class="hljs-params">md5DigestAsHex</span>(<span class="hljs-string">&quot;123456&quot;</span>.<span class="hljs-params">getBytes</span>()</span>));<br></code></pre></td></tr></table></figure><h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4><p>@Bean是放在方法的注释上了，因为它很明确地告诉被注释的方法，你给我产生一个Bean，然后交给Spring容器，剩下的你就别管了</p><p>记住，@Bean就放在方法上，就是让方法去产生一个Bean，然后交给Spring容器。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>       <span class="hljs-meta">@Bean</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-title class_">AccountDao</span> <span class="hljs-title function_">accountDao</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountDao</span>();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>不知道大家有没有想过，用于注册Bean的注解的有那么多个，为何还要出现@Bean注解？</p><p>原因很简单：类似@Component , @Repository , @ Controller , @Service 这些注册Bean的注解存在局限性，只能局限作用于自己编写的类，如果是一个jar包第三方库要加入IOC容器的话，这些注解就手无缚鸡之力了，是的，@Bean注解就可以做到这一点！当然除了@Bean注解能做到还有@Import也能把第三方库中的类实例交给spring管理，而且@Import更加方便快捷，只是@Import注解并不在本篇范围内，这里就不再概述。</p><p>使用@Bean注解的另一个好处就是能够动态获取一个Bean对象，能够根据环境不同得到不同的Bean对象<br>————————————————<br>版权声明：本文为CSDN博主「宜春」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_44543508/article/details/103718958">https://blog.csdn.net/qq_44543508/article/details/103718958</a></p><h4 id="在方法前注解"><a href="#在方法前注解" class="headerlink" title="在方法前注解"></a>在方法前注解</h4><p>让spring在需要的时候，通过自行自动调用这个方法，自行自动创建对象，</p><h3 id="Spring注解的理解"><a href="#Spring注解的理解" class="headerlink" title="Spring注解的理解"></a>Spring注解的理解</h3><p>参考链接： <a href="https://blog.csdn.net/qq_44543508/article/details/103718958">https://blog.csdn.net/qq_44543508/article/details/103718958</a></p><p>一类注解是用于注册Bean比如@Component , @Repository , @ Controller , @Service , @Configration</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">假如IOC容器就是一间空屋子，首先这间空屋子啥都没有，我们要吃大餐，我们就要从外部搬运食材和餐具进来。这里把某一样食材或者某一样餐具搬进空屋子的操作就相当于每个注册Bean的注解作用类似。注册Bean的注解作用就是往IOC容器中放（注册）东西！<br>用于注册Bean的注解： 比如@Component , @Repository , @ Controller , @Service , @Configration这些注解就是用于注册Bean，放进IOC容器中，一来交给spring管理方便解耦，二来还可以进行二次使用，啥是二次使用呢？这里的二次使用可以理解为：在你开始从外部搬运食材和餐具进空屋子的时候，一次性搬运了猪肉、羊肉、铁勺、筷子四样东西，这个时候你要开始吃大餐，首先你吃东西的时候肯定要用筷子或者铁勺，别说你手抓，只要你需要，你就会去找，这个时候发现你已经把筷子或者铁勺放进了屋子，你就不用再去外部拿筷子进屋子了，意思就是IOC容器中已经存在，就可以只要拿去用，而不必再去注册！而拿屋子里已有的东西的操作就是下面要讲的用于使用Bean的注解！<br>————————————————<br>版权声明：本文为CSDN博主「宜春」的原创文章，遵循CC <span class="hljs-number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/qq_44543508/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">103718958</span><br></code></pre></td></tr></table></figure><p>一类注解是用于使用Bean</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">用于使用Bean的注解：比如<span class="hljs-meta">@Autowired</span> , <span class="hljs-meta">@Resource</span>注解，这些注解就是把屋子里的东西自己拿来用，如果你要拿，前提一定是屋子（IOC）里有的，不然就会报错<br></code></pre></td></tr></table></figure><h1 id="接口方法接收前端传入参数"><a href="#接口方法接收前端传入参数" class="headerlink" title="接口方法接收前端传入参数"></a>接口方法接收前端传入参数</h1><h2 id="传统方式—针对localhost-8080-x2F-shop-page-x3D-1"><a href="#传统方式—针对localhost-8080-x2F-shop-page-x3D-1" class="headerlink" title="传统方式—针对localhost:8080&#x2F;shop?page&#x3D;1"></a>传统方式—针对localhost:8080&#x2F;shop?page&#x3D;1</h2><p>*如果是通过这种传送数据参数给后端</p><p><img src="https://farsblog.oss-cn-beijing.aliyuncs.com/PicGo/202304242346310.png" alt="image-20230424234625955"></p><p>用的是@RequestParam</p><p>如果省略了也是默认@RequestParam，所以则可以直接（int page,int pageSize)即可</p><p><strong>接口方法参数不使用任何注释</strong>:这其实也是默认使用的是Request.getParameter() 方法对参数进行获取的,只是没有显示使用@RequestParam而已,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span><br><span class="hljs-keyword">public</span> R&lt;Page&gt; <span class="hljs-title function_">page</span><span class="hljs-params">(<span class="hljs-type">int</span> page, <span class="hljs-type">int</span> pageSize, String name)</span><br></code></pre></td></tr></table></figure><p>也可以用@RequestParam</p><h2 id="RESTFUL格式—-针对localhost-8080-x2F-10048"><a href="#RESTFUL格式—-针对localhost-8080-x2F-10048" class="headerlink" title="RESTFUL格式—-针对localhost:8080&#x2F;10048"></a>RESTFUL格式—-针对localhost:8080&#x2F;10048</h2><p>这样的加个@GetMapping(“&#x2F;{id}”)   @PathVariable也行</p><p><img src="https://farsblog.oss-cn-beijing.aliyuncs.com/PicGo/202304242346436.png" alt="image-20230424234642164"></p><h2 id="JSON方式—-针对POST方法的请求体"><a href="#JSON方式—-针对POST方法的请求体" class="headerlink" title="JSON方式—-针对POST方法的请求体"></a>JSON方式—-针对POST方法的请求体</h2><p>​加@RequestBody</p><h1 id="只有管理员（admin）才能看到启用，禁用按钮？非管理员看不见该按钮"><a href="#只有管理员（admin）才能看到启用，禁用按钮？非管理员看不见该按钮" class="headerlink" title="只有管理员（admin）才能看到启用，禁用按钮？非管理员看不见该按钮"></a>只有管理员（admin）才能看到启用，禁用按钮？非管理员看不见该按钮</h1><h4 id="下面是代码展示-lt-v-if-gt-lt-gt"><a href="#下面是代码展示-lt-v-if-gt-lt-gt" class="headerlink" title="下面是代码展示&lt;   v-if&gt;&lt;&gt;"></a>下面是代码展示&lt;   v-if&gt;&lt;&gt;</h4><p><strong>可以利用v-if完成要求</strong></p><p v-if="IfEmpty">出现</p><p><img src="https://farsblog.oss-cn-beijing.aliyuncs.com/PicGo/202304242347284.png" alt="image-20230424234710060"></p><p><strong>从userInfo中取出username，并赋值给user模型数据</strong><br><img src="https://img-blog.csdnimg.cn/4b5b4df2651347f2b1f411749c703508.png" alt="在这里插入图片描述"><br><strong>判断模型数据user的值是否等于admin，若等于则显示按钮</strong><br><img src="https://img-blog.csdnimg.cn/9b0364cae44f4c19a0c2f19f7a74948c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmxhQ2xvdWQ=,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="当maven无法下载源代码时候执行"><a href="#当maven无法下载源代码时候执行" class="headerlink" title="当maven无法下载源代码时候执行"></a><strong>当maven无法下载源代码时候执行</strong></h2><p>【检查方式<a href="https://so.csdn.net/so/search?q=maven&spm=1001.2101.3001.7020">maven</a>正确情况下，再执行本步骤】则在项目下，项目根目录下 或 pom.xml同级目录中执行</p><p><strong>mvn dependency:resolve -Dclassifier&#x3D;sources</strong></p><p><strong>可能原因2：网络问题</strong></p><p>1.没换源且没魔法上网</p><p>2.换了源又魔法上网</p><h2 id="2-servlet-session-request-application"><a href="#2-servlet-session-request-application" class="headerlink" title="2.servlet,session,request,application"></a>2.servlet,session,request,application</h2><ol><li><h4 id="request"><a href="#request" class="headerlink" title="request"></a><strong>request</strong></h4></li></ol><p>  request是表示一个请求，只要发出一个请求就会创建一个request，它的作用域：仅在当前请求中有效。</p><p>用处：常用于服务器间同一请求不同页面之间的参数传递，常应用于表单的控件值传递。</p><p>方法：request.setAttribute(); request.getAttribute(); request.removeAttribute(); request.getParameter().</p><ol start="2"><li><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4></li></ol><p>  服务器会为每个会话创建一个session对象，所以session中的数据可供当前会话中所有servlet共享。</p><p>会话：用户打开浏览器会话开始，直到关闭浏览器会话才会结束。一次会话期间只会创建一个session对象。</p><p>用处：常用于web开发中的登陆验证界面（当用户登录成功后浏览器分配其一个session键值对）。</p><p>方法：session.setAttribute(); session.getAttribute(); session.removeAttribute();</p><p>获得session对象方法：</p><p>在Servlet中：HttpSession session &#x3D; request.getSession();<br>由于session属于jsp九大内置对象之一，当然可以直接使用。例如：&lt;%session.serAttribute(“name”,“admin”)%&gt;。<br>session被销毁<br>1)session超时;<br>2)客户端关闭后，再也访问不到和该客户端对应的session了，它会在超时之后被销毁;<br>3)调用session. invalidate();<br>备注： session是服务器端对象，保存在服务器端。并且服务器可以将创建session后产生的sessionid通过一个cookie返回给客户端，以便下次验证。（session底层依赖于cookie）</p><ol start="3"><li><h4 id="Application（ServletContext）"><a href="#Application（ServletContext）" class="headerlink" title="Application（ServletContext）"></a>Application（ServletContext）</h4></li></ol><p>  作用范围：所有的用户都可以取得此信息，此信息在整个服务器上被保留。Application属性范围值，只要设置一次，则所有的网页窗口都可以取得数据。ServletContext在服务器启动时创建，在服务器关闭时销毁，一个JavaWeb应用只创建一个ServletContext对象，所有的客户端在访问服务器时都共享同一个ServletContext对象;ServletContext对象一般用于在多个客户端间共享数据时使用;<br>  ————————————————<br>  版权声明：本文为CSDN博主「之前我没得选，现在我想做个好人」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>  原文链接：<a href="https://blog.csdn.net/qq_43368645/article/details/114382818">https://blog.csdn.net/qq_43368645/article/details/114382818</a></p><h2 id="4-spring整合mybatis-plus"><a href="#4-spring整合mybatis-plus" class="headerlink" title="4.spring整合mybatis-plus"></a>4.spring整合mybatis-plus</h2><p>1.勾选mysql，然后手动pom添加（因为目前还没有更新）</p><pre><code class="hljs">&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>2.配置application.yml</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">spring</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">datasource</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">type</span><span class="hljs-punctuation">:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>    <span class="hljs-attribute">driver-class-name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attribute">url</span><span class="hljs-punctuation">:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC</span><br>    <span class="hljs-attribute">username</span><span class="hljs-punctuation">:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attribute">password</span><span class="hljs-punctuation">: </span><br><span class="hljs-comment"># 开启mp的日志（输出到控制台）</span><br><span class="hljs-attribute">mybatis-plus</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">configuration</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">log-impl</span><span class="hljs-punctuation">:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure><h3 id="BaseMapper-lt-gt"><a href="#BaseMapper-lt-gt" class="headerlink" title="BaseMapper&lt;&gt;"></a>BaseMapper&lt;&gt;</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@Mapper<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">StudentMapper</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">BaseMapper</span>&lt;<span class="hljs-symbol">Student</span>&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>4.不用再写sql语句不用再写mapper，已经完成</p><h3 id="通用service的IService"><a href="#通用service的IService" class="headerlink" title="通用service的IService"></a>通用service的IService</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">StudentService</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">IService</span>&lt;<span class="hljs-symbol">Student</span>&gt;&#123;<br>&#125;<br><br>当子类不写泛型然后父类写了<br>这个StudentService继承的 extends IService&lt;Student&gt;，其实子类StudentSercice就默认继承了Student为泛型<br></code></pre></td></tr></table></figure><h3 id="通用Impl的ServiceImpl"><a href="#通用Impl的ServiceImpl" class="headerlink" title="通用Impl的ServiceImpl"></a>通用Impl的ServiceImpl</h3><p><code>public class StudentServiceImpl extends ServiceImpl&lt;StudentMapper, Student&gt; implements StudentService &#123;</code><br><code>&#125;</code></p><h3 id="java驼峰命名法，映射，数据库下划线命名法"><a href="#java驼峰命名法，映射，数据库下划线命名法" class="headerlink" title="java驼峰命名法，映射，数据库下划线命名法"></a>java驼峰命名法，映射，数据库下划线命名法</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-comment">#在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h1 id="过滤器Filter"><a href="#过滤器Filter" class="headerlink" title="过滤器Filter"></a>过滤器Filter</h1><h2 id="1-编写Filter"><a href="#1-编写Filter" class="headerlink" title="1.编写Filter"></a>1.编写Filter</h2><p>@WebFilter(filterName &#x3D; “” , urlPatterns &#x3D; “&#x2F;*”)&#x2F;&#x2F;对所有的都先加入过滤器，后面再针对不同类选择是否直接放行</p><p>@slf4j</p><p>public class LoginCheckFilter implementes Filter{}</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220821153738660.png" alt="image-20220821153738660"></p><h2 id="2-启动类加入写-ServletCOmponentScan"><a href="#2-启动类加入写-ServletCOmponentScan" class="headerlink" title="2.启动类加入写@ServletCOmponentScan"></a>2.启动类加入写@ServletCOmponentScan</h2><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220821153721415.png" alt="image-20220821153721415"></p><h3 id="ServletComponentScan"><a href="#ServletComponentScan" class="headerlink" title="@ServletComponentScan"></a>@ServletComponentScan</h3><p><strong>在SpringBootApplication上使用@ServletComponentScan注解后，<a href="https://so.csdn.net/so/search?q=Servlet&spm=1001.2101.3001.7020">Servlet</a>、Filter、Listener可以直接通过@WebServlet、@WebFilter、@WebListener注解自动注册，无需其他代码</strong>。</p><h2 id="filterChain-doFilter-request-response-放行，进行下一个流程"><a href="#filterChain-doFilter-request-response-放行，进行下一个流程" class="headerlink" title="filterChain,doFilter(request,response)放行，进行下一个流程"></a>filterChain,doFilter(request,response)放行，进行下一个流程</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">filterChain.<span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(<span class="hljs-params">request</span>,<span class="hljs-params">response</span>)</span>;<br></code></pre></td></tr></table></figure><h1 id="新增员工Save方法"><a href="#新增员工Save方法" class="headerlink" title="新增员工Save方法"></a>新增员工Save方法</h1><p><strong>启动项目后，输入员工信息，点击保存</strong></p><p><img src="https://img-blog.csdnimg.cn/435db71af05d414bb46d89f5362b42b7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmxhQ2xvdWQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></p><p><strong>保存后，可以看到控制台上打印的数据，表示可以接收到前端传递到服务端的数据</strong><br><img src="https://img-blog.csdnimg.cn/e536272f4c2043e285048e01f252105d.png" alt="请添加图片描述"></p><p>这一串数据已经在前端打包好成为一个Employee了，是前端传过来的给服务器</p><p>通过Controller后端save方法，，实现将前端给定employee存入数据库</p><pre><code class="hljs">@PostMappingpublic R&lt;String&gt; save(HttpServletRequest request, @RequestBody Employee employee)&#123;    log.info(&quot;新增员工的信息：&#123;&#125;&quot;,employee.toString());    //设置初始密码，需要进行md5加密    employee.setPassword(DigestUtils.md5DigestAsHex(&quot;123456&quot;.getBytes()));    employee.setCreateTime(LocalDateTime.now());    employee.setUpdateTime(LocalDateTime.now());    //强转为long类型    Long empID = (Long)request.getSession().getAttribute(&quot;employee&quot;);    employee.setCreateUser(empID);    employee.setUpdateUser(empID);    employeeService.save(employee);    return R.success(&quot;添加员工成功&quot;);&#125;</code></pre><p>Controller中调用了service</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220821164355766.png" alt="image-20220821164355766"></p><p>service利用了mapper使用数据库</p><h1 id="全局异常处理器GlobalExcptionHandler"><a href="#全局异常处理器GlobalExcptionHandler" class="headerlink" title="全局异常处理器GlobalExcptionHandler"></a>全局异常处理器GlobalExcptionHandler</h1><p><strong>我们的程序进行异常捕获，通常有两种处理方式:</strong></p><ol><li>在Controller方法中加入try、catch进行异常捕获</li><li>使用异常处理器进行全局异常捕获(推荐使用第二种方式)</li></ol><p><strong>在common包下，建立GlobalExceptionHandler类，并添加exceptionHandler方法用来捕获异常，并返回结果</strong></p><p>比如针对<strong>异常:</strong><br>java.sql. SQLIntegrityConstraintViolationException: Duplicate entry ‘zhangsan’for key ‘idx_username</p><h3 id="这个就可以将后端发生的excption通过R发送到前端"><a href="#这个就可以将后端发生的excption通过R发送到前端" class="headerlink" title="这个就可以将后端发生的excption通过R发送到前端"></a>这个就可以将后端发生的excption通过R发送到前端</h3><pre><code class="hljs">@ControllerAdvice(annotations = &#123;RestController.class, Controller.class&#125;)@ResponseBody  //java对象转为json格式的数据@Slf4jpublic class GlobalExceptionHandler &#123;    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)    public R&lt;String&gt; exceptionHandler (SQLIntegrityConstraintViolationException exception)&#123;        log.error(exception.getMessage());        if (exception.getMessage().contains(&quot;Duplicate entry&quot;))&#123;            String[] split = exception.getMessage().split(&quot; &quot;);            String msg = split[2] + &quot;已存在&quot;;            return R.error(msg);        &#125;        return R.error(&quot;unknown error&quot;);    &#125;&#125;</code></pre><h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><p><code>页面发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端</code><br><code>服务端Controller接收页面提交的数据并调用Service查询数据</code><br><code>Service调用Mapper操作数据库，查询分页数据</code><br><code>Controller将查询到的分页数据响应给页面</code><br><code>页面接收到分页数据并通过ElementUI的Table组件展示到页面上</code></p><h3 id="1-配置mybatisplus分页插件，通过config"><a href="#1-配置mybatisplus分页插件，通过config" class="headerlink" title="1.配置mybatisplus分页插件，通过config"></a>1.配置mybatisplus分页插件，通过config</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 配置MP的分页插件</span><br><span class="hljs-comment"> */</span><br>@Configuration<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusConfig</span> </span>&#123;<br><br>    @Bean<br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor mybatisPlusInterceptor()&#123;<br>        MybatisPlusInterceptor mybatisPlusInterceptor = <span class="hljs-keyword">new</span> <span class="hljs-type">MybatisPlusInterceptor</span>();<br>        mybatisPlusInterceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-type">PaginationInnerInterceptor</span>());<br>        <span class="hljs-keyword">return</span> mybatisPlusInterceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-点击员工管理，前端页面发送的请求"><a href="#2-点击员工管理，前端页面发送的请求" class="headerlink" title="2.点击员工管理，前端页面发送的请求"></a>2.<strong>点击员工管理，前端页面发送的请求</strong></h3><p><img src="https://img-blog.csdnimg.cn/cfc1b1ab350542ee9c34294681d04f4f.png" alt="在这里插入图片描述"><br><strong>在搜索框中输入员工姓名，前端页面发送的请求</strong><br><img src="https://img-blog.csdnimg.cn/6fa50f08102e4d11b2eea1e219588b47.png" alt="在这里插入图片描述"></p><h3 id="所以在controller中就可以编写page方法来处理这个get请求"><a href="#所以在controller中就可以编写page方法来处理这个get请求" class="headerlink" title="所以在controller中就可以编写page方法来处理这个get请求"></a>所以在controller中就可以编写page方法来处理这个get请求</h3><pre><code class="hljs">@GetMapping(&quot;/page&quot;)public R&lt;Page&gt; page(int page,int pageSize,String name)&#123;    log.info(&quot;page = &#123;&#125;, pageSize = &#123;&#125;, name = &#123;&#125;&quot;,page,pageSize,name);    //构造分页构造器    Page pageInfo = new Page(page, pageSize);    //构造条件构造器    LambdaQueryWrapper&lt;Employee&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();    //添加过滤条件    queryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name);    //添加排序添加    queryWrapper.orderByDesc(Employee::getUpdateTime);    //执行查询    employeeService.page(pageInfo,queryWrapper);    //返回结果    return R.success(pageInfo);&#125;</code></pre><p>Page pageInfo  &#x3D; new Page(page,pageSize);</p><p>LambdaQuerWrapper<Employee> queryWrapper &#x3D; new LambdaQueryWrapper&lt;&gt;();</Employee></p><p>employeeService.page(pageInfo,queryWrapper);</p><p>return R.success(pageInfo)</p><h2 id="Wrapper-mybatisplus"><a href="#Wrapper-mybatisplus" class="headerlink" title="Wrapper-mybatisplus"></a>Wrapper-mybatisplus</h2><pre><code class="hljs">     //构建一个查询的wrapper     QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;();          //加入条件     //name不为空时，组装模糊查询条件     wrapper.like(StringUtils.isNotBlank(name),&quot;name&quot;,name);     //未删除     wrapper.eq(&quot;del_flag&quot;,0);     //创建时间降序     wrapper.orderByDesc(&quot;create_time&quot;);          //执行查询     List&lt;User&gt; list = userMapper.selectList(wrapper);</code></pre><p>分页</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nsis">public R&lt;<span class="hljs-keyword">Page</span>&gt; <span class="hljs-keyword">page</span>(int <span class="hljs-keyword">page</span>, int pageSize)<br>&#123;<br>    <span class="hljs-keyword">Page</span>&lt;Category&gt; pageInfo = new <span class="hljs-keyword">Page</span>&lt;&gt;(<span class="hljs-keyword">page</span>,pageSize)<span class="hljs-comment">;</span><br>    LambdaQueryWrapper&lt;Category&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;()<span class="hljs-comment">;</span><br>    queryWrapper.orderByAsc(<span class="hljs-title function_">Category::getSort</span>)<span class="hljs-comment">;</span><br>    categoryService.<span class="hljs-keyword">page</span>(pageInfo,queryWrapper)<span class="hljs-comment">;</span><br>    <span class="hljs-keyword">return</span> R.success(pageInfo)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="RESTFUL风格"><a href="#RESTFUL风格" class="headerlink" title="RESTFUL风格"></a>RESTFUL风格</h1><p><img src="https://img-blog.csdnimg.cn/2021031117154877.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjU5NDc5Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>@GetMapping，处理get请求<br>@PostMapping，处理post请求<br>@PutMapping，处理put请求<br>@DeleteMapping，处理delete请求</p><p>4.过滤器Filter</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220721114134952.png" alt="image-20220721114134952"></p><p>生命周期：伴随web启动而init，web停止而destory</p><p>filterchain.doFilter（）将请求转发给过滤器链下一个filter , 如果没有filter那就是你请求的资源</p><p>  <em>&#x2F;&#x2F; 让程序继续往下访问用户的目标资源</em></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">filterChain.<span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(<span class="hljs-params">request</span>,<span class="hljs-params">response</span>)</span>;<br></code></pre></td></tr></table></figure><p>匹配URL路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//路径匹配器，支持通配符</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AntPathMatcher</span> <span class="hljs-variable">PATH_MATCHER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathMatcher</span>();<br></code></pre></td></tr></table></figure><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">check</span>(<span class="hljs-built_in">String</span>[] urls,<span class="hljs-built_in">String</span> requestURI)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">String</span> url : urls) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-built_in">match</span> = PATH_MATCHER.<span class="hljs-property">match</span>(url, requestURI);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">match</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.拦截器Inteceptor<img src="https://img-blog.csdnimg.cn/20210227231924707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvcmlsYg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2.在config注册</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220721114715164.png" alt="image-20220721114715164"></p><h1 id="ResponseBody与response-getWriter-write"><a href="#ResponseBody与response-getWriter-write" class="headerlink" title="@ResponseBody与response.getWriter().write()"></a>@ResponseBody与response.getWriter().write()</h1><p>@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象，通常我们使用用来返回JSON数据或者是<a href="https://so.csdn.net/so/search?q=XML&spm=1001.2101.3001.7020">XML</a>数据</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220721152750356.png" alt="image-20220721152750356"></p><p>前端页面：我这里使用的是ajax提交，指定dataType为json，接收到后台传来的数据会转为json对象</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220721152815317.png" alt="image-20220721152815317"></p><p>**对于response.getWriter().write(JSSONObject.toJSON())**的效果</p><p>效果也差不多</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220721152842917.png" alt="image-20220721152842917"></p><p><img src="https://img-blog.csdnimg.cn/20201122180719515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0lUX0xhb0dvdQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>@RestController</strong></p><p>@Controller和@ResponseBody（加在方法&#x2F;类上面）一起使用  &#x3D;&#x3D;  @RestController的作用相同。</p><p><strong>在mysql就可以设置属性为不可重复性Unique</strong></p><p><strong><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220721153358149.png" alt="image-20220721153358149"></strong></p><p>如果存入重复数据username则会报错</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220721154900047.png" alt="image-20220721154900047"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220721154813777.png" alt="image-20220721154813777"></p><p>F12查看network</p><p>可以看见发送到URL请求</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220721153712338.png" alt="image-20220721153712338"></p><p>MybatisPlus-分页</p><p>1.加入config的</p><p>@Bean<br>public MybatisPlusInterceptor mybatisPlusInterceptor() {<br>    MybatisPlusInterceptor interceptor &#x3D; new MybatisPlusInterceptor();<br>    interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));<br>    return interceptor;<br>}</p><p>2.分页得到的数据在page.getRecords()中</p><pre><code class="hljs">    @Test    public void testSelectPage()&#123;        QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();        queryWrapper.eq(&quot;age&quot;, 18);// 年龄等于18        Page&lt;User&gt; page = new Page&lt;&gt;(1, 5);//当前页为1，每页5条        Page&lt;User&gt; pageParam = userMapper.selectPage(page, null);//第二个参数：实体对象封装操作类，如果没有可以为空    List&lt;User&gt; records = pageParam.getRecords();//获取总记录列表    records.forEach(System.out::println);//遍历    System.out.println(pageParam.getPages());//总页数    System.out.println(pageParam.getTotal());//总记录数    System.out.println(pageParam.getCurrent());//当前页码    System.out.println(pageParam.getSize());//每页记录数    System.out.println(pageParam.hasNext());//是否有下一页    System.out.println(pageParam.hasPrevious());//是否有上一页&#125;</code></pre><p>​<br>​    &#x2F;&#x2F;执行查询<br>​            employeeService.page(pageInfo,queryWrapper);</p><h2 id="公共字段自动填充"><a href="#公共字段自动填充" class="headerlink" title="公共字段自动填充"></a>公共字段自动填充</h2><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220729150345804.png"></p><p>1.在实体类需要自动填充的属性加入@TableFIled</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//创建时间</span><br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br><span class="hljs-keyword">private</span> LocalDateTime createTime;<br><br><br><span class="hljs-comment">//更新时间</span><br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="hljs-keyword">private</span> LocalDateTime updateTime;<br><br><br><span class="hljs-comment">//创建人</span><br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> createUser;<br><br><br><span class="hljs-comment">//修改人</span><br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> updateUser;<br></code></pre></td></tr></table></figure><p>2编写类MyMetaObjectHandler implements MetaObjectHanlder</p><p>记得加入@Component</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Component</span><br><span class="hljs-variable">@Slf4j</span><br>public class MyMetaObjectHandler implements MetaObjectHandler &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入元对象字段填充（用于插入时对公共字段的填充）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param metaObject 元对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">@Override</span><br>    public void <span class="hljs-built_in">insertFill</span>(MetaObject metaObject) &#123;<br>        <span class="hljs-selector-tag">metaObject</span><span class="hljs-selector-class">.setValue</span>(<span class="hljs-string">&quot;createTime&quot;</span> , LocalDateTime.<span class="hljs-built_in">now</span>());<br>        <span class="hljs-selector-tag">metaObject</span><span class="hljs-selector-class">.setValue</span>(<span class="hljs-string">&quot;updateTime&quot;</span> , LocalDateTime.<span class="hljs-built_in">now</span>());<br>        <span class="hljs-selector-tag">metaObject</span><span class="hljs-selector-class">.setValue</span>(<span class="hljs-string">&quot;createUser&quot;</span> , BaseContext.<span class="hljs-built_in">getCurrentId</span>());<br>        <span class="hljs-selector-tag">metaObject</span><span class="hljs-selector-class">.setValue</span>(<span class="hljs-string">&quot;updateUser&quot;</span> , BaseContext.<span class="hljs-built_in">getCurrentId</span>());<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新元对象字段填充（用于更新时对公共字段的填充）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param metaObject 元对象</span><br><span class="hljs-comment">     */</span><br>    @<span class="hljs-selector-tag">Override</span><br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">updateFill</span>(MetaObject metaObject) &#123;<br>        <span class="hljs-selector-tag">metaObject</span><span class="hljs-selector-class">.setValue</span>(<span class="hljs-string">&quot;updateUser&quot;</span> , BaseContext.<span class="hljs-built_in">getCurrentId</span>());<br>        <span class="hljs-selector-tag">metaObject</span><span class="hljs-selector-class">.setValue</span>(<span class="hljs-string">&quot;updateTime&quot;</span> , LocalDateTime.<span class="hljs-built_in">now</span>());<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="1-对象映射器"><a href="#1-对象映射器" class="headerlink" title="1.对象映射器"></a>1.对象映射器</h2><p>JacksonObjectMapper作用就是在后端controller返回response给前端网页时候，将java对象转为json对象传回</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\*</span> 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象<br><br><span class="hljs-string">\*</span> 将<span class="hljs-built_in">JSON</span>解析为Java对象的过程称为 [从<span class="hljs-built_in">JSON</span>反序列化Java对象]<br><br><span class="hljs-string">\*</span> 从Java对象生成<span class="hljs-built_in">JSON</span>的过程称为 [序列化Java对象到<span class="hljs-built_in">JSON</span>]<br></code></pre></td></tr></table></figure><p>2.在config替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 扩展mvc框架的消息转换器</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> converters</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extendMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;<br>    log.info(<span class="hljs-string">&quot;扩展消息转换器...&quot;</span>);<br>    <span class="hljs-comment">//创建消息转换器对象</span><br>    <span class="hljs-type">MappingJackson2HttpMessageConverter</span> <span class="hljs-variable">messageConverter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MappingJackson2HttpMessageConverter</span>();<br>    <span class="hljs-comment">//设置对象转换器，底层使用Jackson将Java对象转为json</span><br>    messageConverter.setObjectMapper(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JacksonObjectMapper</span>());<br>    <span class="hljs-comment">//将上面的消息转换器对象追加到mvc框架的转换器集合中</span><br>    converters.add(<span class="hljs-number">0</span>,messageConverter);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="提示报错：java-找不到符号"><a href="#提示报错：java-找不到符号" class="headerlink" title="提示报错：java: 找不到符号"></a>提示报错：java: 找不到符号</h3><p>解决方式clean和package</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220729190910388.png" alt="image-20220729190910388"></p><h2 id="元数据（Metadata"><a href="#元数据（Metadata" class="headerlink" title="元数据（Metadata)"></a>元数据（Metadata)</h2><p>典型的元数据（Metadata)元素：</p><ul><li>标题和描述</li><li>标签和分类</li><li>谁生成的，何时生成的</li><li>最后一次是被谁更改的，何时更改的</li><li>谁能访问或者更新</li></ul><h2 id="关于客户端的http请求与线程"><a href="#关于客户端的http请求与线程" class="headerlink" title="关于客户端的http请求与线程"></a>关于客户端的http请求与线程</h2><p>同一个http请求是同一个线程</p><p>比如我点击保存，发送请求，会有三个流程loginCheckFilter过滤器，EmployeeCOntroller，MyMetaObjectHandler</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220729194016614.png" alt="image-20220729194016614"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220729194603645.png" alt="image-20220729194603645"></p><p>ThreadLocal就是在一个线程中用于保存的局部变量</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220729194412201.png" alt="image-20220729194412201"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220821145945528.png" alt="image-20220821145945528"></p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="Favicon-ico是自动成为网页图标"><a href="#Favicon-ico是自动成为网页图标" class="headerlink" title="Favicon.ico是自动成为网页图标"></a>Favicon.ico是自动成为网页图标</h2><h2 id="RestController-x3D-Contreller-Responsebody"><a href="#RestController-x3D-Contreller-Responsebody" class="headerlink" title="@RestController&#x3D;@Contreller+@Responsebody"></a>@RestController&#x3D;@Contreller+@Responsebody</h2><p> <code>@ResponseBody</code> 注解是将返回的数据结构转换为 Json 格式</p><p>所以@RestContreller也可以使得返回Json格式数据</p><h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><p>后端java对象     《—-》前端Json</p><p><code>SpringBoot处理JSON数据时，需要用到两个重要的JSON转换注解，分别是@RequestBody和@ResponseBody。</code><br><code>@RequestBody:将请求主体的数据绑定到形参上，该注解应用在方法的形参上</code><br><code>@ResponseBody:直接返回Json对象，该注解应用在方法上。</code></p><p>通过@ResponseBody和@RequestBody</p><p>后端对象：   new User(1, “倪升武”, “123456”);   </p><p>——-》</p><p>前端json       {“id”:1,”username”:”倪升武”,”password”:”123456”}</p><pre><code class="hljs">@RestController@RequestMapping(&quot;/json&quot;)public class JsonController &#123;@RequestMapping(&quot;/user&quot;)public User getUser() &#123;    return new User(1, &quot;倪升武&quot;, &quot;123456&quot;);&#125; @RequestMapping(&quot;/list&quot;)public List&lt;User&gt; getUserList() &#123;    List&lt;User&gt; userList = new ArrayList&lt;&gt;();    User user1 = new User(1, &quot;倪升武&quot;, &quot;123456&quot;);    User user2 = new User(2, &quot;达人课&quot;, &quot;123456&quot;);    userList.add(user1);    userList.add(user2);    return userList;&#125; @RequestMapping(&quot;/map&quot;)public Map&lt;String, Object&gt; getMap() &#123;    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3);    User user = new User(1, &quot;倪升武&quot;, &quot;123456&quot;);    map.put(&quot;作者信息&quot;, user);    map.put(&quot;博客地址&quot;, &quot;http://blog.itcodai.com&quot;);    map.put(&quot;CSDN地址&quot;, &quot;http://blog.csdn.net/eson_15&quot;);    map.put(&quot;粉丝数量&quot;, 4153);    return map;&#125;</code></pre><p>前端</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220822145137197.png" alt="image-20220822145137197"></p><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>是一个用来处理请求地址映射的注解，它可以用于类上，也可以用于方法上。</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220822150235770.png" alt="image-20220822150235770"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220822150250562.png" alt="image-20220822150250562"></p><p>@RequestMapping（value&#x3D;”&#x2F;test”)</p><p>value可省略</p><p>@RequestMapping(“&#x2F;test”)</p><p>@RequestMapping(value&#x3D;”&#x2F;test”,method &#x3D; RequstMethod.GET)</p><p>@GetMapping(“&#x2F;test”)</p><h2 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h2><p><code>@PathVariable</code> 注解主要是用来获取 url 参数，Spring Boot 支持 restfull 风格的 url，比如一个 GET 请求携带一个参数 id 过来，我们将 id 作为参数接收，可以使用 <code>@PathVariable</code> 注解</p><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p> <code>localhost:8080/test/user/2/zhangsan</code></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">获取到<span class="hljs-built_in">的id</span>为：<span class="hljs-number">2</span><br>获取到<span class="hljs-built_in">的name</span>为：zhangsan<br></code></pre></td></tr></table></figure><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220822150624194.png" alt="image-20220822150624194"></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/user/&#123;id&#125;&quot;</span>)<br><br>public string <span class="hljs-built_in">test</span>(<span class="hljs-variable">@PathVariable</span> Integer id)<br><br>&#123;\<br><br>​...<br><br>​<span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(id);<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">获取到<span class="hljs-built_in">的id</span>为：<span class="hljs-number">2</span><br>获取到<span class="hljs-built_in">的name</span>为：zhangsan<br></code></pre></td></tr></table></figure><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><h3 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://localhost:8080/user?<span class="hljs-built_in">id</span>=1<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/user&quot;</span>)</span><br><span class="hljs-keyword">public</span> String testRequestParam(<span class="hljs-meta">@RequestParam</span> Integer id) &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;获取到的id为：&quot;</span> + id);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注解@RequestParam接收的参数是来自HTTP请求体或请求url的QueryString中。</p><p>请求体只有一个，@RequestBody最多只能有一个请求体</p><p>而@RequestParam()可以有多个。</p><p>@RequestBody –&gt; JSON字符串部分</p><p>@RequestParam –&gt; 请求参数部分</p><p>application&#x2F;json格局图<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDYxMzc5LTYzYWJjNmNjODZhMDYzYWYucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMDAwL2Zvcm1hdC93ZWJw" alt="img"></p><p>form-data、x-www-form-urlencoded格局图</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDYxMzc5LTQ5MTAxNDllZGEzZTRiZDQucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXAlN0NpbWFnZVZpZXcyLzIvdy8xMDAwL2Zvcm1hdC93ZWJw" alt="img"></p><h2 id="RequestBody-1"><a href="#RequestBody-1" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>get请求没有请求体不能用requestbody</p><h2 id="自定义参数封装过程原理【用实体类接收参数】"><a href="#自定义参数封装过程原理【用实体类接收参数】" class="headerlink" title="自定义参数封装过程原理【用实体类接收参数】"></a>自定义参数封装过程原理【用<a href="https://so.csdn.net/so/search?q=%E5%AE%9E%E4%BD%93%E7%B1%BB&spm=1001.2101.3001.7020">实体类</a>接收参数】</h2><p>@RequestBody，get请求的url参数传入等可以接收前端传来的多个参数，然后Controller方法中会使得其自动封装为一个实体类</p><p>在使用<a href="https://so.csdn.net/so/search?q=ajax&spm=1001.2101.3001.7020">ajax</a>发送请求时，如果发送的JSON数据是一个类中的不同属性，在Controller方法中使用@RequestBody会直接封装进该类中</p><p>实例：</p><h4 id="传来同一个类的多个参数"><a href="#传来同一个类的多个参数" class="headerlink" title="传来同一个类的多个参数"></a>传来同一个类的多个参数</h4><p>User</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>public class User implements Serializable &#123;<br><span class="hljs-symbol">2 </span>    private Integer user_name;                       //用户名<br><span class="hljs-symbol">3 </span>    private String user_password;                   //用户密码<br><span class="hljs-symbol">4 </span>    ......   <br><span class="hljs-symbol">5 </span>&#125;<br></code></pre></td></tr></table></figure><p>前端传来————此时ajax提交的JSON数据为</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-keyword">data</span>:JSON.stringify(&#123;<span class="hljs-string">&quot;user_name&quot;</span>:admin,<span class="hljs-string">&quot;user_password&quot;</span>:<span class="hljs-number">123</span>)<br></code></pre></td></tr></table></figure><p>后端接受—————-就可以直接@RequestBody</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">Boolean</span> <span class="hljs-selector-tag">Login</span>(<span class="hljs-variable">@RequestBody</span> User user)<br></code></pre></td></tr></table></figure><p>问题：SpringBoot框架下，控制层代码接受前台传递的参数，使用注解@RequestBody接受时，用实体作为接受参数，实体接受不到参数。新增时，报sql空数据异常。</p><p>解决方法：如果在项目中实体是使用逆向工程生成时，就需要注意，前台获取到的数据封装到json中的数据库表字段名与逆向工程生成的实体内的数据库表字段名的大小写保持一致，否则，前台传递的数据使用Map能接受到，但是如果与实体内的字段名的大小写不一致，就会接受不到数据，实体内数据全为空，插入数据时报错。</p><h4 id="如果这些参数并不是同一个类的不同属性"><a href="#如果这些参数并不是同一个类的不同属性" class="headerlink" title="如果这些参数并不是同一个类的不同属性"></a>如果这些参数并不是同一个类的不同属性</h4><p>form表单中增加了一项验证码：verifycode。此时，假如ajax提交的JSON数据为</p><p>假ajax提交的JSON数据为</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-keyword">data</span>:JSON.stringify(&#123;<span class="hljs-string">&quot;user_name&quot;</span>:admin,<span class="hljs-string">&quot;user_password&quot;</span>:<span class="hljs-number">123</span>,<span class="hljs-string">&quot;verifycode&quot;</span>:<span class="hljs-number">666</span>&#125;)<br></code></pre></td></tr></table></figure><p>但是verifycode并不是User类中的属性，不能由@RequestBody User user接收</p><p>就可以用1.@RequestBody String body</p><p>​2.(@RequestBody Map&lt;String,String&gt; map</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>@RequestMapping(value = <span class="hljs-string">&quot;www.tengyao3zc.cn/Login&quot;</span>,method = &#123;RequestMethod.POST&#125;)<br><span class="hljs-symbol">2 </span>    public @ResponseBody Boolean Login(@RequestBody String body) &#123;<br><span class="hljs-symbol">3 </span>        //此时body是整个请求体的内容<br><span class="hljs-symbol">4 </span>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(body);<br><span class="hljs-symbol">5 </span>        //······<br><span class="hljs-symbol">6 </span>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>@RequestMapping(value = <span class="hljs-string">&quot;/Login&quot;</span>,method = &#123;RequestMethod.POST&#125;)<br><span class="hljs-symbol">2 </span>    public @ResponseBody Boolean Login(@RequestBody Map&lt;String,String&gt; map) &#123;<br><span class="hljs-symbol">3 </span>        //此时map.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;user_name&quot;</span>www.jintianxuesha.<span class="hljs-keyword">com</span>)就是前端的user_name<br><span class="hljs-symbol">4 </span>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(map.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;user_name&quot;</span>));<br><span class="hljs-symbol">5 </span>        //map.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;user_password&quot;</span> www.yuntianyul.<span class="hljs-keyword">com</span>)就是前端的user_password<br><span class="hljs-symbol">6 </span>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(map.<span class="hljs-keyword">get</span>( www.jinliyld.cn<span class="hljs-string">&quot;user_password&quot;</span>));<br><span class="hljs-symbol">7 </span>        //map.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;www.javachenglei.com verifycode&quot;</span>)就是前端的verifycode<br><span class="hljs-symbol">8 </span>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(map.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;verifycode&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="GET请求中，因为没有请求体，只有url的QueryString，所以-RequestBody并不适用。"><a href="#GET请求中，因为没有请求体，只有url的QueryString，所以-RequestBody并不适用。" class="headerlink" title="GET请求中，因为没有请求体，只有url的QueryString，所以@RequestBody并不适用。"></a>GET请求中，因为没有请求体，只有url的QueryString，所以@RequestBody并不适用。</h2><p>•在GET请求中，不能使用@RequestBody。 •在POST请求，可以使用@RequestBody和@RequestParam，</p><h1 id="day04"><a href="#day04" class="headerlink" title="day04"></a>day04</h1><h2 id="文件上传与下载"><a href="#文件上传与下载" class="headerlink" title="文件上传与下载"></a>文件上传与下载</h2><p>**Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码</p><p><strong>我们只需要在Controller的方法中声明一个MultipartFile类型的参数即可接收上传的文件，例如:</strong><br><img src="https://img-blog.csdnimg.cn/242c9de8808448c19a29033b47b6bf4e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmxhQ2xvdWQ=,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>这里传上来的file一般是存在C盘的临时文件.tmp，请求结束后自动删除</p><p><img src="https://img-blog.csdnimg.cn/6bdfafcb4df44ad89c361fd85672822b.png" alt="在这里插入图片描述"></p><p><strong>临时文件（TMP文件），所以需要转存到指定位置，否则本次请求完成后临时文件删除</strong></p><p>可以用file.transferTo（地址）转存到指定位置</p><pre><code class="hljs">    //将临时文件存储到指定位置    file.transferTo(new File(&quot;D:\\hello.jpg&quot;));</code></pre><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><ol><li><p>概述：文件和目录（文件夹）路径名的抽象表示形式(类路径)</p></li><li><p>file类的构造函数只是创建一个File实例，并没有以文件做读取等操作，因此路径即使是错误的，也可以创建实例不报错</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//创建一个目录对象</span><br>basePath = <span class="hljs-string">&quot;D:/test&quot;</span><br>        <span class="hljs-keyword">File</span> <span class="hljs-keyword">dir</span> = new <span class="hljs-keyword">File</span>(basePath);<br>        <span class="hljs-comment">//判断目录是否存在</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">dir</span>.exists())&#123;<br>            <span class="hljs-comment">//目录不存在需要创建</span><br>            <span class="hljs-keyword">dir</span>.<span class="hljs-keyword">mkdir</span>();<br>        &#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="输入流与输出流"><a href="#输入流与输出流" class="headerlink" title="输入流与输出流"></a>输入流与输出流</h3><p>输入流 FileinputStream（File file或者String filePath）</p><p>输出流FileoutputStream（File file或者String filePath）</p><p>每次执行read（）方法，<strong>read每调用一次就会读取文本内容的下一个字节</strong></p><p>read（）返回-1时候代表读完</p><p><strong>①read()</strong> :从输入流中一次读取一个字节，读完一个字节自动读取数据的下一个字节，<strong>返回*0*到*255*范围内的int字节值</strong>。如果因为已经到达流末尾而没有可用的字节，则返回*-1*。在输入数据可用、检测到流末尾或者抛出异常前，此方法一直阻塞。</p><p>②read(byte[] b) :从输入流中读取一定数量的字节，并将其读取存储在缓冲区数组 b 中。</p><p>以整数形式返回实际读取的字节数。</p><p>在输入数据可用、检测到文件末尾或者抛出异常前，此方法一直阻塞。如果因为流位于文件末尾而没有可用的字节，则返回值 -1；每次读取的字节数是缓冲区数组的最大储存字节数（new byte[2] 数组最多储存2个字节，那么read（byte）每一次只能读到2字节，并且数组是满的状态），下一次调用读取的字节存入这个数组会替代掉上一次数组的内容（返回的是读了多少个字节而读到的字节内容储存到了b缓冲区中）</p><p>③read(byte[] bytes,int off ,int len) 参数的byte照样是缓存区数组，off是读取字节的开始位置，len是每次读取的的字节数</p><p>那么这个和上面read（b）的区别就是他指定了每一次读出多少个字节，而不再用每一次读满一个缓存数组的形式，并且这一个可以指定读取字节开始的位置。返回的也是实际每次读取到的字节数而不是字节，字节都储存在缓存数组里。（比如，new bety[10], read（bety,0,9）,那么每次读进数组的是9个字节，那么每次数据就会剩下一个字节项，那么下一次用read读，读到的第一个字节就会放在数组的最后一个位置，而剩下的8个字节替换掉上次的前8个字节，想想就复杂 ）。</p><p>一般是</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">  <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   \* 文件下载</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   \* @param name</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   \* @param response</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   */</span><br><br>  @<span class="hljs-constructor">GetMapping(<span class="hljs-string">&quot;/download&quot;</span>)</span><br><br>  public void download(String name, HttpServletResponse response)&#123;<br><br><br><br>​    <span class="hljs-keyword">try</span> &#123;<br>​      <span class="hljs-comment">//输入流，通过输入流读取文件内容</span><br>​      FileInputStream fileInputStream = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileInputStream(<span class="hljs-params">new</span> File(<span class="hljs-params">basePath</span> + <span class="hljs-params">name</span>)</span>);<br>​      <span class="hljs-comment">//输出流，通过输出流将文件写回浏览器</span><br>​      ServletOutputStream outputStream = response.get<span class="hljs-constructor">OutputStream()</span>;<br>​      response.set<span class="hljs-constructor">ContentType(<span class="hljs-string">&quot;image/jpeg&quot;</span>)</span>;<br>​     <span class="hljs-built_in">int</span> len = <span class="hljs-number">0</span>;<br>​      byte<span class="hljs-literal">[]</span> <span class="hljs-built_in">bytes</span> = <span class="hljs-keyword">new</span> byte<span class="hljs-literal">[<span class="hljs-number">1024</span>]</span>;<br>​      <span class="hljs-keyword">while</span> ((len = fileInputStream.read(<span class="hljs-built_in">bytes</span>)) != -<span class="hljs-number">1</span>)&#123;<br>​       outputStream.write(<span class="hljs-built_in">bytes</span>,<span class="hljs-number">0</span>,len);<br>​        outputStream.flush<span class="hljs-literal">()</span>;<br>​      &#125;<br>​      outputStream.close<span class="hljs-literal">()</span>;<br>​      fileInputStream.close<span class="hljs-literal">()</span>;<br>​    &#125; catch (Exception e) &#123;<br>​      e.print<span class="hljs-constructor">StackTrace()</span>;<br>​    &#125;<br><br>  &#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">@RestController@RequestMapping(&quot;/common&quot;)@Slf4jpublic class CommonController &#123;@PostMapping(&quot;/upload&quot;)public R&lt;String&gt; upload(MultipartFile file)&#123;    //file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件删除    log.info(file.toString());    try &#123;        //将临时文件存储到指定位置        file.transferTo(new File(&quot;D:\\hello.jpg&quot;));    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;    return null;&#125;</code></pre><ul><li>MultipartFile是spring类型，代表HTML中form data方式上传的文件，包含<em>二进制数据+文件名称</em>。</li><li>MultipartFile后面的参数名必须为file，因为需要和前端页面的name保持一致，否则不会生效<br><img src="https://img-blog.csdnimg.cn/97b6d511faa64b8abf1f6ad988ef7f69.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQmxhQ2xvdWQ=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><h3 id="UUID，不需要任何参数生成一个唯一数字"><a href="#UUID，不需要任何参数生成一个唯一数字" class="headerlink" title="UUID，不需要任何参数生成一个唯一数字"></a>UUID，不需要任何参数生成一个唯一数字</h3><p>UUID是Universally <a href="https://so.csdn.net/so/search?q=Unique&spm=1001.2101.3001.7020">Unique</a> Identifier的缩写，它是在一定的范围内（从特定的名字空间到全球）唯一的机器生成的标识符。UUID具有以下涵义：</p><ul><li>经由一定的算法机器生成</li></ul><p>为了保证UUID的唯一性，规范定义了包括网卡MAC地址、<a href="https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E6%88%B3&spm=1001.2101.3001.7020">时间戳</a>、名字空间（Namespace）、随机或伪随机数、时序等元素，以及从这些元素生成UUID的算法。UUID的复杂特性在保证了其唯一性的同时，意味着只能由计算机生成。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">    <span class="hljs-comment">//使用UUID重新生成文件名，防止文件名称重复造成文件覆盖</span><br><br>​    String fileName = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UUID</span>.</span></span>random<span class="hljs-constructor">UUID()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span> + suffix;<span class="hljs-comment">//dfsdfdfd.jpg</span><br></code></pre></td></tr></table></figure><h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p>1.读取application.yml的配置属性</p><p>@Value(“${user.name}”)</p><p>private String name;</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220823160603571.png" alt="image-20220823160603571"></p><h2 id="前端js分析"><a href="#前端js分析" class="headerlink" title="前端js分析"></a>前端js分析</h2><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220823100440835.png" alt="image-20220823100440835"></p><p>调用了getCategoryList（）函数，其中{‘type’:1}是参数param,type值为1，代表是菜品类型</p><p>res代表函数返回值R，如果成功返回则将R.data赋给this.dishList(菜品分类列表)，所以R.data应该是List<Category></Category></p><p>———-》后端方法public R&lt;LIst<Category>&gt; list()</Category></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220823100746047.png" alt="image-20220823100746047"></p><p>param&#x3D;{‘type’,1}</p><p>通过url’&#x2F;category&#x2F;list’发送get请求，附带参数</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220823112333702.png" alt="image-20220823112333702"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220823112345186.png" alt="image-20220823112345186"></p><p>传统方式后端可以不加@RequestParam</p><p>public R&lt;LIst<Category>&gt; list(Mapping type)</Category></p><p>也可以使用自动封装的实体类</p><p>public R&lt;LIst<Category>&gt; list(Category category)</Category></p><p>这里的参数可以是category是原参数param的type封装成category再转过来</p><p>Content-Tpye</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">text/html  ：HTML格式<br>text/plain ：纯文本格式      <br>text/xml   ：XML格式<br><br>image/gif  ：gif图片格式    <br>image/jpeg ：jpg图片格式 <br>image/png  ：png图片格式<br><br>application/xml     ： XML数据格式<br>application/json    ： JSON数据格式<br>application/pdf     ： pdf格式  <br>application/msword  ： Word文档格式<br>application/octet-stream ： 二进制流数据（如文件下载）<br><br>application/x-www-form-urlencoded ： <br><br>&lt;form encType=<span class="hljs-string">&quot;&quot;</span>&gt;中默认的encType，<br>form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）。<br>服务器收到的raw body会是，name=aaa&amp;key=bbb。<br><br><br>multipart/form-data ： 表单上传文件<br></code></pre></td></tr></table></figure><h2 id="lambda的几个使用场景"><a href="#lambda的几个使用场景" class="headerlink" title="lambda的几个使用场景"></a>lambda的几个使用场景</h2><p>​lambda能替换匿名内部类</p><pre><code class="hljs">    Runnable r = new Runnable() &#123;        @Override        public void run() &#123;            System.out.println(&quot;thread run&quot;);        &#125;    &#125;     Runnable r = () -&gt; &#123;        System.out.println(&quot;thread run&quot;);    &#125;;</code></pre><p>​哪里有list，哪里就有lambda</p><pre><code class="hljs">    //遍历输出集合    List&lt;Integer&gt; list=Arrays.asList(1,2,3,4,5);    list.forEach(x-&gt;System.out.print(x));    //当然也可使用方法引用    list.forEach(System.out::print);     //取出所有大于1的元素，并形成新的集合    List&lt;Integer&gt; collect = list.stream().filter(x -&gt; x &gt; 1).collect(Collectors.toList());        //获取学生的所有年龄集合    List&lt;Integer&gt; ageList=Arrays.asList(new Student(&quot;tom&quot;,20),new Student(&quot;jack&quot;,22))            .stream().map(Student::getAge).collect(Collectors.toList());</code></pre><p>js分析</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220825143810519.png" alt="image-20220825143810519"></p><p>if（valid）这里是进行校验是否要进行</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/SpringBoot/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220825143910403.png" alt="image-20220825143910403"></p><p>把当前页面的数据封装为一个param</p><p>、</p><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>json序列化：就是<a href="https://so.csdn.net/so/search?q=JavaBean&spm=1001.2101.3001.7020">JavaBean</a>对象转化为JSON格式的字符串。</p><p>反序列化：就是序列化的反方向，将<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>转化为JavaBean。</p><p>前端要json字符串，后端要javaBean对象（假设后端采用java语言）怎么办？此时就需要json的序列化和反序列化了。</p><p>从前端json反序列化给后端需要@ResponseBody接受</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>1.在serviceImpl加入@Transactional</p><p>2.启动类加**@EnableTransactionManagement**</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《面向服务的软件系统》大作业</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E3%80%8A%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%8B%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E3%80%8A%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%8B%E5%A4%A7%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<p><strong>哈尔滨工业大学国家示范性软件学院</strong></p><p><strong>《面向服务的软件系统》大作业</strong></p><p><strong>项目题目：  基于微服务的网络购物云平台</strong></p><p><strong>项目组成员：</strong></p><p><strong>姓名：  石卓凡   学号： 120L021011</strong></p><p><strong>姓名： 苏泽楷    学号： 120L020926</strong></p><p><strong>姓名： 艾永亮   学号： 120L020205</strong></p><p><strong>完成日期： 2022年 12 月 19 日</strong></p><p>目录</p><p><a href="#_Toc122438707">1.选题 1</a></p><p><a href="#_Toc122438708">1.1项目介绍 1</a></p><p><a href="#_Toc122438709">1.2整体项目两大板块 3</a></p><p><a href="#_Toc122438710">2.实现方案 5</a></p><p><a href="#_Toc122438711">2.1 使用的技术知识 5</a></p><p><a href="#22-%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E6%96%B9%E6%B3%95">2.2 团队协作方法 5</a></p><p><a href="#23-%E8%AE%BE%E8%AE%A1%E7%AE%A1%E7%90%86%E5%91%98%E7%AB%AF">2.3 设计管理员端 5</a></p><p><a href="#231-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1">2.3.1 数据库设计 6</a></p><p><a href="#%E5%90%8E%E7%AB%AF%E8%AE%BE%E8%AE%A1">2.3.2 后端设计 8</a></p><p><a href="#233-%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1">2.3.3 前端设计 12</a></p><p><a href="#24-%E8%AE%BE%E8%AE%A1%E5%AE%A2%E6%88%B7%E6%89%8B%E6%9C%BA%E7%AB%AF">2.4 设计客户手机端 16</a></p><p><a href="#25-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2">2.5 项目部署 19</a></p><p><a href="#_Toc122438719">3.实现结果 21</a></p><p><a href="#31-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">3.1 软件开发 21</a></p><p><a href="#%E7%AE%A1%E7%90%86%E5%91%98%E7%AB%AF">3.1.1 管理员端 21</a></p><p><a href="#%E5%AE%A2%E6%88%B7%E6%89%8B%E6%9C%BA%E7%AB%AF">3.1.2 客户手机端 23</a></p><p><a href="#32%E6%9E%B6%E6%9E%84%E9%83%A8%E7%BD%B2">3.2 架构部署 25</a></p><p><a href="#_Toc122438724">4.总结 28</a></p><p><a href="#1%E7%9F%B3%E5%8D%93%E5%87%A1">(1).石卓凡 28</a></p><p><a href="#2%E8%8B%8F%E6%B3%BD%E6%A5%B7">(2).苏泽楷 28</a></p><p><a href="#3%E8%89%BE%E6%B0%B8%E4%BA%AE">(3).艾永亮 30</a></p><p><a href="#_Toc122438728">5.对课程的建议 32</a></p><p>1. 选题</p><p><strong>选择题目2：基于微服务框架开发项目</strong></p><p>●基于Springboot搭建项目框架</p><p>●项目采用微服务架构，可基于Dubbo或Spring Cloud等 框架，起评分标准90分</p><p>●如采用Shiro框架实现认证与授权，或Jenkins实现 CI&#x2F;CD等扩展能力，起评分标准100分</p><p>●运用Maven、Git等主流开发工具</p><p>●业务不限，软件功能相对完整，界面美观友好</p><p>●包含至少5个操作界面，代码量1500行+</p><p><strong>大作业题目：基于微服务的网络购物云平台</strong></p><p><strong>概述：</strong></p><p><strong>1.1项目介绍：</strong></p><p>当今，网络经济模式越来越流行，网上购物方式日益为大家所接受。互联网的飞速发展，已经颠覆了传统的信息采集、传递和外观，对劳动者的劳动技能和工作效率的提高，提供了前所未有的有利条件和推进作用。个人经营，企业等的经济收入增长大多得益于互联网的推广和应用。</p><p>网络购物云平台是电子商务的前端商务平台，它在整个商务活动过程中扮演着非常重要的角色。网上购物系统也是一种商业信息系统，它具有强大的交互功能，能向用户提供各种信息资源，能使商家和用户之间能方便地进行信息传递，新型的线上线下整合营销模式可以方便快捷地完成电子贸易。</p><p>而一个购物平台的用户分为两类，一类是管理员，负责维护这个购物平台上架的商品，管理本平台销售商品的品牌分类。另一类是普通的手机客户，将会通过购物平台浏览商品最终旋入购物车并下单。</p><p>因此，针对两类用户，我们的大作业项目就需要设计成为俩个小项目，<strong>管理端</strong>和<strong>客户端</strong>。</p><p>与此同时，一般实际中购物平台的访问量很大，为了模拟真实情况，采用多台服务器去部署，并且使用限流策略等。因此管理端和客户端部署在两个不同集群。</p><p>图1.1 项目部署图</p><p>图1.2 项目设计图</p><p>图1.3 项目数据流图(DFD)</p><p><strong>1.2整体项目两大板块：</strong></p><p><strong>(a).管理端：</strong></p><p>该管理系统可以登录管理员账号，登录员工账号，管理员可以实现对某个电商交易平台的员工，商品，品牌分类等进行管理与查询。后台管理系统中的信息以便于客户手机端可以对电商商品进行下单。</p><p><strong>(b).客户端：</strong></p><p>客户可以进行登录，采用手机短信验证码登录，然后对商品进行选购下单，通过位置定位确定收货地点来下单。</p><p>图1.4 项目功能结构图</p><ol><li>实现方案</li></ol><p><strong>2.1 使用的技术知识</strong></p><table><thead><tr><th><strong>分工层面</strong></th><th><strong>应用到的技术</strong></th></tr></thead><tbody><tr><td>前端</td><td>H5,Vue,Element-Plus,axios,vite</td></tr><tr><td>后端</td><td>springcloud,mybatis-plus,nacos,sentinel,gateway,Feign</td></tr><tr><td>运维</td><td>Docker,k8s,jenkins，nginx</td></tr><tr><td>数据</td><td>Mysql</td></tr></tbody></table><p>表2.1 项目涉及技术&#x2F;知识</p><h2 id="2-2-团队协作方法"><a href="#2-2-团队协作方法" class="headerlink" title="2.2 团队协作方法"></a>2.2 团队协作方法</h2><p>后端对接我们采取的是利用apiFox，便于更好理解互相之间的工作接口，apifox这种工具可以帮助我们小组前后端分离：</p><p><strong>对于前端来说</strong></p><p>1.更好的了解后端接口情况；</p><p>2.如果还没有后端接口，可以模拟后端接口，如果需要，前端向后端申请希望新增这样接口。</p><p><strong>对于后端来说</strong></p><p>1.后端可以通过导出Api然后将接口导入到apifox，以此来向其他成员说明接口情况；</p><p>2.可以详细了解前端需要哪些额外接口。</p><h2 id="2-3-设计管理员端"><a href="#2-3-设计管理员端" class="headerlink" title="2.3 设计管理员端"></a>2.3 设计管理员端</h2><p>图2.1 项目顶层数据流图(DFD)</p><h3 id="2-3-1-数据库设计"><a href="#2-3-1-数据库设计" class="headerlink" title="2.3.1 数据库设计"></a>2.3.1 数据库设计</h3><p><strong>需求：</strong></p><ul><li>为前后端提供数据库支持</li><li>数据库表的命名简单明了，且要求每条数据都有详细注释，方便其他成员阅读</li><li>允许项目所有成员可以通过远程访问，而不是部署在某个同学的本机上，方便前后端成员随时根据需要去访问数据</li></ul><p><strong>设计方案：</strong></p><ul><li>在服务器k8s集群上部署mysql作为云数据库，可以通过navicat进行远程连接和可视化操作</li><li>数据库中含employee员工表，brand品牌表，good商品表；</li><li>实现数据库里面商品携带商品图片，可以将商品图片转化为url链接存入然后mysql类型定义为varchar并且长度为2083</li><li>想要解决good的名称唯一可以直接利用mysql的唯一索引，这样就限制了存入数据库的name是唯一的</li></ul><p>图2.2 项目数据库表设计</p><p>图2.3 项目数据库表设计(2)</p><table><thead><tr><th>表</th><th>名</th><th>注释</th></tr></thead><tbody><tr><td>Brand</td><td>id</td><td>主键</td></tr><tr><td></td><td>name</td><td>品牌名</td></tr><tr><td></td><td>number</td><td>该品牌旗下所含的商品总数</td></tr><tr><td></td><td>Create_time</td><td>创建时间</td></tr><tr><td></td><td>update_time</td><td>更新时间</td></tr><tr><td></td><td>create_user</td><td>创建人</td></tr><tr><td></td><td>update_user</td><td>修改人</td></tr><tr><td>Good</td><td>id</td><td>主键</td></tr><tr><td></td><td>name</td><td>商品名</td></tr><tr><td></td><td>price</td><td>该商品的售价</td></tr><tr><td></td><td>Brand</td><td>该商品所属的品牌</td></tr><tr><td></td><td>Create_time</td><td>创建时间</td></tr><tr><td></td><td>update_time</td><td>更新时间</td></tr><tr><td></td><td>create_user</td><td>创建人</td></tr><tr><td></td><td>update_user</td><td>修改人</td></tr><tr><td></td><td>Img</td><td>商品图片URL</td></tr><tr><td>Employee</td><td>id</td><td>主键</td></tr><tr><td></td><td>name</td><td>员工姓名</td></tr><tr><td></td><td>status</td><td>状态 0:禁用，1:正常</td></tr><tr><td></td><td>username</td><td>用户名</td></tr><tr><td></td><td>password</td><td>密码</td></tr><tr><td></td><td>phone</td><td>手机号</td></tr><tr><td></td><td>sex</td><td>性别</td></tr><tr><td></td><td>Id_number</td><td>身份证号</td></tr><tr><td></td><td>Create_time</td><td>创建时间</td></tr><tr><td></td><td>update_time</td><td>更新时间</td></tr><tr><td></td><td>create_user</td><td>创建人</td></tr><tr><td></td><td>update_user</td><td>修改人</td></tr></tbody></table><p>表2.2 数据库各表及其表项含义</p>图2.4 数据库ERD图<h3 id="后端设计"><a href="#后端设计" class="headerlink" title="后端设计"></a>后端设计</h3><p><strong>需求：</strong></p><p>●使用springcloud微服务框架，将客户端单独部署到新的服务器集群</p><p>●实现管理端所有功能且给出所用到的所有接口：员工,商品,品牌接口</p><p><strong>设计方案：</strong></p><p><strong>(Ⅰ).采用到的springcloud组件：</strong></p><p><strong>(1).Nacos注册服务中心</strong></p><p>将项目拆分成多个微服务，如员工管理服务、商品管理服务、品牌管理服务。微服务数据独立，微服务将自己的业务暴露为接口，供其它微服务调用。各个微服务之间的相互发现和互动都会通过nacos。</p><p>其中每个服务部署两个实例。</p><p>图2.5 项目部署的nacos图</p><p><strong>(2).feign远程调用</strong></p><p>利用feign实现在各微服务之间发起远程调用；</p><p>图2.6 项目使用到的feign接口</p><p><strong>(3).gateWay网关</strong></p><p>网关作为整体微服务项目入口，需要校验用户是是否有请求资格，如果没有则进行拦截，且实现跨域问题；</p><p>设定gateWay端口为10010，强制客户只能通过10010端口访问，确保安全性。</p><p><strong>(4).Sentinel实现流量控制</strong></p><p>微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务；利用sentinel进行流量控制实时监控流量防止雪崩问题的出现。</p><p>图2.7 项目部署的sentinel图</p><p><strong>(Ⅱ)Springcloud分为以下几个模块：</strong></p><p>图2.8 Maven项目结构图</p><p><strong>(1). Mail-employee模块：</strong></p><p>●静态映射backend前端资源并部署上服务器（WebMvcConfig）</p><p>●设置全局异常处理器，负责全局处理异常方法(GlobalExceptionHandler)</p><p>●根据需求，自己应用新的json对象转换器，扩展mvc框架的消息转换器（JacksonObjectMapper）</p><p>●配置MP的分页插件（MybatisPlusConfig）</p><p>●员工登录接口</p><p>●员工退出</p><p>●新增员工</p><p>●员工信息分页查询</p><p>●根据id修改员工信息</p><p>●根据id查询员工信息</p><p><strong>(2).Mail-brand模块：</strong></p><p>●新增品牌</p><p>●品牌信息分页查询</p><p>●根据id修改品牌信息</p><p>●根据id查询品牌信息</p><p>●根据品牌名让修改品牌总数</p><p>●返回指定品牌的总数</p><p><strong>(3).Mail-good模块：</strong></p><p>●新增商品</p><p>●商品信息分页查询</p><p>●根据id修改商品信息</p><p>●根据id查询商品信息</p><p>●用于手机端打开展示goodslist</p><p><strong>(4).Mail-loginMessage模块：</strong></p><p>●随机生成验证码</p><p>●调用api向指定手机号发送验证码</p><p><strong>(5).gateWay模块：</strong></p><p>网关作为整体微服务项目入口，需要校验用户是是否有请求资格，如果没有则进行拦截，且实现跨域问题；</p><p>设定gateWay端口为10010，强制客户只能通过10010端口访问，确保安全性</p><p><strong>(6).短信服务api：</strong></p><p>选用的是aliyun短信服务，需要小心公开仓库暴露专属个人的key，因为在Code中会使用到aliyun给出的key，如果不加密直接放在github的公开仓库中，就有key暴露的安全风险。</p><p>图2.9 aliyun短信服务</p><p><strong>(Ⅲ)Axios跨域问题：</strong></p><p>利用的是SpringCloud的GateWay解决，原生的网关帮助解决了cors跨域请求，解决了axios不能直接跨域的问题，很方便快捷</p><p>Axios的解决经过：</p><p>1. 首先小组尝试在前端设计时候通过利用一个代理服务器解决cors跨域，但是部署和配置过程繁琐最终尝试一下午后放弃。</p><p>2. 临时使用apifox模拟后端接口Mock发回数据以此保证前端项目继续工作，暂时跳过跨域问题阻碍。</p><p>3. 后端在后期成功通过gateWay利用网关解决了前端axios跨域问题。</p><h3 id="2-3-3-前端设计"><a href="#2-3-3-前端设计" class="headerlink" title="2.3.3 前端设计"></a>2.3.3 前端设计</h3><p>前端设计分为四个部分，以及对应的js组成：</p><p>图2.10 前端页面</p><p>login：登录页面</p><p>member：员工管理页面</p><p>good：货品管理页面</p><p>brand：品牌管理页面</p><p>其中member、good、brand较为类似，仅以<strong>member为例</strong>讲解</p><p><strong>(1).Login</strong></p><p>el-form组件实现表单的设计，使表单的样式整齐划一；</p><p>用el-form标签将表单控件包裹起来，每个控件使用el-form-item标签包裹起来，这样产生的表单就会比较整齐；</p><p>el-input组件实现文本框的输入，el-button实现提交按钮。</p><p>图2.11 管理员端登录界面</p><p><strong>Login-javascript：</strong></p><p>初始验证数据：</p><p>前端对输入信息的初次验证：</p><p>调用loginApi完成对账号密码的验证：</p><p>失败则弹出错误信息并放回false：</p><p><strong>(2).Member</strong></p><p>Member可以分为add和list页面，大体技术相似，以list为例：</p><p>el-input实现输入查找框(初始显示浅色文本“请输入员工姓名”)：</p><p>图2.12 查找框</p><p>当点击回车后，响应事件handleQuery：</p><p>图2.13 list实现</p><p>el-table实现数据的展示和分页，el-table-column完成每一列信息的具体要求</p><p>图2.14 数据展示与分页</p><p>el-button实现添加员工的跳转和编辑禁用设置，点击后分别响应事件“addMemberHandle”、“statusHandle”</p><p>图2.15 员工编辑与禁用</p><p><strong>Member-javascipt：</strong></p><p>先获取当前登录员工的账号，并赋值给模型数据user：</p><p>响应添加或者修改员工信息时分别携带不同信息进行跳转add页面：</p><p>禁用完成状态的修改：</p><p><strong>分页出错问题</strong>：</p><p>这里由于我们在修改前端每页容纳的数据条数Size时，会同时触发handleSizeChange和handleCurrentChange事件；</p><p>由于同时的响应，可能会导致Currentpage的页码大于总页码的情况；</p><p>因此，我们采用延时技术，将handleSizeChange延时处理，先后完成就不会出现溢出查找的情况。</p><h2 id="2-4-设计客户手机端"><a href="#2-4-设计客户手机端" class="headerlink" title="2.4 设计客户手机端"></a>2.4 设计客户手机端</h2><p>图2.16 客户手机端顶层DFD图</p><p><strong>需求：</strong></p><p>●要求客户能从手机端访问项目，并且要能够适应手机端的窗口大小和操作</p><p>●要求可以手机短信登录，要求可以定位</p><h3 id><a href="#" class="headerlink" title></a></h3><p><strong>设计：</strong></p><p>采用主流的前后端分离，并且设计方案是单页面vue，设计思路也简洁明了，获取mail_good接口数据，再通过vue组件呈现</p><p>页面说明：</p><table><thead><tr><th>页面</th><th>说明</th></tr></thead><tbody><tr><td>Login</td><td>客户手机端的登录页面</td></tr><tr><td>Home</td><td>浏览商品加入购物车页面</td></tr><tr><td>Location</td><td>定位收货地址并下单页面</td></tr></tbody></table><p><strong>(1).Login介绍：</strong></p><p>通过客户输入的手机号作为参数，向后端发送axios请求调用短信登录接口，实现登录</p><p>通过验证随机生成的四位验证码对比输入的验证码来确定登录</p><p><strong>(2).Home介绍：</strong></p><p>图2.17 Home页面内组件设计图</p><p>组件说明：</p><table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td>Counter</td><td>实时统计购物车合计价格</td></tr><tr><td>Footer</td><td>浏览商品的底部购物车选框</td></tr><tr><td>Goods</td><td>商品信息组件</td></tr><tr><td>Header</td><td>浏览商品的头部信息选框</td></tr></tbody></table><p><strong>(3).Location介绍：</strong></p><p>使用的是vue-baidu-map。用于下单时候的定位收货地址。</p><p>在百度地图的api官网中只有js版本，于是vue使用的版本需要自行去npm搜索。</p><p>图2.18 vue-baidu-map</p><p><strong>(4).使用拖拽式生成页面：</strong></p><p>本模块使用的是<a href="https://vcc3.sahadev.tech/">https://vcc3.sahadev.tech/</a></p><p>对于新手入门速成vue和html，我们选择使用简单设计网页模板可以使用拖拽式组件生成，这样就可以利用拖拽使用ElementPlus等组件</p><p>图2.19 网页设计模板</p><p><strong>(5).引入依赖方式：</strong></p><p>(a).项目最初采用的是直接全局引入依赖，随着开发到后期，在vue引入的依赖越来越多，每次构建新组件都需要重复大量引入，特别麻烦。</p><p>(b).改为动态按需引入依赖，所需要的改动远比全局引入依赖小。</p><p>图2.20 动态引入依赖后的vite.config.js</p><h2 id="2-5-项目部署"><a href="#2-5-项目部署" class="headerlink" title="2.5 项目部署"></a>2.5 项目部署</h2><p><strong>管理员端项目</strong>部署需要一台Jenkins服务器，服务器在安装配置Jenkins之前还需要安装git客户端、上传jdk、安装maven、安装docker及设置相应环境变量，之后下载 jenkins 的安装包，启动Jenkins。</p><p>之后便使用Jenkins构建部署任务对项目实现自动化部署：</p><p>1．安装 Jenkins 和相关插件：首先需要安装 Jenkins 服务器，并安装需要使用的插件。</p><p>2．创建 Jenkins 任务：在 Jenkins 中创建一个新的任务，并配置源代码管理、构建触发器、构建环境和构建步骤等相关信息。</p><p>图2.21 Jenkins构建任务配置</p><p>3．设置权限：确保只有授权的用户才能访问 Jenkins 任务并操作。</p><p>4．配置构建步骤：根据项目的实际情况，设置合适的构建步骤，包括编译代码、执行单元测试、打包、部署等。</p><p>5．监控构建状态：通过 Jenkins 的构建历史和日志功能，监控构建的状态和输出信息，以便及时发现并解决问题。</p><p><strong>客户端项目</strong>同样部署在Jenkins服务器中，需要安装并启动nginx、修改其nginx.conf文件的项目dist地址以发布项目及修改操作用户(root)：</p><p>图2.22 nginx修改配置</p><p>3. 实现结果</p><h2 id="3-1-软件开发"><a href="#3-1-软件开发" class="headerlink" title="3.1 软件开发"></a>3.1 软件开发</h2><p>管理端入口(已停止服务器)：<a href="http://120.79.55.22:10010/backend/index.html">http://120.79.55.22:10010/backend/index.html</a></p><p>客户手机端入口(已停止服务器)：http:&#x2F;47.92.244.182&#x2F;#&#x2F;login</p><h3 id="管理员端"><a href="#管理员端" class="headerlink" title="管理员端"></a>管理员端</h3><p><strong>(1).账号登录</strong></p><p>管理员&#x2F;员工可以通过账号密码进行登录：</p><p>图3.1 管理员端登录页面</p><p><strong>(2).进入管理页(成功登录)</strong></p><p>管理员能在此界面管理员工，商品，品牌。并且能对员工权限进行禁用；</p><p>员工仅可以在这个界面管理商品，品牌；</p><p>右侧整个数据的展示并且采用了分页设计，设定每2条数据为1页。</p><p>图3.2 管理员端管理主页</p><p><strong>(3).对数据进行新增(以新增员工为例)</strong></p><p>可以新增一个员工。在输入新员工的信息时会自动检测账号是否已经被使用，自动检测手机号是否符合格式，自动检测身份证号是否符合，如果出现不符合情况都会给出对应提示</p><p>图3.3 新增员工功能</p><p>图3.4 自动检验手机号格式</p><p><strong>(4).对已有数据进行修改(以修改某员工为例)</strong></p><p>图3.5 修改员工信息</p><h3 id="客户手机端"><a href="#客户手机端" class="headerlink" title="客户手机端"></a>客户手机端</h3><p><strong>(1).手机登录</strong></p><ol><li>提示条提示：请输入手机号</li><li>客户输入手机号</li><li>提示条提示：请点击获取验证码</li><li>项目在后端随机生成4位验证码，将验证码以短信形式发送给客户输入的手机号，同时验证码code返回给前端</li><li>提示条提示：请输入验证码并登录</li><li>前端验证客户输入验证码是否和此前生成验证码一样,登录成功&#x2F;失败</li></ol><p><img src="/shizhuofan.GitHub.io/media/ed4ee9d0caab0fd87c23d6ba34d94c73.png"><img src="/shizhuofan.GitHub.io/media/4f4168eeec88ab5edcc013f09f93c2c1.jpeg"></p><p>图3.6 手机登录界面及验证码</p><p><strong>(2).浏览商品和加入购物车</strong></p><p>1.页面会逐条展示购物平台中的待售商品以及价格</p><p>2.客户可以选中某个商品，并且选择购买此商品的数量，加入购物车</p><p><img src="/shizhuofan.GitHub.io/media/59ef27cadefbf12d294fcab3feaa7e8b.png"><img src="/shizhuofan.GitHub.io/media/c930df70742057031bb9d1b9f1589f86.png"></p><p>图3.7 商品页面及实时显示价格</p><p><strong>(3).定位确定收货地址并下单</strong></p><p>(1).用户能点击自动定位由地图api自动获取当前位置设置下单地址</p><p>(2).用户确定地址之后点击下单，完成下单</p><p><img src="/shizhuofan.GitHub.io/media/cc9ce0f3cffd1eeae28b9c2ede54e8a7.png"><img src="/shizhuofan.GitHub.io/media/2910d249a8be0c5353ccd842ae8bfaf8.png"></p><p>图3.8 定位位置并成功下单</p><h2 id="3-2架构部署"><a href="#3-2架构部署" class="headerlink" title="3.2架构部署"></a>3.2架构部署</h2><p><strong>3.2.1 jenkins自动部署</strong></p><p>首先，Jenkins与gitlab关联webhook设置测试成功，当有代码被推送到gitlab仓库时，Jenkins会自动拉取gitlab代码进行自动化部署。</p><p>图3.9 Jenkins与gitlab关联</p><p>Jenkins自动化部署项目控制台输出：</p><p>图3.10 Jenkins自动化部署项目成功</p><p>在服务器上可以查看相应项目镜像及docker容器创建并成功运行，项目成功运行之后的操作界面即为上述软件开发中管理员端展示的界面</p><p>图3.11 Jenkins服务器容器镜像列表</p><p><strong>3.2.2 nginx 部署客户手机端项目</strong></p><p>修改nginx.conf文件，location中配置dist的实际路径</p><p>图3.12 修改的nginx.conf文件</p><p>可以看到nginx服务已经成功启动，且之后的项目的操作界面即为上述的客户手机端展示的操作界面。</p><p>图3.13 nginx正常启动部署客户端项目</p><p>4.总结</p><h2 id="1-石卓凡："><a href="#1-石卓凡：" class="headerlink" title="(1).石卓凡："></a>(1).石卓凡：</h2><p><strong>①</strong>网络上的经验帖子具有时效性和针对性，对于不同版本，或者几年前的帖子，同一个问题的解决办法很有可能不适用。</p><p>比如请求goods数据中vue3的axios跨域问题</p><p>(ⅰ)网络博客关于vue2的解决方案不适合</p><p>因为vite.config.js在vue3中存在于根目录，而在vue2中存在于config文件夹并且import Vue from ‘vue’这条语句在Vue3基本上弃用，但是在Vue2还在使用，而网络上给出的方案用的都是import Vue from ‘vue’导致报错冲突</p><p>(ⅱ)网络博客针对vue-cli脚手架或者含webpack或者vite2.x的解决方案不适合，因为本项目后面改用的是vite3.x脚手架，项目结构基本不一致，这会导致同一位置的配置文件在vite下不会生效。由于最初使用的vite2.x的脚手架无法识别vite.config.js配置文件，还将这个模块重新移植到vite3.x</p><p><strong>②</strong>目前有许多现成的可视化操作软件可以方便我们的设计。比如k8s的kubesphere，docker的dockerDesktop，github的githubDesktop都可以方便我们的操作。</p><p><strong>③</strong>使用springcloud的一些心得：</p><p>分布式系统的复杂性：在使用Spring Cloud时，需要注意分布式系统带来的复杂性，这些复杂性包括网络分区、服务故障和超时等。需要确保系统能够应对这些挑战；</p><p>服务注册与发现：Spring Cloud使用nacos来实现服务注册和发现。在使用nacos时，需要注意服务的状态和健康检查；</p><p>负载均衡：Spring Cloud使用Ribbon来实现负载均衡。在使用Ribbon时，需要注意负载均衡策略和超时设置。</p><h2 id="2-苏泽楷："><a href="#2-苏泽楷：" class="headerlink" title="(2).苏泽楷："></a>(2).苏泽楷：</h2><p><strong>①在使用Jenkins进行项目自动化部署时，需要注意以下几点：</strong></p><p>1．安装 Jenkins 和相关插件：首先需要安装 Jenkins 服务器，并安装需要使用的插件。</p><p>Jenkins安装插件需要替换源地址，其官网的下载地址国内应该是下载不了的，网络中大多数教程中都是在jenkins插件配置里使用<a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json%E6%9B%BF%E6%8D%A2%E4%B8%BA%E4%BA%86%E6%B8%85%E5%8D%8E%E6%BA%90%E5%9C%B0%E5%9D%80%E3%80%82%E4%BD%86%E6%98%AF%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E8%B7%AF%E5%BE%84%E5%85%B6%E5%AE%9E%E6%98%AF%E6%B2%A1%E5%8F%98%E7%9A%84%EF%BC%8C%E5%8F%98%E7%9A%84%E5%8F%AA%E6%98%AF%E8%BF%99%E4%B8%AAjson%E6%98%AF%E4%BB%8E%E6%B8%85%E5%8D%8E%E6%BA%90%E4%B8%8B%E6%9D%A5%E7%9A%84%EF%BC%8C%E5%85%B6%E5%86%85%E7%9A%84%E6%8F%92%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E6%98%AF%E6%B2%A1%E6%9C%89%E5%8F%98%E7%9A%84%EF%BC%8C%E8%BF%98%E6%98%AF%E4%BB%8E%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E3%80%82%E5%9B%A0%E6%AD%A4%EF%BC%8C%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BF%AE%E6%94%B9%E6%BA%90%E5%BA%94%E8%AF%A5%E6%98%AF%E8%BF%9B%E5%85%A5Jenkins%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%B0%86default.json%E9%87%8C%E6%89%80%E6%9C%89%E7%9A%84updates.jenkins-ci.org%E6%9B%BF%E6%8D%A2%E4%B8%BAmirrors.tuna.tsinghua.edu.cn%E3%80%81www.google.com%E6%9B%BF%E6%8D%A2%E4%B8%BAwww.baidu.com%EF%BC%9A">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json替换为了清华源地址。但是，这样插件下载路径其实是没变的，变的只是这个json是从清华源下来的，其内的插件下载地址是没有变的，还是从官网下载。因此，正确的修改源应该是进入Jenkins工作目录，将default.json里所有的updates.jenkins-ci.org替换为mirrors.tuna.tsinghua.edu.cn、www.google.com替换为www.baidu.com：</a></p><p>2．创建 Jenkins 任务：在 Jenkins 中创建一个新的任务，并配置源代码管理、构建触发器、构建环境和构建步骤等相关信息。</p><p>3．设置权限：确保只有授权的用户才能访问 Jenkins 任务并执行操作。</p><p>4．配置构建步骤：根据项目的实际情况，设置合适的构建步骤，包括编译代码、执行单元测试、打包、部署等。</p><p>5．监控构建状态：通过 Jenkins 的构建历史和日志功能，监控构建的状态和输出信息，以便及时发现并解决问题。</p><p><strong>②Jenkins使用心得：</strong></p><p>1.Jenkins 提供了丰富的插件，可以帮助用户更方便地实现持续集成和自动化部署。</p><p>2.在使用 Jenkins 进行自动化部署时，要注意保证构建环境的稳定性，并对构建过程中出现的问题进行及时处理。建议定期备份 Jenkins 的配置和构建历史。</p><p>3.可以使用 Jenkins 的 Pipeline 功能来实现更加复杂的构建流程，并支持代码化的方式编写构建脚本。</p><p>4.可以使用 Jenkins 的插件来实现对构建结果的可视化，方便我们更直观地了解构建的状态。</p><p>5.建议使用 Jenkins 的安全功能来保护构建环境，比如使用安全登录、访问控制、数据加密等手段。</p><p>总之，使用 Jenkins 可以帮助用户更有效地实现持续集成和自动化部署，提高项目的开发效率和质量。</p><p><strong>③使用 nginx 部署前端项目时，需要注意以下几点：</strong></p><p>1. 安装 nginx 服务器：首先需要在服务器上安装 nginx ，并配置服务器的监听端口和访问权限等信息。</p><p>2．配置 nginx 虚拟主机：在 nginx 中创建一个虚拟主机，并配置虚拟主机的域名、服务器根目录和访问权限等信息。</p><p>3．发布前端项目文件：将前端项目打包后上传到虚拟主机的服务器根目录中，以便访问。</p><p>4．配置前端路由：在前端项目中配置路由规则，以便在不同的路径下显示不同的内容。</p><p>一些使用心得：</p><p>1. 使用 nginx 可以更方便地将前端项目部署到服务器上，方便访问。</p><p>2. 使用 nginx 部署前端项目时，要注配置虚拟主机的域名和服务器根目录，确保能够正确访问前端项目文件。</p><p>3. 可以使用 nginx 的反向代理功能来解决跨域问题，并使用加密协议来保护前端项目的安全性。</p><h2 id="3-艾永亮："><a href="#3-艾永亮：" class="headerlink" title="(3).艾永亮："></a>(3).艾永亮：</h2><p><strong>①el-table实现页面size更改时要注意：</strong></p><p>1.el-pagination的@size-change事件和@current-change冲突，导致切换每页显示条数时，偶尔会出现无数据的情况</p><p>2.这里由于我们在修改前端每页容纳的数据条数Size时，会同时触发handleSizeChange和handleCurrentChange事件。</p><p>3.由于同时的响应，可能会导致Currentpage的页码大于总页码。</p><p>4.因此我们采用延时技术，将handleSizeChange延时处理，先后完成就不会出现溢出查找的情况。</p><p><strong>②el-table实现分页时要注意：</strong></p><p>1.分页的核心是tableData.slice这一句代码，利用了slice方法把数据源tableData进行分割，但实际上是请求了所有的数据，然后实现前端假分页显示。<br> 2.还有一种分页的思想就是给后台传入如上的参数currentPage和pag</p><p>esize的值，告诉后台，我们需要[(currentPage-1)*pagesize,currentPag</p><p>e*pagesize]这一个区间的数据，让后台返回来。</p><p><strong>③这两种方法各有利弊：</strong></p><p>如果是前者前端控制分页的方法，因为本质是请求了所有的数据，如果这个数据量非常大，涉及到了几百，几千甚至几万数据，第一页的table数据加载的时间就会非常慢，因为它把后面的数据都拿过来了，用户体验非常不好，对内存空间也很不友好。明明只显示了几十条的数据，却为此存了几万条的数据，明显后者的效率会好些。但是它也是有好处的，好处就是如果在数据量小的情况下，第一页table加载速度用户也能接受的情况下，用户之后点击切换页面按钮或者直接跳转到哪个页面都不需要发起请求即可显示出数据，速度非常快。</p><p>5.对课程的建议</p><p><strong>1.关于前置知识</strong></p><p>希望多加入一些前置知识，比如springboot之类的，上这门课拥有一些前置知识之后上课会发现收获的更多；又或者一些前端的前置知识，比如javascript或者一些前端常见的技术问题，这样在学习前端或者大作业实践的时候会更加方便。</p><p><strong>2.关于实验部分</strong></p><p>实验内容和实验指导书可以更新一下，目前的指导书还存在着版本过时问题导致配置出错的问题，并且实验内容有的可以改为让同学自己搭建一个简单的springboot项目；并且实验指导书上，相关步骤说明较少，实际操作与理解都较为困难。</p><p><strong>3.关于Jenkins和k8s实战</strong></p><p>希望以后的课可以多加入一些教怎么样去实际操作jenkins和k8s的课上内容。个人认为很有性价比，在没有老师指导自己去摸索的情况下所要花费的代价太大且有不少的坑。</p><p><strong>4.关于前后端交互</strong></p><p>希望能多讲一些前后端交互的知识和案例，现如今开发大多为前后端分离团队协作，前后端交互和团队的沟通协作就显得更为重要。</p>]]></content>
    
    
    <categories>
      
      <category>面向服务的软件系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向服务的软件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《面向服务的软件系统》实验2指导书tips</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E3%80%8A%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%8B%E5%AE%9E%E9%AA%8C2%E6%8C%87%E5%AF%BC%E4%B9%A6tips%20/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E3%80%8A%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%8B%E5%AE%9E%E9%AA%8C2%E6%8C%87%E5%AF%BC%E4%B9%A6tips%20/</url>
    
    <content type="html"><![CDATA[<p>《面向服务的软件系统》实验2指导书tips</p><p>-Szf</p><p>目录</p><p><a href="#mvn%E6%89%93%E5%8C%85%E5%91%BD%E4%BB%A4">Mvn打包命令 1</a></p><p><a href="#%E8%B7%AF%E5%BE%84%E4%B8%8D%E8%83%BD%E6%9C%89%E4%B8%AD%E6%96%87">路径不能有中文 1</a></p><p><a href="#tomcat%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98">Tomcat控制台乱码问题： 1</a></p><p><a href="#%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98">端口问题 2</a></p><p><a href="#pom%E6%96%87%E4%BB%B6">Pom文件 2</a></p><p><a href="#log4jproperties">log4j.properties 2</a></p><p><a href="#%E5%A6%82%E6%9E%9C%E9%81%87%E4%B8%8Afailed-to-start-qos">如果遇上failed to start qos 3</a></p><h3 id="Mvn打包命令"><a href="#Mvn打包命令" class="headerlink" title="Mvn打包命令"></a>Mvn打包命令</h3><p>mvn install ‘-Dmaven.test.skip&#x3D;true’</p><p>如果是要在idea这种的终端来执行mvn命令需要加入’’</p><h3 id="路径不能有中文"><a href="#路径不能有中文" class="headerlink" title="路径不能有中文"></a>路径不能有中文</h3><p>&lt;Context docBase&#x3D;”D:&#x2F;360MoveData&#x2F;Users&#x2F;86189&#x2F;Desktop&#x2F;Service-oriented technology development&#x2F;lab2&#x2F;dubbox-master&#x2F;dubbo-admin&#x2F;target&#x2F;dubbo-admin-2.8.4” path&#x3D;”” reloadable&#x3D;”false”&#x2F;&gt;</p><p>在这个context里面不能有中文</p><h3 id="Tomcat控制台乱码问题："><a href="#Tomcat控制台乱码问题：" class="headerlink" title="Tomcat控制台乱码问题："></a>Tomcat控制台乱码问题：</h3><p>因为idea平时是utf8，但是tomcat得是GBK才不乱码</p><p>可以查怎么修改tomcat的编码（startup乱码之后去conf找logging把UTF8换成GBK）</p><h3 id="端口问题"><a href="#端口问题" class="headerlink" title="端口问题"></a>端口问题</h3><p>因为tomcat和zookeeper默认端口都是8080</p><p>Zookeeper端口指定为8080</p><p>Tomcat改为端口8089</p><p>dubbo（在BootStrap代码中）端口要求是8888</p><p>访问<a href="http://localhost:8089/">http://localhost:8089/</a></p><p>避免端口冲突</p><h3 id="Pom文件"><a href="#Pom文件" class="headerlink" title="Pom文件"></a>Pom文件</h3><p>在provider和consumer的pom.xml因为指导书版本太老的问题，需要更正一下引入依赖</p><p>引入这三个，然后调整一下pom.xml</p><p>需要额外netty-all和kryo，并且更新dubbo版本</p><p>&lt;dependency&gt;</p><p>&lt;groupId&gt;io.netty&lt;&#x2F;groupId&gt;</p><p>&lt;artifactId&gt;netty-all&lt;&#x2F;artifactId&gt;</p><p>&lt;version&gt;4.1.32.Final&lt;&#x2F;version&gt;</p><p>&lt;&#x2F;dependency&gt;</p><p>&lt;dependency&gt;</p><p>&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</p><p>&lt;artifactId&gt;dubbo&lt;&#x2F;artifactId&gt;</p><p>&lt;version&gt;2.6.12&lt;&#x2F;version&gt;</p><p>&lt;&#x2F;dependency&gt;</p><p>&lt;dependency&gt;</p><p>&lt;groupId&gt;com.esotericsoftware&lt;&#x2F;groupId&gt;</p><p>&lt;artifactId&gt;kryo&lt;&#x2F;artifactId&gt;</p><p>&lt;version&gt;4.0.2&lt;&#x2F;version&gt;</p><p>&lt;&#x2F;dependency&gt;</p><h3 id="log4j-properties"><a href="#log4j-properties" class="headerlink" title="log4j.properties"></a>log4j.properties</h3><p>默认启动BootStarp和Test的java文件之后无法自动检测到log4j但是pom中也有依赖，需要自己在文件新建一个log4j</p><p>在resources加入log4j.properties</p><p><strong>log4j.properties的内容：</strong></p><p>log4j.rootLogger&#x3D;debug, stdout, R</p><p>log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender</p><p>log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout</p><p># Pattern to output the caller’s file name and line number.</p><p>log4j.appender.stdout.layout.ConversionPattern&#x3D;%5p [%t] (%F:%L) - %m%n</p><p>log4j.appender.R&#x3D;org.apache.log4j.RollingFileAppender</p><p>log4j.appender.R.File&#x3D;example.log</p><p>log4j.appender.R.MaxFileSize&#x3D;100KB</p><p># Keep one backup file</p><p>log4j.appender.R.MaxBackupIndex&#x3D;5</p><p>log4j.appender.R.layout&#x3D;org.apache.log4j.PatternLayout</p><p>log4j.appender.R.layout.ConversionPattern&#x3D;%p %t %c - %m%n</p><h3 id="如果遇上failed-to-start-qos"><a href="#如果遇上failed-to-start-qos" class="headerlink" title="如果遇上failed to start qos"></a>如果遇上failed to start qos</h3><p>法1：检查pom.xml是不是加入了上述tips的补充依赖，qos需要反序列化的那几个依赖</p><p>法2（没自己试过理论可行），修改provider.xml</p><p>&lt;**dubbo:application name&#x3D;”provider” owner&#x3D;”programmer” organization&#x3D;”dubbox”**&gt;<br> &lt;**dubbo:parameter key&#x3D;”qos.enable” value&#x3D;”true”**&#x2F;&gt;<br> &lt;**dubbo:parameter key&#x3D;”qos.accept.foreign.ip” value&#x3D;”false”**&#x2F;&gt;<br> &lt;**dubbo:parameter key&#x3D;”qos.port” value&#x3D;”33333”**&#x2F;&gt;<br>&lt;&#x2F;**dubbo:application**&gt;</p>]]></content>
    
    
    <categories>
      
      <category>面向服务的软件系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向服务的软件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《面向服务的软件系统》大作业选题报告</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E5%A4%A7%E4%BD%9C%E4%B8%9A%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A_%E7%9F%B3%E5%8D%93%E5%87%A1_%E8%8B%8F%E6%B3%BD%E6%A5%B7_%E8%89%BE%E6%B0%B8%E4%BA%AE/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E5%A4%A7%E4%BD%9C%E4%B8%9A%E9%80%89%E9%A2%98%E6%8A%A5%E5%91%8A_%E7%9F%B3%E5%8D%93%E5%87%A1_%E8%8B%8F%E6%B3%BD%E6%A5%B7_%E8%89%BE%E6%B0%B8%E4%BA%AE/</url>
    
    <content type="html"><![CDATA[<p><strong>大作业选题报告</strong></p><p><strong>课程：面向服务的软件系统</strong></p><p><strong>学 号  姓 名</strong></p><p><strong>成员：  120L021011  ， 石卓凡</strong></p><p><strong>成员：  120L020926  ， 苏泽楷</strong></p><p><strong>成员： 120L020205  ， 艾永亮</strong></p><h1 id="1-选题"><a href="#1-选题" class="headerlink" title="1.选题"></a>1.选题</h1><h2 id="1-1作业题目"><a href="#1-1作业题目" class="headerlink" title="1.1作业题目"></a>1.1作业题目</h2><p><strong>选题2： 基于微服务框架开发项目</strong></p><h2 id="1-2题目概述"><a href="#1-2题目概述" class="headerlink" title="1.2题目概述"></a>1.2题目概述</h2><p><strong>基于微服务的网络购物云平台</strong></p><p><strong>背景介绍：</strong></p><p>当今，网络经济模式越来越流行，其中电子商务是其中最重要的组成部分，是利用互联网技术与传统信息系统相连接的一种动态商务模式，它能将有价值的信息高效地传输给顾客、经销商等，并能通过网络将他们紧密地连接起来，形成新的产业链。成熟的互联网技术让订货、支付、售后等服务集成到电子商务中。互联网进入传统流通领域后，电子商务也流行起来，这意味着一种全新的购物理念的形成和发展。网络购物云平台是电子商务的前端商务平台，他在整个商务活动的过程中扮演着非常重要的角色。网上购物系统也是一种商业信息系统，它具有强大的交互功能，能向用户提供各种信息资源，能使商家和用户之间能方便地进行信息传递，方便快捷地完成电子贸易。随着互联网广泛的应用和发展使得网名数量激增，市场需求越来越大。网上购物方式日益为大家所接受。互联网的飞速发展，已经颠覆了传统的信息采集、传递和外观，对劳动者的劳动技能和工作效率的提高，提供了前所未有的有利条件和推进作用。个人经营，企业等的经济收入增长大多得益于互联网的推广和应用。网络购物云平台使市场的传统营销思路走向终结，新型的线上线下整合营销模式得到了企业和社会的广泛关注和认可。</p><p><strong>网络购物平台分为管理端和客户端：</strong></p><p><strong>管理端：</strong></p><p>该管理系统可以登录管理员账号，登录员工账号，管理员可以实现对某个电商交易平台的员工，商品，品牌分类等进行管理与查询。后台管理系统中的信息以便于客户手机端可以对电商商品进行下单。</p><p>针对开题报告的演示初步设计（如下图）：</p><p>图1:管理端初步demo页面设计</p><p><strong>客户端：</strong></p><p>客户可以进行登录，登录方式比如手机登录或者微信登录，然后对商品进行选购下单</p><p>展示结果类似于美团外卖（如下图）：</p><p>图2:客户端计划仿照的美团外卖app页面</p><h1 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h1><p>使用的技术知识</p><table><thead><tr><th><strong>分工层面</strong></th><th><strong>预期应用到的技术</strong></th></tr></thead><tbody><tr><td>前端</td><td>H5,Vue,ElementUI</td></tr><tr><td>后端</td><td>Springboot,springcloud</td></tr><tr><td>运维</td><td>Docker,k8s,jenkins</td></tr><tr><td>数据</td><td>Mysql,redis,mybatis plus</td></tr></tbody></table><p>网络购物平台采用微服务基础，基于springcloud，解决服务与服务之间的解耦，利用h5,vue等作为前端</p><p>网络购物平台部署于k8s可以实现容器集群的故障迁移，资源调度等，服务器集群具有很强的可伸缩性。随着需求和负荷的增长，可以向集群系统添加更多的服务器。允许有多台服务器执行相同的应用和数据库操作。</p><p>网络购物平台利用了Jenkins实现持续、自动地构建&#x2F;测试项目，监控软件开放流程，快速问题定位及处理，提高开发效率。</p><p><strong>1.实现电商后台网络购物平台基本功能</strong></p><p><strong>2.1 Springboot+vue搭建网站，通过网站管理电商商品，数据库在云服务器上</strong></p><p><strong>初步需求：</strong></p><p>管理端够对员工，商品，品牌分类进行管理与查询。后续可以根据实时需求添加对其余信息的管理</p><p>客户端能够进行购物下单，类似于简易版淘宝或者美团外卖。</p><p><strong>设计方案：</strong></p><p>在云服务器上运行mysql作为云数据库，数据库中含employee员工表，brand品牌表，good商品表；</p><p>图3.1：数据库表demo初步设计：</p><p>图3.2：数据库表demo初步设计：</p><p>本地Springboot+vue框架搭建分为：</p><p>(1).登录模块，设定admin管理员，以管理员身份登录index；</p><p>(2).index模块，由index模块可以进入员工管理，商品管理，品牌管理三个模块；</p><p>(3).员工管理，商品管理，品牌管理，每个模块对自己内容的管理都可以实现增删改查。</p><p>图4:管理端初步demo页面设计</p><p>（4）客户端模块，用于客户可以访问管理端存储的数据信息并且进行购物下单</p><p><strong>2.从单体项目扩展为分布式项目</strong></p><p><strong>2.2 将上一个项目加入springcloud扩展为分布式微服务系统</strong></p><p><strong>初步需求：</strong>将单体项目变为多个微服务，需要有网关，服务注册中心等，有高并发性能</p><p><strong>设计方案：</strong></p><p><strong>(1).加入Nacos注册服务中心</strong></p><p>将之前的项目拆分成多个微服务，比如登录服务，员工管理服务，商品管理服务，品牌管理服务。微服务数据独立，不要访问其它微服务的数据库，微服务可以将自己的业务暴露为接口，供其它微服务调用。各个微服务之间的相互发现和互动都会通过nacos。</p><p><strong>(2).加入feign远程调用</strong></p><p>利用feign实现在各微服务之间发起远程调用；</p><p>在index模块利用feign进行远程调用员工管理服务，商品管理服务，品牌管理服务，实现数据库操作。</p><p><strong>(3).加入gateWay网关</strong></p><p>网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截，且实现跨域问题；</p><p>让员工管理服务，商品管理服务，品牌管理服务等一切请求都必须经过网关，并利用网关实现axios跨域请求问题。</p><p><strong>(4).加入Sentinel实现流量控制</strong></p><p>微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务；利用sentinel进行流量控制实时监控流量防止雪崩问题的出现。</p><p><strong>3.项目部署上云</strong></p><ol><li><p><strong>将项目利用docker进行打包</strong></p><p><strong>初步方案：</strong>可以利用docker命令打包生成镜像之后上传于dockerHub</p><p><strong>部署环境：</strong>在本地虚拟机Ubuntu中安装配置docker环境，然后将项目打包发布于个人的docker Hub</p><ol><li><strong>将项目利用k8s部署到云服务器上，</strong></li></ol></li></ol><p><strong>初步方案：</strong>k8s读取dockerHub中的镜像，然后利用deployment部署pod，再利用service发布，并暴露端口供外网访问</p><p><strong>部署环境：</strong>aliyun三台服务器使用centors系统,利用k8s实现1主2从，能够在云服务器上运行电商后台网络购物平台</p><p><strong>4.项目实现自动化部署</strong></p><ol><li><p><strong>将项目通过Jenkins实现CI&#x2F;CD扩展能力</strong></p><p><strong>需求：</strong>JenKins实现CI&#x2F;CD</p></li></ol><p><strong>初步方案：</strong>Jenkins服务器安装配置Jenkins，创建任务，配置gitlab仓库地址，测试CI&#x2F;CD是否成功，即Jenkins能否将Git仓库项目成功编译测试并发布到Tomcat服务器上</p><h1 id="3-成员与分工"><a href="#3-成员与分工" class="headerlink" title="3.成员与分工"></a>3.成员与分工</h1><p>第一阶段Springboot+vue</p><table><thead><tr><th>分工任务</th><th>成员</th></tr></thead><tbody><tr><td>数据库+后端</td><td>石卓凡</td></tr><tr><td>前端</td><td>艾永亮</td></tr></tbody></table><p>第二阶段Springcloud</p><table><thead><tr><th>分工任务</th><th>成员</th></tr></thead><tbody><tr><td>数据库+后端</td><td>石卓凡</td></tr><tr><td>前端</td><td>艾永亮</td></tr></tbody></table><p>第三阶段docker</p><table><thead><tr><th>分工任务</th><th>成员</th></tr></thead><tbody><tr><td>运维</td><td>石卓凡</td></tr><tr><td>运维</td><td>苏泽楷</td></tr><tr><td>运维</td><td>艾永亮</td></tr></tbody></table><p>第四阶段k8s</p><table><thead><tr><th>分工任务</th><th>成员</th></tr></thead><tbody><tr><td>运维</td><td>石卓凡</td></tr><tr><td>运维</td><td>苏泽楷</td></tr><tr><td>运维</td><td>艾永亮</td></tr></tbody></table><p>第五阶段Jenkins</p><table><thead><tr><th>分工任务</th><th>成员</th></tr></thead><tbody><tr><td>运维</td><td>苏泽楷</td></tr></tbody></table><h1 id="4-进度计划"><a href="#4-进度计划" class="headerlink" title="4.进度计划"></a>4.进度计划</h1><p>1.前后端人员学习知识,Springboot+vue搭建网站通过网站管理电商商品</p><p>2022.10.10-2022.10.29</p><p>2.将上一个项目加入springcloud扩展为分布式微服务系统</p><p>2022.10.29-2022.11.12</p><p>3.运维人员学习知识，将项目利用docker进行打包</p><p>2022.11.12-2022.11.19</p><p>4.将项目利用k8s部署到云服务器上</p><p>2022.11.12-2022.11.26</p><p>5.运维人员学习知识，将项目通过Jenkins实现CI&#x2F;CD扩展能力，直接部署在云服务器上</p><p>2022.11.26-2022.12.10</p><p>6.完善项目，对于项目中可能存在的问题和bug进行调试</p><p>2022.12.10-2022.12.20</p>]]></content>
    
    
    
    <tags>
      
      <tag>面向服务的软件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E6%AF%8F%E6%97%A5%E8%AE%BA%E6%96%87/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E6%AF%8F%E6%97%A5%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="每日论文"><a href="#每日论文" class="headerlink" title="每日论文"></a>每日论文</h1><h2 id="A-Dynamic-Service-Placement-Based-on-Deep-Reinforcement-Learning-in-Mobile-Edge-Computing-2023-4-2"><a href="#A-Dynamic-Service-Placement-Based-on-Deep-Reinforcement-Learning-in-Mobile-Edge-Computing-2023-4-2" class="headerlink" title="A Dynamic Service Placement Based on Deep Reinforcement Learning in Mobile Edge Computing-2023.4.2"></a><strong>A Dynamic Service Placement Based on Deep Reinforcement Learning in Mobile Edge Computing</strong>-2023.4.2</h2><p><strong>不行</strong></p><p>这篇论文考虑的主要有用户迁移然后服务要跟着迁移，这里还考虑一个服务只专门服务一个用户，跟我的背景差别很大啊</p><p>State &#x3D; [r,u],r是剩余存储能力，u是用户当前位置</p><p>Action 是 多个服务迁移如：服务v迁移到服务w</p><p>reward也因此别人直接用某个公式做奖励了，我觉得不好借鉴</p><p>奖励 r 由多个移动用户的平均延迟反馈与 r 进行比较来衡量<img src="/shizhuofan.GitHub.io/2023/04/21/%E6%AF%8F%E6%97%A5%E8%AE%BA%E6%96%87/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20230403211230255.png" alt="image-20230403211230255"></p><h2 id="Online-Microservice-Orchestration-for-IoT-via-Multiobjective-Deep-Reinforcement-Learning-2023-4-2"><a href="#Online-Microservice-Orchestration-for-IoT-via-Multiobjective-Deep-Reinforcement-Learning-2023-4-2" class="headerlink" title="Online Microservice Orchestration for IoT via Multiobjective Deep Reinforcement Learning 2023.4.2"></a>Online Microservice Orchestration for IoT via Multiobjective Deep Reinforcement Learning 2023.4.2</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>校园点评-个人日志</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E6%A0%A1%E5%9B%AD%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E6%A0%A1%E5%9B%AD%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="校园点评项目中间件及数据库"><a href="#校园点评项目中间件及数据库" class="headerlink" title="校园点评项目中间件及数据库"></a>校园点评项目中间件及数据库</h1><p>启动项目以及快速复习参考：鱼皮笔记：<a href="https://bcdh.yuque.com/staff-wpxfif/resource/vwcn5s#cEfva">https://bcdh.yuque.com/staff-wpxfif/resource/vwcn5s#cEfva</a></p><p>1.mysql用8.0</p><p>2.redis用docker desktop</p><p>数据库名字叫hitdp</p><p>_redis没有密码</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E6%A0%A1%E5%9B%AD%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/image-20230414112351015.png" class title="image-20230414112351015"><p>3，nginx位于hitdp里面</p><p><img src="https://farsblog.oss-cn-beijing.aliyuncs.com/PicGo/202304211135667.png" alt="image-20230421113506598"></p><h1 id="待办："><a href="#待办：" class="headerlink" title="待办："></a>待办：</h1><ul><li><input disabled type="checkbox"> 改掉项目名字，我目前只改了数据库名字hitdp</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计网题目笔记</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017195102157.png" alt="image-20221017195102157"></p><p>1B&#x3D;8bit</p><p>1bps&#x3D;1bit&#x2F;s</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221015194408396.png" alt="image-20221015194408396"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015194854414.png" alt="image-20221015194854414"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015195210240.png" alt="image-20221015195210240"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015195428398.png" alt="image-20221015195428398"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015195907366.png" alt="image-20221015195907366"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015200330833.png" alt="image-20221015200330833"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015202240615.png" alt="image-20221015202240615">1</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015202824495.png" alt="image-20221015202824495"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015203518340.png" alt="image-20221015203518340"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015211129781.png" alt="image-20221015211129781"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015211145845.png" alt="image-20221015211145845"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015211314532.png" alt="image-20221015211314532"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015211539077.png"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015211550563.png" alt="image-20221015211550563"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015211806860.png" alt="image-20221015211806860"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221015214103306.png" alt="image-20221015214103306"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017154204745.png"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017154415622.png" alt="image-20221017154415622"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017155341312.png" alt="image-20221017155341312"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017160503331.png" alt="image-20221017160503331"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221018190252034.png" alt="image-20221018190252034"></p><h1 id="讲座1（概述）"><a href="#讲座1（概述）" class="headerlink" title="讲座1（概述）"></a>讲座1（概述）</h1><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109202051817.png" class title="image-20221109202051817"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109202847129.png" class title="image-20221109202847129"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109202931862.png" class title="image-20221109202931862"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109204013198.png" class title="image-20221109204013198"><p>1MB &#x3D; 1024KB</p><p>因为是1B&#x3D;8b，所以从10^3变成2^10</p><p>1Mb &#x3D; 1000 000 b</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109204108824.png" class title="image-20221109204108824"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109210426723.png" class title="image-20221109210426723"><p>带宽就是最大吞吐量(类似最大速度)</p><p>吞吐量就是当前实际的mb&#x2F;s（类似速度）  </p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109210628930.png" class title="image-20221109210628930"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109211159594.png" class title="image-20221109211159594"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109211323949.png" class title="image-20221109211323949"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109212200044.png" class title="image-20221109212200044"><p>讲座1（应用层）</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221109213915683.png" class title="image-20221109213915683"><p><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221110110012645.png" alt="image-20221110110012645"><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221110110019772.png" alt="image-20221110110019772"></p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221110161209999.png" class title="image-20221110161209999"><h1 id="讲座2（网络层）"><a href="#讲座2（网络层）" class="headerlink" title="讲座2（网络层）"></a>讲座2（网络层）</h1><h2 id="可靠传输（一般的方式）"><a href="#可靠传输（一般的方式）" class="headerlink" title="可靠传输（一般的方式）"></a>可靠传输（一般的方式）</h2><h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115160853860.png" alt="image-20221115160853860"><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115162419970.png" alt="image-20221115162419970"></p><p>对于GBN的信道利用率</p><p>N越大信道利用率越大</p><h3 id="GBN"><a href="#GBN" class="headerlink" title="GBN"></a>GBN</h3><p><strong>发送方对于：</strong></p><p>收到ACK累计确认</p><p>在GBN 协议中，对序号为n的分组的确认采取累积确认的方式，表明接收方已正确接收到序号为n的以前且包括n在内的所有分组</p><p>发送方仅使用一个定时器</p><p>如果收到 ACK, 但仍有已发送但未被确认的分组，则定时器被重新启动；如果没有巳发送但未被确认的分组，停止该定时器；如果出现超时，发送方重传所有已发送但还未被确认过的分组</p><p><strong>接收方</strong></p><p>对于乱序到达的分组直接丢弃    ACK机制：发送序列号最大的按序的ACK序号</p><h3 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h3><p><strong>发送方：</strong></p><p>每个分组必须拥有其自己的逻辑定时器，因为超时发生后只能发送一个分组</p><p>GBN和SR窗口</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115161829329.png" class title="image-20221115161829329"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115162018350.png" class title="image-20221115162018350"><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>包括了TCP如何实现可靠传输</p><p>TCP拥塞控制</p><h3 id="TCp可靠传输的方式"><a href="#TCp可靠传输的方式" class="headerlink" title="TCp可靠传输的方式"></a>TCp可靠传输的方式</h3><p>TCP序号是以字节为单位</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115170536527.png" class title="image-20221115170536527"><p>SR和gBN和停等协议都是确认号&#x3D;序号，且都是以报文段分组为单位</p><p>TCP协议是确认号&#x3D;序号+1，且是以字节Byte为单位</p><p>TCp协议就像是接收方可以缓存的GBN协议（发送方接收到的累计确认）</p><p>且接收方每次发回ACK都会告诉发送方自己的接收窗口实时还可以接收多少，会让发送方自己的发送窗口在每次收到ack之后都会调整自己的发送窗口（发送窗口上限值 &#x3D; MIn（发送方得知的接收窗口rwnd，拥塞窗口cwnd）</p><p>且发送方收到3次重复ACK之后也会重传，这时候的是rwnd减半（快重传）</p><p>TCP发送方在收到ACK确认之后才会将拥塞窗口增大！！！！</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115192721241.png" class title="image-20221115192721241"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115191945696.png" class title="image-20221115191945696"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115192115551.png" class title="image-20221115192115551"><p>TCP的拥塞控制</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115193832654.png" class title="image-20221115193832654"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115193847376.png" class title="image-20221115193847376"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115194108601.png" class title="image-20221115194108601"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115194358700.png" class title="image-20221115194358700"><h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p>连接建立三次握手</p><p>连接关闭四次握手 </p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20221115203153490.png" class title="image-20221115203153490"><h1 id="考研408真题"><a href="#考研408真题" class="headerlink" title="考研408真题"></a>考研408真题</h1><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230208143418790.png" class title="image-20230208143418790">1<img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210102804066.png" class title="image-20230210102804066"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210103721830.png" class title="image-20230210103721830">  <img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210163834280.png" class title="image-20230210163834280"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210163829625.png" class title="image-20230210163829625">1<img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210170251613.png" class title="image-20230210170251613"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210172807019.png" class width="1">11<img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210205930681.png" class title="image-20230210205930681"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210210711241.png" class title="image-20230210210711241"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210212831848.png" class title="image-20230210212831848"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210213610641.png" class title="image-20230210213610641"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230210213812671.png" class title="image-20230210213812671"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230211095643352.png" class title="image-20230211095643352">还有多少分配地址，这里也不要忘了-2，全0和全1<img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230212155051206.png" class title="image-20230212155051206"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230212161643526.png" class title="image-20230212161643526"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230212193753452.png" class title="image-20230212193753452"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230212194406109.png" class title="image-20230212194406109"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230212194749945.png" class title="image-20230212194749945"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213112304043.png" class title="image-20230213112304043"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213113620569.png" class title="image-20230213113620569"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213113647649.png" class title="image-20230213113647649"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213115556720.png" class title="，"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213115830202.png" class title="image-20230213115830202">9<p><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213121838857.png" alt="image-20230213121838857"><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213122843922.png" alt="image-20230213122843922"></p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213123439789.png" class title="image-20230213123439789"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213124559345.png" class title="image-20230213124559345"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213130629056.png" class title="image-20230213130629056"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213222411059.png" class title="image-20230213222411059"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213223719178.png" class title="image-20230213223719178"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213224051940.png" class title="image-20230213224051940"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213224631691.png" class title="image-20230213224631691"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213225254748.png" class title="image-20230213225254748"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213231523154.png" class title="image-20230213231523154"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230213234107330.png" class title="image-20230213234107330"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230214104304513.png" class title="image-20230214104304513"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230214115317532.png" class title="image-20230214115317532"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230214121513262.png" class title="image-20230214121513262"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230215103056975.png" class title="image-20230215103056975"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230215103544998.png" class title="image-20230215103544998"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230215103627668.png" class title="image-20230215103627668"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230215104753879.png" class title="image-20230215104753879"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230215105137106.png" class title="image-20230215105137106"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230215114731972.png" class title="image-20230215114731972"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230215135658710.png" class title="image-20230215135658710"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230217110151618.png" class title="image-20230217110151618"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230219111752934.png" class title="image-20230219111752934"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230219111813322.png" class title="image-20230219111813322"><p>D</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230219113000565.png" class title="image-20230219113000565"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pBY2tfY2hlbjAzMDk=,size_16,color_FFFFFF,t_70.jpeg" class title="在这里插入图片描述"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230219114155993.png" class title="image-20230219114155993"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/SouthEast.png" class title="img"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230219115010612.png" class title="image-20230219115010612"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E9%A2%98%E7%9B%AE/image-20230219120210097.png" class title="image-20230219120210097">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>谷粒商城个人笔记</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="个人改动"><a href="#个人改动" class="headerlink" title="个人改动"></a>个人改动</h1><p>完成了nginx动静分离，但是没有做FarsMall的域名.<br>我的流程:localhost:8888-&gt;nginx-&gt;nginx设置Header为FarsMall-&gt;nginx转给GateWay localhost:88 -&gt;GateWay只对Head为FarsMall的进行路由静态资源</p><h1 id="谷粒商城个人笔记"><a href="#谷粒商城个人笔记" class="headerlink" title="谷粒商城个人笔记"></a>谷粒商城个人笔记</h1><p><packaging>pom</packaging>      用在父级工程或聚合工程中。用来做jar包的版本控制。</p><p><packaging>jar</packaging>      将会打包成jar用作jar包使用，packaging默认类型。</p><p><packaging>war</packaging>      将会打包成war，发布在服务器上的工程。如网站或服务。</p><p>maven的父类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.xuecheng<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xuecheng-plus-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../xuecheng-plus-parent<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>xuecheng-plus-base<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br></code></pre></td></tr></table></figure><p>跨域问题，服务器对浏览器发起的OPTION询问返回的响应标头，如果有两个filter就会加两遍Access-Control标头内容，也会出错</p><h2 id="docker容器内部使用vim"><a href="#docker容器内部使用vim" class="headerlink" title="docker容器内部使用vim"></a>docker容器内部使用vim</h2><p>1.[linux文件创建命令是什么-linux运维-PHP中文网](<a href="https://www.php.cn/linux-490062.html#:~:text=%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4%E6%98%AF%EF%BC%9A1%E3%80%81%E2%80%9Cvi">https://www.php.cn/linux-490062.html#:~:text=文件创建命令是：1、“vi</a> 文件名”命令，该命令输入保存之后文件才被创建；2、“touch 文件名”命令，该命令用于更改文件或目录的时间，若文件不存在会自动创建；3、“echo,文件内容 &gt; 文件名”命令，该命令会将指定内容写入文件中。)</p><p>用echo命令新建&#x2F;etc&#x2F;apt&#x2F;sources.list，并赋值</p><p>(非必须，一般sources.list都默认有源仓库地址)</p><p>2.apt update</p><p>3.apt install vim</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vim">rm /etc/apt/sources.<span class="hljs-keyword">list</span><br><span class="hljs-keyword">cat</span> sources.<span class="hljs-keyword">list</span><br><span class="hljs-keyword">echo</span> <span class="hljs-comment">&quot;</span><br><span class="hljs-keyword">deb</span> http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal main restricted universe multiverse<br><span class="hljs-keyword">deb</span> http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-security main restricted universe multiverse<br><span class="hljs-keyword">deb</span> http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-updates main restricted universe multiverse<br><span class="hljs-keyword">deb</span> http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-backports main restricted universe multiverse<br>##測試版源<br><span class="hljs-keyword">deb</span> http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-proposed main restricted universe multiverse<br># 源碼<br><span class="hljs-keyword">deb</span>-src http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal main restricted universe multiverse<br><span class="hljs-keyword">deb</span>-src http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-security main restricted universe multiverse<br><span class="hljs-keyword">deb</span>-src http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-updates main restricted universe multiverse<br><span class="hljs-keyword">deb</span>-src http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-backports main restricted universe multiverse<br>##測試版源<br><span class="hljs-keyword">deb</span>-src http://<span class="hljs-keyword">cn</span>.archive.ubuntu.<span class="hljs-keyword">com</span>/ubuntu/ focal-proposed main restricted universe multiverse<br><span class="hljs-comment">&quot; &gt; sources.list</span><br>apt install <span class="hljs-keyword">vim</span><br>apt <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><h2 id="wsl打开wsl硬盘"><a href="#wsl打开wsl硬盘" class="headerlink" title="wsl打开wsl硬盘"></a>wsl打开wsl硬盘</h2><p>法1.资源管理器中输入\\wsl$</p><p>法2.</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/image-20230224170030681.png" class title="image-20230224170030681"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/image-20230224170038323.png" class title="image-20230224170038323"><h2 id="打开jvisualvm"><a href="#打开jvisualvm" class="headerlink" title="打开jvisualvm"></a>打开jvisualvm</h2><p>cmd输入jvisualvm</p><h2 id="WSL和win互通"><a href="#WSL和win互通" class="headerlink" title="WSL和win互通"></a>WSL和win互通</h2><p>1、在WSL子系统中，使用下面的命令。获取WSL的ip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip addr | grep eth0<br></code></pre></td></tr></table></figure><p>wsl 172.29.64.13</p><p>在win查看自己win的ip可以供win和wsl访问</p><p>ipconfig</p><p>172.20.175.49</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/image-20230301131343209.png" class title="image-20230301131343209"><p>主要是防火墙</p><h2 id="powshell和cmd不一样"><a href="#powshell和cmd不一样" class="headerlink" title="powshell和cmd不一样"></a>powshell和cmd不一样</h2><h2 id="sql索引会加快速度"><a href="#sql索引会加快速度" class="headerlink" title="sql索引会加快速度"></a>sql索引会加快速度</h2><h2 id="nginx的配置"><a href="#nginx的配置" class="headerlink" title="nginx的配置"></a>nginx的配置</h2><p><strong>用的是wsl的虚拟机，就是每次都是动态ip需要自己去修改才能启动</strong></p><p>启动命令是</p><p>前面是ubuntu，后面是nginx容器</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> --name nginx <br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/conf/</span>nginx.conf:<span class="hljs-regexp">/etc/</span>nginx/nginx.conf <br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/conf/</span>conf.d:<span class="hljs-regexp">/etc/</span>nginx/conf.d <br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/log:/</span>var<span class="hljs-regexp">/log/</span>nginx <br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/html:/u</span>sr<span class="hljs-regexp">/share/</span>nginx/html <br>-d nginx:latest<br></code></pre></td></tr></table></figure><p>在容器中是&#x2F;etc&#x2F;nginx</p><p>在宿主Ubuntu中是</p><p>&#x2F;home&#x2F;nginx&#x2F;</p><p>&#x2F;home&#x2F;nginx&#x2F;html&#x2F;</p><h2 id="HOST域名配置问题"><a href="#HOST域名配置问题" class="headerlink" title="HOST域名配置问题"></a>HOST域名配置问题</h2><p>本机.HOSTS中 FarsMall和farsmall同属于一个</p><p>同时输入网站<a href="http://www.baidu.com和www.baidu.com都同属于一个,转为www.baidu.com/">www.BAIDU.com和www.baidu.com都同属于一个，转为www.baidu.com</a></p><p>gateway验证时候的HOST的FarsMall和farsmall又不同属于一个,应该写farsmall</p><p>1.不要重复配置farsmall.com和FarsMall.com冲突</p><p>2.chrome:&#x2F;&#x2F;net-internals&#x2F;?#dns   更新HOST之后要清理以前的DNS缓存</p><h2 id="githug远程仓库add之后出现嵌套仓库"><a href="#githug远程仓库add之后出现嵌套仓库" class="headerlink" title="githug远程仓库add之后出现嵌套仓库"></a>githug远程仓库add之后出现嵌套仓库</h2><p>.git是隐藏文件，只有在资源管理器才可以见到</p><p>idea看不见.git文件夹</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/image-20230301190614534.png" class title="image-20230301190614534"><p>如果你添加了一个已经是git仓库的文件夹，那么git会认为它是一个submodule，并且只会记录它的路径和版本号，而不会跟踪它的内容 。这样做的目的是为了保持子模块和父项目之间的独立性和灵活性。所以这个警告只是提醒你如果你想添加一个子模块，应该使用<code>git submodule add</code>命令，并且如果你想删除一个子模块，应该使用<code>git rm --cached</code>命令 。</p><ul><li><a href="https://www.jianshu.com/p/30d2ff4ebc6a">一种是删除本地新建module中的.git文件夹，这样git就不会把它当作一个独立的仓库了</a><a href="https://www.jianshu.com/p/30d2ff4ebc6a">2</a>。然后再重新执行add、commit和push命令。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面向服务的软件系统-期末复习笔记</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="分布式微服务"><a href="#分布式微服务" class="headerlink" title="分布式微服务"></a>分布式微服务</h1><h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221029105633076.png" alt="image-20221029105633076"></p><h2 id="log4j-properties"><a href="#log4j-properties" class="headerlink" title="log4j.properties"></a>log4j.properties</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">log4j.rootLogger</span>=debug, stdout, R<br><span class="hljs-comment">#log4j.rootLogger = [ level ] , appenderName, appenderName, …</span><br><span class="hljs-comment">#OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL</span><br><span class="hljs-comment">#Log4j有一个规则：只输出级别不低于设定级别的日志信息，假设Loggers级别设定为INFO，则INFO</span><br><span class="hljs-comment">#、WARN、ERROR和FATAL级别的日志信息都会输出，而级别比INFO低的DEBUG则不会输出。</span><br><br><span class="hljs-attr">log4j.appender.stdout</span>=org.apache.log4j.ConsoleAppender<br><span class="hljs-attr">log4j.appender.stdout.layout</span>=org.apache.log4j.PatternLayout<br><br><span class="hljs-comment"># Pattern to output the caller&#x27;s file name and line number.</span><br><span class="hljs-attr">log4j.appender.stdout.layout.ConversionPattern</span>=%<span class="hljs-number">5</span>p [%t] (%F:%L) - %m%n<br><br><span class="hljs-attr">log4j.appender.R</span>=org.apache.log4j.RollingFileAppender<br><span class="hljs-attr">log4j.appender.R.File</span>=example.log<br><br><span class="hljs-attr">log4j.appender.R.MaxFileSize</span>=<span class="hljs-number">100</span>KB<br><span class="hljs-comment"># Keep one backup file</span><br><span class="hljs-attr">log4j.appender.R.MaxBackupIndex</span>=<span class="hljs-number">5</span><br><br><span class="hljs-attr">log4j.appender.R.layout</span>=org.apache.log4j.PatternLayout<br><span class="hljs-attr">log4j.appender.R.layout.ConversionPattern</span>=%p %t %c - %m%n<br><br><span class="hljs-comment">#org.apache.log4j.ConsoleAppender（控制台），</span><br><span class="hljs-comment">#org.apache.log4j.FileAppender（文件），  </span><br><span class="hljs-comment">#org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</span><br><span class="hljs-comment">#org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），  </span><br><span class="hljs-comment">#org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</span><br></code></pre></td></tr></table></figure><h2 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/b92cafea69b1419bbf88dbe687b4deb2.png" class title="2.png"><p>SOA（全称：Service Oriented Architecture），中文意思为 “面向服务的架构”，你可以将它理解为一个架构模型或者一种设计方法，而并不是服务解决方案。</p><p>其中包含多个服务， 服务之间通过相互依赖或者通过通信机制，来完成相互通信的，最终提供一系列的功能。一个服务通常以独立的形式存在与操作系统进程中。各个服务之间通过网络调用 。</p><p>跟 SOA 相提并论的还有一个 ESB（企业服务总线），简单来说ESB就是一根管道，用来连接各个服务节点。为了集成不同系统，不同协议的服务，ESB 可以简单理解为：它做了消息的转化解释和路由工作，让不同的服务互联互通；</p><p>我们将各个应用之间彼此的通信全部去掉，在中间引入一个ESB企业总线，各个服务之间，只需要和ESB进行通信，这个时候，各个应用之间的交互就会变得更加的清晰，业务架构&#x2F;逻辑等，也会变得很清楚。</p><p>原本杂乱没有规划的系统，梳理成了一个有规划可治理的系统，在这个过程中，最大的变化，就是引入了ESB企业总线。</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/f94d72cc1b4e441fb57cff5d78625857.png" class title="3.png"><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>微服务架构其实和SOA架构类似，微服务是在SOA上做的升华。微服务架构重点强调的一个是”业务需要彻底的组件化和服务化”，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这样的小应用和其他各个应用之间，相互去协作通信，来完成一个交互和集成，这就是微服务架构。</p><p><strong>每个微服务有自己私有的数据库持久化业务数据。</strong></p><p>• <strong>每个微服务只能访问自己的数据库，而不能访问其它服</strong></p><p><strong>务的数据库。</strong></p><p>• <strong>数据的去中心化，进一步降低了微服务之间的耦合度，</strong></p><p><strong>不同服务可采用不同数据库技术（<strong><strong>SQL</strong></strong>、<strong><strong>NoSQL</strong></strong>等）。</strong></p><p><strong>在复杂的业务场景下，如果包含多个微服务，通常在客</strong></p><p><strong>户端或者中间层（网关）处理。</strong></p><p>微服务的特征<br>1.通过服务实现组件化<br>2.按业务能力来划分服务和开发团队<br>3.去中心化<br>4.基础设施自动化（devops、自动化部署）</p><h2 id="SOA-和微服务架构的差别"><a href="#SOA-和微服务架构的差别" class="headerlink" title="SOA 和微服务架构的差别"></a>SOA 和微服务架构的差别</h2><p>1.微服务去中心化，去掉ESB企业总线。微服务不再强调传统SOA架构里面比较重的ESB企业服务总线，同时SOA的思想进入到单个业务系统内部实现真正的组件化</p><p>2.Docker容器技术的出现，为微服务提供了更便利的条件，比如更小的部署单元，每个服务可以通过类似Node或者Spring Boot等技术跑在自己的进程中。</p><p>3.SOA注重的是系统集成方面，而微服务关注的是完全分离</p><h1 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h1><h2 id="SOAP规定了哪些（部分）"><a href="#SOAP规定了哪些（部分）" class="headerlink" title="SOAP规定了哪些（部分）"></a>SOAP规定了哪些（部分）</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218135845978.png" class title="image-20230218135845978"><h2 id="zookeeper的follower和Leader"><a href="#zookeeper的follower和Leader" class="headerlink" title="zookeeper的follower和Leader"></a>zookeeper的follower和Leader</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215143435218.png" class title="image-20230215143435218"><h2 id="ESB包括哪些服务"><a href="#ESB包括哪些服务" class="headerlink" title="ESB包括哪些服务"></a>ESB包括哪些服务</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215224853879.png" class title="image-20230215224853879"><h2 id="什么是ESB"><a href="#什么是ESB" class="headerlink" title="什么是ESB"></a>什么是ESB</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215230810134.png" class title="image-20230215230810134"><h2 id="SOA是一种具体的技术吗"><a href="#SOA是一种具体的技术吗" class="headerlink" title="SOA是一种具体的技术吗"></a>SOA是一种具体的技术吗<img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215230823919.png" class title="image-20230215230823919"></h2><h2 id="在SOA中为什么要用ESB，而不是点对点发消息"><a href="#在SOA中为什么要用ESB，而不是点对点发消息" class="headerlink" title="在SOA中为什么要用ESB，而不是点对点发消息"></a>在SOA中为什么要用ESB，而不是点对点发消息</h2><p>应用A发送消息给ESB，ESB再将消息转换给应用B，那么应用A直接通过SOAP协议发送给B，效率不是应该更高吗？而且如果这些IT系统都在一个网络中，提供的WebService都在统一命名空间下，就可以相互通信，为什么还要加上这一层？有两点需要考虑。第一点。点对点做服务的时候，通常需要考虑日志记录，服务访问安全、传输安全、数据安全、路由分发等一系列问题，而这些完全可以统一管理，统一验证，灵活配置，；如果应用A调用了应用B，在调用了应用C等具有逻辑流程的调用时，还可以在ESB上实现流程引擎；第二点，ESB是一个中间件平台，包含了消息中间件的全部功能，有异步消息处理机制，可以实现业务系统之间真正的松耦合的结构。</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="为什么ESB是SOA重要架构部分，而Dubbo却不使用ESB"><a href="#为什么ESB是SOA重要架构部分，而Dubbo却不使用ESB" class="headerlink" title="为什么ESB是SOA重要架构部分，而Dubbo却不使用ESB"></a>为什么ESB是SOA重要架构部分，而Dubbo却不使用ESB</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215231233261.png" class title="image-20230215231233261"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215231442676.png" class title="image-20230215231442676"><h2 id="负载均衡的意义"><a href="#负载均衡的意义" class="headerlink" title="负载均衡的意义"></a>负载均衡的意义</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215231652520.png" class title="image-20230215231652520"><h2 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218104603238.png" class title="image-20230218104603238"><h2 id="持续集成CI"><a href="#持续集成CI" class="headerlink" title="持续集成CI"></a>持续集成CI<img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215232516175.png" class title="image-20230215232516175"></h2><h2 id="CICD"><a href="#CICD" class="headerlink" title="CICD"></a>CICD<img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215232552469.png" class title="image-20230215232552469"></h2><h2 id="什么是CICD"><a href="#什么是CICD" class="headerlink" title="什么是CICD"></a>什么是CICD</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215232633514.png" class title="image-20230215232633514"><h2 id="幂等性，分布式服务系统中有哪些服务需要幂等性"><a href="#幂等性，分布式服务系统中有哪些服务需要幂等性" class="headerlink" title="幂等性，分布式服务系统中有哪些服务需要幂等性"></a>幂等性，分布式服务系统中有哪些服务需要幂等性</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215232856025.png" class title="image-20230215232856025"><h2 id="分布式服务系统中有哪些服务"><a href="#分布式服务系统中有哪些服务" class="headerlink" title="分布式服务系统中有哪些服务"></a>分布式服务系统中有哪些服务</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218140818842.png" class title="image-20230218140818842"><h2 id="CAP-1"><a href="#CAP-1" class="headerlink" title="CAP"></a>CAP</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215232940356.png" class title="image-20230215232940356"><h2 id="服务雪崩效应"><a href="#服务雪崩效应" class="headerlink" title="服务雪崩效应"></a>服务雪崩效应<img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215233517621.png" class title="image-20230215233517621"></h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215233550837.png" class title="image-20230215233550837"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215233654160.png" class title="image-20230215233654160"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218132230813.png" class title="image-20230218132230813"><h2 id="单体架构应用和微服务架构应用区别"><a href="#单体架构应用和微服务架构应用区别" class="headerlink" title="单体架构应用和微服务架构应用区别"></a>单体架构应用和微服务架构应用区别<img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215234141735.png" class title="image-20230215234141735"></h2><h2 id="单体架构到SOA到微服务"><a href="#单体架构到SOA到微服务" class="headerlink" title="单体架构到SOA到微服务"></a>单体架构到SOA到微服务</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215232421659.png" class title="image-20230215232421659"><h2 id="dependecies作用"><a href="#dependecies作用" class="headerlink" title="dependecies作用"></a>dependecies作用<img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216213917677.png" class title="image-20230216213917677"></h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216214110594.png" class title="image-20230216214110594"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216214124335.png" class title="image-20230216214124335"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216214231684.png" class title="image-20230216214231684"><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218114512116.png" class title="image-20230218114512116"><h2 id="消息代理架构"><a href="#消息代理架构" class="headerlink" title="消息代理架构"></a>消息代理架构</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216220959251.png" class title="image-20230216220959251"><h2 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216221354457.png" class title="image-20230216221354457"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216221412566.png" class title="image-20230216221412566"><h2 id="WSDL"><a href="#WSDL" class="headerlink" title="WSDL"></a>WSDL</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216221428225.png" class title="image-20230216221428225"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216221452712.png" class title="image-20230216221452712"><h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216222101456.png" class title="image-20230216222101456"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216222144591.png" class title="image-20230216222144591"><h2 id="DevOps理念"><a href="#DevOps理念" class="headerlink" title="DevOps理念"></a>DevOps理念</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216222725075.png" class title="image-20230216222725075"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216222839230.png" class title="image-20230216222839230"><h2 id="Docker会全面取代KVM吗"><a href="#Docker会全面取代KVM吗" class="headerlink" title="Docker会全面取代KVM吗"></a>Docker会全面取代KVM吗<img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215231027326.png" class title="image-20230215231027326"></h2><h2 id="docker调度工具"><a href="#docker调度工具" class="headerlink" title="docker调度工具"></a>docker调度工具</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230216221943667.png" class title="image-20230216221943667"><h2 id="docker的C-x2F-S"><a href="#docker的C-x2F-S" class="headerlink" title="docker的C&#x2F;S"></a>docker的C&#x2F;S</h2><p>docker本身其实是一个server的形式存在着的，叫做docker daemon，也叫做dockerd，那么怎么与这个server进行通信呢？当然想到要用一个client客户端，client客户端有很多种形式，比如我们经常在命令行敲的docker工具，它就是一个client，另外比如windows或mac系统装的桌面版docker，那也是客户端（这个也可以操控dockerd），总之有很多形式的客户端。所以docker工作本身是一个client&#x2F;server架构，客户端通过unix socket进程间通信的方式与服务端做信息交互（默认如果是与本地的dockerd交互的话是这么交互，如果是与远端的dockerd交互需要重新指定host及协议）</p><h2 id="docker容器和镜像区别"><a href="#docker容器和镜像区别" class="headerlink" title="docker容器和镜像区别"></a>docker容器和镜像区别</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218094156630.png" class title="image-20230218094156630"><h2 id="Springcloud的优点"><a href="#Springcloud的优点" class="headerlink" title="Springcloud的优点"></a>Springcloud的优点</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230217234709072.png" class title="image-20230217234709072"><h2 id="Jenkins优点"><a href="#Jenkins优点" class="headerlink" title="Jenkins优点"></a>Jenkins优点</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218103826787.png" class title="image-20230218103826787"><h2 id="docker的优点"><a href="#docker的优点" class="headerlink" title="docker的优点"></a>docker的优点</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218094234689.png" class title="image-20230218094234689"><h2 id="k8s的优点"><a href="#k8s的优点" class="headerlink" title="k8s的优点"></a>k8s的优点</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218094402432.png" class title="image-20230218094402432"><h2 id="SpringBoot优点"><a href="#SpringBoot优点" class="headerlink" title="SpringBoot优点"></a>SpringBoot优点<img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230215232256634.png" class title="image-20230215232256634"></h2><h2 id="应用部署方式演变"><a href="#应用部署方式演变" class="headerlink" title="应用部署方式演变"></a>应用部署方式演变</h2><p>在部署应用程序的方式上，主要经历了三个时代：</p><ul><li><p><strong>传统部署</strong>：互联网早期，会直接将应用程序部署在物理机上</p><blockquote><p>优点：简单，不需要其它技术的参与</p><p>缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响</p></blockquote></li><li><p><strong>虚拟化部署</strong>：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境</p><blockquote><p>优点：程序环境不会相互产生影响，提供了一定程度的安全性</p><p>缺点：增加了操作系统，浪费了部分资源</p></blockquote></li><li><p><strong>容器化部署</strong>：与虚拟化类似，但是共享了操作系统</p><blockquote><p>优点：</p><p>​    可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等</p><p>​    运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦</p><p>​    容器化的应用程序可以跨云服务商、跨Linux操作系统发行版进行部署</p></blockquote></li></ul><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20200505183738289.png" class title="image-20200505183738289"><p>容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：</p><ul><li>一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器</li><li>当并发访问量变大的时候，怎么样做到横向扩展容器数量</li></ul><p>这些容器管理的问题统称为<strong>容器编排</strong>问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：</p><ul><li><strong>Swarm</strong>：Docker自己的容器编排工具</li><li><strong>Mesos</strong>：Apache的一个资源统一管控的工具，需要和Marathon结合使用</li><li><strong>Kubernetes</strong>：Google开源的的容器编排工具</li></ul><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20200524150339551.png" alt="image-20200524150339551" style="border:1px solid;zoom:110%;"><h2 id="如何配置jenkins和k8s的集成"><a href="#如何配置jenkins和k8s的集成" class="headerlink" title="如何配置jenkins和k8s的集成"></a>如何配置jenkins和k8s的集成</h2><h2 id="-1"><a href="#-1" class="headerlink" title></a><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218095835686.png" class title="image-20230218095835686"></h2><h2 id="什么是瀑布模型"><a href="#什么是瀑布模型" class="headerlink" title="什么是瀑布模型"></a>什么是瀑布模型</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218100210599.png" class title="image-20230218100210599"><h2 id="什么是敏捷开发"><a href="#什么是敏捷开发" class="headerlink" title="什么是敏捷开发"></a>什么是敏捷开发</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218100339530.png" class title="image-20230218100339530"><h2 id="SOA架构中分库分表的原理和实践方法"><a href="#SOA架构中分库分表的原理和实践方法" class="headerlink" title="SOA架构中分库分表的原理和实践方法"></a>SOA架构中分库分表的原理和实践方法</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218103256766.png" class title="image-20230218103256766"><h2 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218103309644.png" class title="image-20230218103309644"><h2 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218103415951.png" class title="image-20230218103415951"><h2 id="以-rabbitMQ-为代表的现代消息中间件在微服务系统中主要解决了什么问题？"><a href="#以-rabbitMQ-为代表的现代消息中间件在微服务系统中主要解决了什么问题？" class="headerlink" title="以 rabbitMQ 为代表的现代消息中间件在微服务系统中主要解决了什么问题？"></a>以 rabbitMQ 为代表的现代消息中间件在微服务系统中主要解决了什么问题？</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218103617413.png" class title="image-20230218103617413"><h2 id="SLA的好处-可见资料"><a href="#SLA的好处-可见资料" class="headerlink" title="SLA的好处-可见资料"></a>SLA的好处-可见资料</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218130935223.png" class title="image-20230218130935223"><h2 id="传统服务的质量评价和软件服务的质量评价"><a href="#传统服务的质量评价和软件服务的质量评价" class="headerlink" title="传统服务的质量评价和软件服务的质量评价"></a>传统服务的质量评价和软件服务的质量评价</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218140357960.png" class title="image-20230218140357960"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218140239112.png" class title="image-20230218140239112"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218140618212.png" class title="image-20230218140618212"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218140623441.png" class title="image-20230218140623441"><p>分布式服务系统中有哪些服务，详细一点</p><h1 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h1><h2 id="基于服务的软件系统与你以往做过的软件有何区别？可以从软件结构、开发过程、调试方法等方面阐述。"><a href="#基于服务的软件系统与你以往做过的软件有何区别？可以从软件结构、开发过程、调试方法等方面阐述。" class="headerlink" title="基于服务的软件系统与你以往做过的软件有何区别？可以从软件结构、开发过程、调试方法等方面阐述。"></a>基于服务的软件系统与你以往做过的软件有何区别？可以从软件结构、开发过程、调试方法等方面阐述。</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218100620807.png" class title="image-20230218100620807"><h2 id="1、-Dubbo框架与Zookeeper框架之间的关系是什么？如何将Zookeeper框架与Dubbo框架进行集成？"><a href="#1、-Dubbo框架与Zookeeper框架之间的关系是什么？如何将Zookeeper框架与Dubbo框架进行集成？" class="headerlink" title="1、 Dubbo框架与Zookeeper框架之间的关系是什么？如何将Zookeeper框架与Dubbo框架进行集成？"></a>1、 Dubbo框架与Zookeeper框架之间的关系是什么？如何将Zookeeper框架与Dubbo框架进行集成？</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218100725938.png" class title="image-20230218100725938"><h2 id="1、-Dubbo框架中的Dubbo-master的作用是什么？"><a href="#1、-Dubbo框架中的Dubbo-master的作用是什么？" class="headerlink" title="1、 Dubbo框架中的Dubbo-master的作用是什么？"></a>1、 Dubbo框架中的Dubbo-master的作用是什么？</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218101240421.png" class title="image-20230218101240421"><h2 id="1、-Dubbo框架下Service-Provider发布服务的过程，及过程中的关键点。"><a href="#1、-Dubbo框架下Service-Provider发布服务的过程，及过程中的关键点。" class="headerlink" title="1、 Dubbo框架下Service Provider发布服务的过程，及过程中的关键点。"></a>1、 Dubbo框架下Service Provider发布服务的过程，及过程中的关键点。</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218101347388.png" class title="image-20230218101347388"><h2 id="1、-Dubbo框架下Service-Consumer消费服务的过程，及过程中的关键点。"><a href="#1、-Dubbo框架下Service-Consumer消费服务的过程，及过程中的关键点。" class="headerlink" title="1、 Dubbo框架下Service Consumer消费服务的过程，及过程中的关键点。"></a>1、 Dubbo框架下Service Consumer消费服务的过程，及过程中的关键点。</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218101454061.png" class title="image-20230218101454061"><h2 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h2><h2 id="1、-容器虚拟化和传统虚拟化的区别是什么？"><a href="#1、-容器虚拟化和传统虚拟化的区别是什么？" class="headerlink" title="1、 容器虚拟化和传统虚拟化的区别是什么？"></a>1、 容器虚拟化和传统虚拟化的区别是什么？</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218101850785.png" class title="image-20230218101850785"><h2 id="如何实现k8s自动部署"><a href="#如何实现k8s自动部署" class="headerlink" title="如何实现k8s自动部署"></a>如何实现k8s自动部署</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218095625712.png" class title="image-20230218095625712"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218095647111.png" class title="image-20230218095647111"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218095808936.png" class title="image-20230218095808936"><h2 id="1、-Kubernetes有哪些核心组件，其功能是什么？"><a href="#1、-Kubernetes有哪些核心组件，其功能是什么？" class="headerlink" title="1、 Kubernetes有哪些核心组件，其功能是什么？"></a>1、 Kubernetes有哪些核心组件，其功能是什么？</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218102001596.png" class title="image-20230218102001596"><h2 id="实验4"><a href="#实验4" class="headerlink" title="实验4"></a>实验4</h2><h2 id="1、-如果你要从头开发一个基于微服务架构的项目，项目中的服务最终要部署在k8s管理的镜像环境中，你认为应如何创建项目？与手动部署实验过程相比，哪些改进可以让开发更加合理高效？"><a href="#1、-如果你要从头开发一个基于微服务架构的项目，项目中的服务最终要部署在k8s管理的镜像环境中，你认为应如何创建项目？与手动部署实验过程相比，哪些改进可以让开发更加合理高效？" class="headerlink" title="1、 如果你要从头开发一个基于微服务架构的项目，项目中的服务最终要部署在k8s管理的镜像环境中，你认为应如何创建项目？与手动部署实验过程相比，哪些改进可以让开发更加合理高效？"></a>1、 如果你要从头开发一个基于微服务架构的项目，项目中的服务最终要部署在k8s管理的镜像环境中，你认为应如何创建项目？与手动部署实验过程相比，哪些改进可以让开发更加合理高效？</h2><h2 id="-2"><a href="#-2" class="headerlink" title></a><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218102531002.png" class title="image-20230218102531002"></h2><h2 id="1、-如何将k8s中多个provider服务实例的负载均衡策略改为轮询调用？即在多次反复调用时轮流调用各个服务实例。"><a href="#1、-如何将k8s中多个provider服务实例的负载均衡策略改为轮询调用？即在多次反复调用时轮流调用各个服务实例。" class="headerlink" title="1、 如何将k8s中多个provider服务实例的负载均衡策略改为轮询调用？即在多次反复调用时轮流调用各个服务实例。"></a>1、 如何将k8s中多个provider服务实例的负载均衡策略改为轮询调用？即在多次反复调用时轮流调用各个服务实例。</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/image-20230218102750666.png" class title="image-20230218102750666">]]></content>
    
    
    <categories>
      
      <category>面向服务的软件系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面向服务的软件系统-大作业分享</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="面向服务大作业分享"><a href="#面向服务大作业分享" class="headerlink" title="面向服务大作业分享"></a>面向服务大作业分享</h1><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114205121053.png" class title="image-20221114205121053"><p>管理员端：前后端资源合并设计</p><p>客户手机端：前后端分离设计</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114165458696.png" class title="image-20221114165458696"><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="1-mysql"><a href="#1-mysql" class="headerlink" title="1.mysql"></a>1.mysql</h4><p>目前设计了三条表</p><p>brand品牌</p><p>employee管理员工</p><p>good商品</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114203716493.png" class title="image-20221114203716493"><h3 id="tips1"><a href="#tips1" class="headerlink" title="tips1:"></a>tips1:</h3><p>如果小组内都想同时开发共用同一个数据库，可以利用云服务器docker部署一个mysql，然后使用这个云服务器上的mysql</p><h3 id="tips2："><a href="#tips2：" class="headerlink" title="tips2："></a>tips2：</h3><p>想要实现数据库里面商品携带商品图片</p><p>可以将商品图片转化为url链接存入</p><p>然后mysql类型定义为varchar并且长度为2083</p><h3 id="tips3唯一索引："><a href="#tips3唯一索引：" class="headerlink" title="tips3唯一索引："></a>tips3唯一索引：</h3><p>想要解决good的名称唯一可以直接利用mysql的唯一索引</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114165218161.png" class title="image-20221114165218161"><p>这样就限制了存入数据库的name是唯一的</p><h2 id="前后端代码：管理员模块"><a href="#前后端代码：管理员模块" class="headerlink" title="前后端代码：管理员模块"></a>前后端代码：管理员模块</h2><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>1.采用常见的entity，mapper，service，controller层关系分类设计</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114204231439.png" class title="image-20221114204231439"><h3 id="2-登录功能"><a href="#2-登录功能" class="headerlink" title="2.登录功能"></a>2.登录功能</h3><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114205236817.png" class title="image-20221114205236817"><h3 id="3-管理界面"><a href="#3-管理界面" class="headerlink" title="3.管理界面"></a>3.管理界面</h3><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114205307391.png" class title="image-20221114205307391"><h3 id="4-添加员工，商品，品牌"><a href="#4-添加员工，商品，品牌" class="headerlink" title="4.添加员工，商品，品牌"></a>4.添加员工，商品，品牌</h3><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114205407434.png" class title="image-20221114205407434"><h2 id="前后端代码：客户手机端模块"><a href="#前后端代码：客户手机端模块" class="headerlink" title="前后端代码：客户手机端模块"></a>前后端代码：客户手机端模块</h2><h3 id="介绍：采用的是单页面vue3设计"><a href="#介绍：采用的是单页面vue3设计" class="headerlink" title="介绍：采用的是单页面vue3设计"></a>介绍：采用的是单页面vue3设计</h3><p>这里实现前后分离，基本利用vue实现逻辑</p><p>整体思路是通过mail_good暴露出来的接口获取到商品数据</p><p>然后根据获取到的数据进行页面展示</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114165000162.png" class title="image-20221114165000162"><h2 id="运维打包放入docker部署k8s模块"><a href="#运维打包放入docker部署k8s模块" class="headerlink" title="运维打包放入docker部署k8s模块"></a>运维打包放入docker部署k8s模块</h2><p>docker在虚拟机192.168.217.128配置好了</p><p>同时在本机windows也配置了docker</p><p>利用idea集成docker来打包</p><p>alt+8快捷键打开docker</p><p>docker build -t 944613709&#x2F;mail-employee:3.0 .<br>docker build -t 944613709&#x2F;mail-brand:3.0 .</p><p>docker build -t 944613709&#x2F;mail-good:3.0 .</p><p>docker build -t 944613709&#x2F;gateway:3.0 .</p><p>docker push 944613709&#x2F;mail-employee:3.0<br>docker push 944613709&#x2F;mail-brand:3.0<br>docker push 944613709&#x2F;mail-good:3.0</p><p>docker push 944613709&#x2F;gateway:3.0</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114201103721.png" class title="image-20221114201103721"><h2 id="sentinel"><a href="#sentinel" class="headerlink" title="sentinel"></a>sentinel</h2><p>在云服务器要打开对应的防火墙端口</p><p>不然访问不到</p><h2 id="后端跨域问题"><a href="#后端跨域问题" class="headerlink" title="后端跨域问题"></a>后端跨域问题</h2><p>后端跨域由springcloud组件解决了</p><p>SpringCloudApiGateway之支持Cors跨域请求</p><p> 配置代理可解决使用Axios不能直接进行跨域的问题。</p><h2 id="手机端购物车"><a href="#手机端购物车" class="headerlink" title="手机端购物车"></a>手机端购物车</h2><p>后端在给定一个接口</p><p>localhost:8082&#x2F;good&#x2F;list</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114115855526.png" class title="image-20221114115855526"><h2 id="k8s使用kubesphere"><a href="#k8s使用kubesphere" class="headerlink" title="k8s使用kubesphere"></a>k8s使用kubesphere</h2><p>1.直接利用kubesphere进行k8s部署以及管理，这里图形化操作做得比原生的操作界面好</p><p>2,在模拟了实际公司开发中，模拟本程序是有wuhan企业空间</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221114112448806.png" class title="image-20221114112448806"><p>3.在wuhan企业空间就有本次项目</p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="遇上的问题1：阿里云经常重启之后失效"><a href="#遇上的问题1：阿里云经常重启之后失效" class="headerlink" title="遇上的问题1：阿里云经常重启之后失效"></a>遇上的问题1：阿里云经常重启之后失效</h3><p>发现阿里云重启需要十多分钟</p><h3 id="Q2：kubesphere经常忘记密码"><a href="#Q2：kubesphere经常忘记密码" class="headerlink" title="Q2：kubesphere经常忘记密码"></a>Q2：kubesphere经常忘记密码</h3><p>直接用命令改密码</p><p>kubectl patch users admin -p ‘{“spec”:{“password”:”123456”}}’ –type&#x3D;’merge’ &amp;&amp; kubectl annotate users admin iam.kubesphere.io&#x2F;password-encrypted-</p><h3 id="Q3：前端的手机端跨域问题"><a href="#Q3：前端的手机端跨域问题" class="headerlink" title="Q3：前端的手机端跨域问题"></a>Q3：前端的手机端跨域问题</h3><p>由于手机端是localhost3000</p><p>所以访问localhost8082时候有cors警告跨域问题</p><p>使用前端axios代理服务器解决跨域问题失败</p><p>前端要访问localhost10010通过网关解决跨域问题</p><h3 id="通过后端springcloud-nacos解决了前端跨域问题"><a href="#通过后端springcloud-nacos解决了前端跨域问题" class="headerlink" title="通过后端springcloud nacos解决了前端跨域问题"></a>通过后端springcloud nacos解决了前端跨域问题</h3><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221115141551454.png" class title="image-20221115141551454"><p>A在dev时候利用apifox暂时跳过</p><p>Q4：怎么在goods存入对应图片</p><p>数据库插入img网址</p><p>mysql的img应该设置类型varchar,长度设置为2083</p><p>否则会发生过长警告</p><p>Q4：虚拟机ifconfig没有出来ip地址</p><p>nat切换桥联再切换回nat</p><h2 id="gateway网关的使用"><a href="#gateway网关的使用" class="headerlink" title="gateway网关的使用"></a>gateway网关的使用</h2><p><a href="http://localhost:10010/backend/index.html">http://localhost:10010/backend/index.html</a></p><p>改为访问这个网站</p><h3 id="localhost和127-0-0-1虽然都指向本机，但也属于跨域"><a href="#localhost和127-0-0-1虽然都指向本机，但也属于跨域" class="headerlink" title="localhost和127.0.0.1虽然都指向本机，但也属于跨域"></a><strong>localhost和127.0.0.1虽然都指向本机，但也属于跨域</strong></h3><h2 id="图片的存放"><a href="#图片的存放" class="headerlink" title="图片的存放"></a>图片的存放</h2><p>存放在resource通过浏览器可以直接访问到</p><p>resourece&#x2F;images&#x2F;goods</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="短信登录服务"><a href="#短信登录服务" class="headerlink" title="短信登录服务"></a>短信登录服务</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221117194924621.png" class title="image-20221117194924621"><p>直接用aliyun给出的api</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221117195421941.png" class title="image-20221117195421941"><h2 id="vue可视化推荐"><a href="#vue可视化推荐" class="headerlink" title="vue可视化推荐"></a>vue可视化推荐</h2><p><a href="https://vform666.com/vform3.html?from=element_plus">https://vform666.com/vform3.html?from=element_plus</a></p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221203214551261.png" class title="image-20221203214551261"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221203215211736.png" class title="image-20221203215211736"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221204140853062.png" class title="image-20221204140853062"><p>合适的vant组件，已经给定了type&#x3D;tel自动检验是否为手机号</p><h2 id="vue动态引入依赖"><a href="#vue动态引入依赖" class="headerlink" title="vue动态引入依赖"></a>vue动态引入依赖</h2><p><a href="https://element-plus.gitee.io/zh-CN/guide/quickstart.html#%E6%8C%89%E9%9C%80%E5%AF%BC%E5%85%A5">https://element-plus.gitee.io/zh-CN/guide/quickstart.html#按需导入</a></p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221203214357539.png" class title="image-20221203214357539"><p>自动引入vant和element plus依赖</p><p>非常好用</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221203214900976.png" class title="image-20221203214900976"><h2 id="小心bug"><a href="#小心bug" class="headerlink" title="小心bug"></a>小心bug</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221204142025199.png" class title="image-20221204142025199"><h2 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h2><h3 id="watch实现步骤美化"><a href="#watch实现步骤美化" class="headerlink" title="watch实现步骤美化"></a>watch实现步骤美化</h3><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221204145825346.png" class title="image-20221204145825346"><h2 id="k8s安装jenkins"><a href="#k8s安装jenkins" class="headerlink" title="k8s安装jenkins"></a>k8s安装jenkins</h2><p>1.在csdn找非官方教程吃了很多亏</p><p>2.我最后在官网教程一下子就搞好了yyds</p><p><a href="https://www.jenkins.io/doc/book/installing/kubernetes/">https://www.jenkins.io/doc/book/installing/kubernetes/</a></p><h1 id="后端接口导出至postman"><a href="#后端接口导出至postman" class="headerlink" title="后端接口导出至postman"></a>后端接口导出至postman</h1><p>直接利用easyAPi</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221208154220470.png" class title="image-20221208154220470"><h1 id="部署对接出现问题"><a href="#部署对接出现问题" class="headerlink" title="部署对接出现问题"></a>部署对接出现问题</h1><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221208160622644.png" class title="image-20221208160622644"><h1 id="管理端前端跨域问题，其实没解决"><a href="#管理端前端跨域问题，其实没解决" class="headerlink" title="管理端前端跨域问题，其实没解决"></a>管理端前端跨域问题，其实没解决</h1><p>当时我用了临时解决措施：</p><p>就是前端没有跨域，借助了同一个端口的后端接口，后端接口再去调用feign来跨过端口调用真正的后端访存数据库接口</p><h1 id="安装nacos"><a href="#安装nacos" class="headerlink" title="安装nacos"></a>安装nacos</h1><p>因为安装nacos比较麻烦还需要依赖mysql数据库</p><p>官网失败</p><p>kubesphere失败</p><p>最后用的helm安装一键完成</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221213115002337.png" class title="image-20221213115002337"><h1 id="loginMessage模块不需要连接数据库，但是springboot的druid依赖默认要求连接数据库"><a href="#loginMessage模块不需要连接数据库，但是springboot的druid依赖默认要求连接数据库" class="headerlink" title="loginMessage模块不需要连接数据库，但是springboot的druid依赖默认要求连接数据库"></a>loginMessage模块不需要连接数据库，但是springboot的druid依赖默认要求连接数据库</h1><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221213115448241.png" class title="image-20221213115448241"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221213115858272.png" class title="image-20221213115858272"><p>由于Springboot我加了druid依赖</p><p>最后选择加入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@SpringBootApplication(<span class="hljs-params">exclude = &#123;</span></span><br><span class="hljs-params"><span class="hljs-meta">        DataSourceAutoConfiguration.<span class="hljs-keyword">class</span>,</span></span><br><span class="hljs-params"><span class="hljs-meta">        DataSourceTransactionManagerAutoConfiguration.<span class="hljs-keyword">class</span>,</span></span><br><span class="hljs-params"><span class="hljs-meta">        DruidDataSourceAutoConfigure.<span class="hljs-keyword">class</span> ,</span></span><br><span class="hljs-params"><span class="hljs-meta">        HibernateJpaAutoConfiguration.<span class="hljs-keyword">class</span>&#125;</span>)</span><br></code></pre></td></tr></table></figure><h1 id="新增手机客户端后，前端设计要求数据库中的表额外多出good-count-goods-state，且要求某些数据的类型作出调整"><a href="#新增手机客户端后，前端设计要求数据库中的表额外多出good-count-goods-state，且要求某些数据的类型作出调整" class="headerlink" title="新增手机客户端后，前端设计要求数据库中的表额外多出good_count,goods_state，且要求某些数据的类型作出调整"></a>新增手机客户端后，前端设计要求数据库中的表额外多出good_count,goods_state，且要求某些数据的类型作出调整</h1><p>因为当时已经完成了管理员端的前后端部分，最后认定不应该再去调整数据库，否则前面的也都得改动</p><p>于是只在手机客户端中根据传入的数据，自行作出调整，（新增数据属性，修改数据类型）</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221214102953933.png" class title="image-20221214102953933"><h1 id="由于axios的异步调用，created和mounted无法使用async"><a href="#由于axios的异步调用，created和mounted无法使用async" class="headerlink" title="由于axios的异步调用，created和mounted无法使用async"></a>由于axios的异步调用，created和mounted无法使用async</h1><p>于是采用了换函数执行位置</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%88%86%E4%BA%AB/image-20221214110755760.png" class title="image-20221214110755760"><h1 id="服务器内存问题，导致服务器爆炸"><a href="#服务器内存问题，导致服务器爆炸" class="headerlink" title="服务器内存问题，导致服务器爆炸"></a>服务器内存问题，导致服务器爆炸</h1><p>在同时部署了多个pods之后，内存又不够了，导致我服务器已经卡死，ssh命令都特别慢</p>]]></content>
    
    
    <categories>
      
      <category>面向服务的软件系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面向服务的软件系统-大作业展示</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="面向服务大作业展示"><a href="#面向服务大作业展示" class="headerlink" title="面向服务大作业展示"></a>面向服务大作业展示</h1><p><a href="http://localhost:10010/backend/index.html">http://localhost:10010/backend/index.html</a></p><p>访问路径</p><p>理论上</p><p>http:&#x2F;&#x2F;公网ip:32210&#x2F;backend&#x2F;index.html就可以访问</p><h2 id="同时多ip部署大作业项目"><a href="#同时多ip部署大作业项目" class="headerlink" title="同时多ip部署大作业项目"></a>同时多ip部署大作业项目</h2><p>发现数据库调用很慢（只使用了一个mysql）</p><p>成功连接sentinel</p><p><a href="http://47.92.244.182:31581/#/dashboard/metric/mailemployee">http://47.92.244.182:31581/#/dashboard/metric/mailemployee</a></p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214193300402.png" class title="image-20221214193300402"><p>基于gateway与nacos集合，在目前项目中暂时不需要sentinel专门去限流</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214193814894.png" class title="image-20221214193814894"><p><a href="http://47.92.244.182:30503/nacos/#/serviceManagement?dataId=&group=&appName=&namespace=">http://47.92.244.182:30503/nacos/#/serviceManagement?dataId=&amp;group=&amp;appName=&amp;namespace=</a></p><p>成功连接nacos</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221213120043836.png" alt="image-20221213120043836"></p><p>成功放入docker运行并无问题</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214150728690.png" class title="image-20221214150728690"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214154017141.png" class title="image-20221214154017141"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214144959425.png" class title="image-20221214144959425"><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214111013757.png" class title="image-20221214111013757"><p>12.14修正了原先管理端后端处理前端跨域问题的过时方法</p><p>后端Feign处理前端跨域方法改为后端网关处理</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214145849488.png" class title="image-20221214145849488"><p>残余的可以删掉，但是保留下来是为了保留Feign接口，方便以后要用时候再次利用这些Feign接口</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214150130346.png" class title="image-20221214150130346"><p>12.14准备采用nginx部署</p><p>原始80端口冲突所以一直显示不出来！！！</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214201550762.png" class title="image-20221214201550762"><h1 id="在新的k8s利用jenkins部署好之后，需要添加gateway白名单"><a href="#在新的k8s利用jenkins部署好之后，需要添加gateway白名单" class="headerlink" title="在新的k8s利用jenkins部署好之后，需要添加gateway白名单"></a>在新的k8s利用jenkins部署好之后，需要添加gateway白名单</h1><p>在这里需要nginx的公网请求ip和端口</p><p>12.14代办</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%A4%A7%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA/image-20221214205204586.png" class title="image-20221214205204586"><h1 id="互相合作很不错，自己部署一晚上nginx没有成功，交给苏泽楷一下子就成了"><a href="#互相合作很不错，自己部署一晚上nginx没有成功，交给苏泽楷一下子就成了" class="headerlink" title="互相合作很不错，自己部署一晚上nginx没有成功，交给苏泽楷一下子就成了"></a>互相合作很不错，自己部署一晚上nginx没有成功，交给苏泽楷一下子就成了</h1><h1 id="gateway的跨域允许"><a href="#gateway的跨域允许" class="headerlink" title="gateway的跨域允许"></a>gateway的跨域允许</h1><p>就算是本机ip是120.</p><p>categories: 面向服务的软件系统</p>]]></content>
    
    
    <categories>
      
      <category>面向服务的软件系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《面向服务的软件系统》实验三：微服务与容器技术</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%AE%9E%E9%AA%8C%E4%B8%89-120L021011%E7%9F%B3%E5%8D%93%E5%87%A1/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%AE%9E%E9%AA%8C%E4%B8%89-120L021011%E7%9F%B3%E5%8D%93%E5%87%A1/</url>
    
    <content type="html"><![CDATA[<p>《面向服务的软件系统》实验报告</p><p>——实验三：微服务与容器技术</p><p>姓名： 石卓凡 学号： 120L021011</p><p>目录</p><p><a href="#%E5%AE%B9%E5%99%A8%E8%99%9A%E6%8B%9F%E5%8C%96%E5%92%8C%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">1、 容器虚拟化和传统虚拟化的区别是什么？ 2</a></p><p><a href="#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D">概念介绍 2</a></p><p><a href="#%E5%8C%BA%E5%88%AB">区别： 3</a></p><p><a href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-kubernetes-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2">2、 如何实现 Kubernetes 自动化部署？ 5</a></p><p><a href="#%E9%80%9A%E8%BF%87devops%E5%AE%9E%E7%8E%B0k8s%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2">1. 通过devops实现k8s自动部署 5</a></p><p><a href="#%E9%80%9A%E8%BF%87jenkins%E5%AE%9E%E7%8E%B0%E5%AF%B9k8s%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2">2. 通过Jenkins实现对k8s的自动化构建和自动化部署 6</a></p><p><a href="#%E6%9C%AC%E6%AC%A1%E5%AE%9E%E9%AA%8C%E9%80%9A%E8%BF%87%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0k8s%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8">3. 本次实验通过传统方式实现k8s自动部署应用 7</a></p><p><a href="#kubernetes%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E5%85%B6%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88">3、 Kubernetes有哪些核心组件，其功能是什么？ 12</a></p><p><a href="#%E5%AE%98%E6%96%B9%E5%AE%9A%E4%B9%89%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6">（一） 官方定义的核心组件： 12</a></p><p><a href="#%E4%B8%AA%E4%BA%BA%E8%AE%A4%E4%B8%BA%E5%9C%A8%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E6%8E%A5%E8%A7%A6%E5%88%B0%E7%9A%84%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6">（二） 个人认为在使用中的接触到的关键组件： 14</a></p><p><a href="#kubernetes%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">4、 Kubernetes搭建过程中遇到的问题，与解决办法。 18</a></p><h1 id="容器虚拟化和传统虚拟化的区别是什么？"><a href="#容器虚拟化和传统虚拟化的区别是什么？" class="headerlink" title="容器虚拟化和传统虚拟化的区别是什么？"></a>容器虚拟化和传统虚拟化的区别是什么？</h1><p>图1.传统虚拟化和容器虚拟化</p><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p>容器虚拟化和传统虚拟化同属于虚拟化技术</p><p><strong>传统虚拟化</strong>：</p><p>虚拟出多个操作系统共同使用硬件资源即虚拟机，虚拟机需要安装操作系统才能执行应用程序，需要Hypevisor和Guest OS</p><p>简单说来就是通过在住操作系统上安装虚拟机管理系统（比如VMware）然后创建虚拟机，虚拟各种硬件，在虚拟机安装从操作系统，在从操作系统中安装部署应用</p><p><strong>容器虚拟化</strong>：</p><p>一般通过docker实现，在单个操作系统上虚拟出多个资源组共同使用硬件资源，透过共享Host OS的作法，取代一个一个Guest OS的功用。</p><p>简单来说，通过docker容器，通过将应用程序及其所需要的依赖，函数库，环境配置打包成为一个镜像，然后形成进程作为容器。也就是软件运行所需要的所有的资源打包放到一个隔离的容器，不需要捆绑一个操作系统</p><h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><table><thead><tr><th><strong>特性</strong></th><th><strong>Docker</strong></th><th><strong>虚拟机</strong></th></tr></thead><tbody><tr><td><strong>性能</strong></td><td>接近原生</td><td>性能较差</td></tr><tr><td><strong>硬盘占用</strong></td><td>一般为MB，占用体积小</td><td>一般为GB，占用体积大</td></tr><tr><td><strong>启动</strong></td><td>秒级，启动快</td><td>分钟级，启动慢</td></tr><tr><td><strong>操作系统覆盖</strong></td><td>仅是内核支持的os</td><td>支持linux，window，mac等</td></tr><tr><td><strong>技术成熟度</strong></td><td>更加成熟，技术更新，更受欢迎</td><td>较落后</td></tr><tr><td><strong>方案</strong></td><td>容器内没有自己的内核且也没有进行硬件虚拟，容器内的应用进程直接运行于宿主的内核</td><td>虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程</td></tr><tr><td><strong>资源利用率</strong></td><td>Docker 对系统资源的利用率很高，一台主机上可以同  时运行数千个 Docker 容器。 容器除了运行其中的应用外，基本不消耗额外的系统资  源，使得应用的性能很高，同时系统的开销尽量小</td><td>虚拟机对于系统资源的利用率较低，一台主机同时打开多台虚拟机所需要的要求远远大于docker的需求</td></tr><tr><td><strong>管理难度</strong></td><td>管理简单，使用 Docker，只需要小小的修改，就可以替代以往大  量的更新工作</td><td>管理复杂，需要进入虚拟机去操作</td></tr><tr><td><strong>资源隔离</strong></td><td>能力较差，Docker是利用cgroup实现资源限制的，只能限制资源消耗的最大值，而不能隔绝其他程序占用自己的资源</td><td>资源隔离能力较强，因为不同虚拟机直接拥有不同硬件</td></tr><tr><td><strong>安全性</strong></td><td>Docker目前并不能分辨具体执行指令的用 户，只要一个用户拥有执行Docker的权限，那么他就可以对Docker的容器进行所有操作，不管该容器是否是由 该用户创建，存在一定的安全风险。</td><td>安全性相对于docker较强，需要提供虚拟机用户密码验证</td></tr></tbody></table><p><strong>区别总结：</strong></p><p>Docker是一个系统进程，虚拟机是在操作系统中的操作系统。</p><p>简单来说运行一个程序需要环境，而传统虚拟化技术是通过虚拟出一整个操作系统来提供所需要的环境，而容器虚拟化技术是通过docker的镜像中来包含所需要的特定依赖，函数库，环境配置资源。</p><p>Docker体积小，启动速度快，性能好。虚拟机体积大，启动速度慢，性能一般</p><h1 id="如何实现-Kubernetes-自动化部署？"><a href="#如何实现-Kubernetes-自动化部署？" class="headerlink" title="如何实现 Kubernetes 自动化部署？"></a>如何实现 Kubernetes 自动化部署？</h1><p>图2.1.1自动化部署概念图</p><h2 id="通过devops实现k8s自动部署"><a href="#通过devops实现k8s自动部署" class="headerlink" title="通过devops实现k8s自动部署"></a>通过devops实现k8s自动部署</h2><p>自动化部署指的是，通过自动化工具将应用介质部署到指定环境中去。 自动化部署只是持续交付和持续部署流程中的一个功能单元</p><p>DevOps 自动化，运用技术，在减少人工辅助的情况下执行各项任务，以此来简化运维与开发团队之间的反馈循环工作，从而将迭代更新更快地部署到生产应用中。因此经常使用devops来实现k8s的自动部署</p><p><strong>通过Devops实现自动部署k8s的过程：</strong></p><ol><li>创建容器镜像仓库</li><li>在DevOps创建流水线</li><li>创建容器</li><li>自动化升级</li></ol><h2 id="通过Jenkins实现对k8s的自动化构建和自动化部署"><a href="#通过Jenkins实现对k8s的自动化构建和自动化部署" class="headerlink" title="通过Jenkins实现对k8s的自动化构建和自动化部署"></a>通过Jenkins实现对k8s的自动化构建和自动化部署</h2><p>图2.1.2利用jenkins自动化部署概念图</p><p><strong>一般过程</strong></p><ol><li>提交项目代码并打上git tag，上传代码及tag至gitlab或者github</li><li>Github或者gitlab通过webhook自动触发jenkins执行任务</li><li>jenkins获取代码，执行代码编译、构建docker镜像、上传docker镜像至harbor镜像仓库、执行kubectl命令部署至k8s。</li></ol><p><strong>具体过程</strong></p><ol><li><a href="https://devopstack.cn/devops/1476.html#2_jenkins"><strong>部署jenkins</strong></a></li><li><a href="https://devopstack.cn/devops/1476.html#21">环境准备</a></li><li><a href="https://devopstack.cn/devops/1476.html#22_jenkins">部署jenkins</a></li><li><a href="https://devopstack.cn/devops/1476.html#221_jenkins_Pod">部署有状态的jenkins Pod</a></li><li><a href="https://devopstack.cn/devops/1476.html#222_jenkins_ingress">创建jenkins ingress</a></li><li><a href="https://devopstack.cn/devops/1476.html#223_jenkins">jenkins认证授权</a></li><li><a href="https://devopstack.cn/devops/1476.html#23jenkins">配置jenkins</a></li><li><a href="https://devopstack.cn/devops/1476.html#24_JenkinsK8S">Jenkins在K8S中动态创建代理</a></li><li><a href="https://devopstack.cn/devops/1476.html#25_Jenkins_Slave">构建Jenkins Slave镜像</a></li><li><a href="https://devopstack.cn/devops/1476.html#251_Dockerfile">Dockerfile配置文件</a></li><li><a href="https://devopstack.cn/devops/1476.html#252_jenkins-slave">jenkins-slave启动脚步</a></li><li><a href="https://devopstack.cn/devops/1476.html#253_mavensettingsxml">maven源配置文件settings.xml</a></li><li><a href="https://devopstack.cn/devops/1476.html#254">构建镜像, 并推送至私有镜像仓库</a><ol><li><a href="https://devopstack.cn/devops/1476.html#3_pipeline"><strong>pipeline的使用</strong></a></li></ol></li><li><a href="https://devopstack.cn/devops/1476.html#31_Jenkins_Pipeline">Jenkins Pipeline构建流水线发布</a></li><li><a href="https://devopstack.cn/devops/1476.html#32_git">生成git流水线语法</a></li><li><a href="https://devopstack.cn/devops/1476.html#33_pipeline">pipeline语法</a><ol><li><a href="https://devopstack.cn/devops/1476.html#4_jenkinsk8s"><strong>通过jenkins部署代码到k8s</strong></a></li></ol></li><li><a href="https://devopstack.cn/devops/1476.html#41_PipelineCI">编写Pipeline脚本完成CI阶段</a></li><li><a href="https://devopstack.cn/devops/1476.html#411_pipeline">创建pipeline流水线中各个凭证</a></li><li><a href="https://devopstack.cn/devops/1476.html#412_parameters">parameters参数化生成</a></li><li><a href="https://devopstack.cn/devops/1476.html#413_pipeline">拉取代码片段pipeline生成</a></li><li><a href="https://devopstack.cn/devops/1476.html#414_jenkins_pipeineCI">完整的基于jenkins pipeine脚本CI阶段构建</a></li><li><a href="https://devopstack.cn/devops/1476.html#42_PipelineCD">编写Pipeline脚本完成CD阶段</a></li><li><a href="https://devopstack.cn/devops/1476.html#421_pipeline">持续部署pipeline片段生成</a></li><li><a href="https://devopstack.cn/devops/1476.html#422_pipeline">持续部署pipeline代码</a></li><li><a href="https://devopstack.cn/devops/1476.html#423_cd">构建完成cd阶段</a></li><li><a href="https://devopstack.cn/devops/1476.html#424_pipeline">添加回滚操作pipeline</a></li><li><a href="https://devopstack.cn/devops/1476.html#43_pipeline">添加构建状态告警pipeline</a></li></ol><h2 id="本次实验通过传统方式实现k8s自动部署应用"><a href="#本次实验通过传统方式实现k8s自动部署应用" class="headerlink" title="本次实验通过传统方式实现k8s自动部署应用"></a>本次实验通过传统方式实现k8s自动部署应用</h2><p>以本实验过程来举例说明一般部署过程</p><ol><li><strong>编写程序代码</strong></li></ol><p>本实验中是编写server.js</p><p>而一般可以通过对springboot模块进行maven的package获取target文件对其进行打包</p><p>比如通过对大作业springcloud的某个微服务进行打包成为app.jar</p><p>图2.1.3打包app.jar图</p><ol><li><strong>Docker镜像的打包和上传：</strong></li></ol><p>本实验对server.js进行打包，新建Dockerfile文件，写入</p><p><strong>Dockerfile：</strong></p><p>FROM node:6.14.2 使用node:6.14.2基础镜像</p><p>EXPOSE 8080暴露端口8080</p><p>COPY server.js .</p><p>CMD node server.js基于dockerfile深层的image运行container的默认运行程序指定为这个</p><p>docker build -t hello_world:v2 .通过docker对程序进行构建，并命名为hello_wolrd版本v2</p><p>docker tag hello_world:v2 944613709&#x2F;hello-world:v2 对刚才的hello_wolrd:v2进行打标签（换名字）改为944613709&#x2F;hello-world以便于之后上传dockerhub</p><p>docker push 944613709&#x2F;hello_world:v2上传dockerhub</p><p>图2.1.4 dockerhub</p><ol><li><strong>部署到 Kubernetes 中</strong></li></ol><p><strong>本实验用的是yaml方式，yaml方式相对于原始的纯cmd命令要效率高一些</strong></p><p>新建hello_world.yaml文件</p><p>命令kubectl create -f .&#x2F;hello_world.yaml 执行yaml文件来部署</p><p>图2.1.5 yaml文件内容</p><p>其中部署Service，命名为hello-world</p><p>模式为Nodeport，pod暴露8080映射为该服务的80端口</p><p>集群内其他节点可以通过80来访问pod的8080端口</p><p>并且nodePort&#x3D;31611，让集群外节点可以通过31611来访问pod的8080端口</p><p>图2.1.6 yaml文件内容</p><p>其中部署一个Deployment命名为hello-world</p><p>其中给定副本数量为3，每一个容器镜像为944613709&#x2F;hello_world，容器端口为8080</p><p>图2.1.7 yaml文件内容</p><h1 id="Kubernetes有哪些核心组件，其功能是什么？"><a href="#Kubernetes有哪些核心组件，其功能是什么？" class="headerlink" title="Kubernetes有哪些核心组件，其功能是什么？"></a>Kubernetes有哪些核心组件，其功能是什么？</h1><h2 id="官方定义的核心组件："><a href="#官方定义的核心组件：" class="headerlink" title="官方定义的核心组件："></a>官方定义的核心组件：</h2><p>参考官方文档：</p><p><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/components/">https://kubernetes.io/zh-cn/docs/concepts/overview/components/</a></p><p>图3.1 k8s所需的组件</p><p>图3.2 k8s所需的组件关系图</p><table><thead><tr><th><strong>组件分类</strong></th><th><strong>组件名</strong></th><th><strong>功能介绍</strong></th></tr></thead><tbody><tr><td>控制平面组件</td><td>控制平面组件</td><td>控制平面组件会为集群做出全局决策，比如资源的调度</td></tr><tr><td></td><td>kube-apiserve</td><td>API 服务器是 Kubernetes <a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。</td></tr><tr><td></td><td>etcd</td><td>一致且高度可用的键值存储，用作 Kubernetes 的所有集群数据的后台数据库</td></tr><tr><td></td><td>kube-scheduler</td><td>kube-scheduler 是控制平面的组件， 负责监视新创建的、未指定运行节点（node）的 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pods</a>， 并选择节点来让 Pod 在上面运行。</td></tr><tr><td></td><td>kube-controller-manager</td><td><a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/">kube-controller-manager</a> 是控制平面的组件， 负责运行控制器进程。</td></tr><tr><td></td><td>cloud-controller-manager</td><td>云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</td></tr><tr><td>Node 组件</td><td>Node 组件</td><td>节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境</td></tr><tr><td></td><td>kubelet</td><td>kubelet 会在集群中每个节点（node）上运行。 它保证<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers">容器（containers）</a>都运行在 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/">Pod</a> 中</td></tr><tr><td></td><td>kube-proxy</td><td><a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a> 是集群中每个节点（node）上所运行的网络代理， 实现 Kubernetes <a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">服务（Service）</a></td></tr><tr><td></td><td>容器运行时</td><td>容器运行环境是负责运行容器的软件</td></tr><tr><td>插件</td><td>插件</td><td>插件使用 Kubernetes 资源（DaemonSet、 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">Deployment</a> 等）实现集群功能</td></tr><tr><td></td><td>DNS</td><td>为 Kubernetes 服务提供 DNS 记录</td></tr><tr><td></td><td>Web 界面</td><td><a href="https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/resource-usage-monitoring/">容器资源监控</a> 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中， 并提供浏览这些数据的界面</td></tr><tr><td></td><td>集群层面日志</td><td><a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/logging/">集群层面日志</a>机制负责将容器的日志数据保存到一个集中的日志存储中， 这种集中日志存储提供搜索和浏览接口</td></tr></tbody></table><h2 id="个人认为在使用中的接触到的关键组件："><a href="#个人认为在使用中的接触到的关键组件：" class="headerlink" title="个人认为在使用中的接触到的关键组件："></a>个人认为在使用中的接触到的关键组件：</h2><table><thead><tr><th>组件</th><th>组件名</th></tr></thead><tbody><tr><td></td><td>Node</td></tr><tr><td></td><td>NameSpace</td></tr><tr><td></td><td>Pod</td></tr><tr><td></td><td>Deployment</td></tr><tr><td></td><td>Service</td></tr><tr><td></td><td>Ingress</td></tr><tr><td></td><td>Volume</td></tr><tr><td></td><td>Label</td></tr><tr><td></td><td>Master</td></tr></tbody></table><p>图3.3 k8s组件关系图</p><p><strong>Master：</strong>集群控制节点，每个集群需要至少一个master节点负责集群的管控</p><p><strong>Node：</strong>工作负载节点，由master分配容器到这些node工作节点上，然后node节点上的docker负责容器的运行</p><p><strong>Namespace：</strong>命名空间</p><p>实现多套环境的资源隔离或者多租户的资源隔离。</p><p>用于隔离资源使得不同空间的pods不会互相干扰</p><p><strong>Pod：</strong>运行中的一组容器，pod是k8s中应用的最小单位</p><p>程序要运行必须部署在容器中，而容器必须存在于Pod中。一个Pod容器中运行着多个container容器</p><p>图3.4 pod关系图</p><p><strong>Deployment：</strong></p><p>Pod是最小的控制单元，但是k8s很少直接控制Pod</p><p>一般利用Deployment控制Pod，使Pod拥有多副本，自愈，扩缩容等能力</p><p>图3.4 deployment关系图</p><p><strong>Service：</strong></p><p>service可以看作是一组同类Pod对外的访问接口。借助Service，应用可以方便地实现服务发现和负载均衡</p><p><strong>Service典型类型：</strong></p><p>ClusterIP：它是Kubernetes系统自动分配的虚拟IP，只能在集群内部访问NodePort：类型的Service允许NodeIp:NodePort来访问service</p><p>图3.4 service关系图</p><p><strong>Ingress：</strong></p><p>Ingress只需要一个NodePort或者一个LB就可以满足暴露多个Service的需求</p><p>实际上就是kubernetes对反向代理的一个抽象，它的工作原理类似于Nginx</p><h2 id="Volume："><a href="#Volume：" class="headerlink" title="Volume："></a><strong>Volume：</strong></h2><p>存储卷，用来管理k8s存储，一个volume卷可以被挂载在Pod中一个或者多个容器的指定路径下面。解决数据持久化存储的问题，将Pod和卷的生命周期分离</p><p><strong>Label ：</strong></p><p>标签，附加到某个资源上，用于关联对象、查询和筛选</p><h1 id="Kubernetes搭建过程中遇到的问题，与解决办法。"><a href="#Kubernetes搭建过程中遇到的问题，与解决办法。" class="headerlink" title="Kubernetes搭建过程中遇到的问题，与解决办法。"></a>Kubernetes搭建过程中遇到的问题，与解决办法。</h1><p><strong>Q1</strong>:服务器只有一台，合作之后发现针对某一台服务器无法实现既作为自己集群的master又作为其他集群的node</p><p>A1：重新开启两台虚拟机，重新搭建k8s</p><p><strong>Q2：</strong>遇见提示没有docker，kubernetes的command以及提示8080端口有误</p><p>A2：1.以为是自己没有安装好docker，后来发现是没有root权限是无法使用到docker命令。使用命令su root登录以获取root权限</p><ol><li>还需要对docker进行启动，使用开机自启动更加方便，利用命令systemctl start 和systemctl enable</li></ol><p>**Q3:**在第一次kubeadm init提示错误之后，再次kubeadm init提示文件错误</p><p>A3：在询问老师之后，才知道如果第一次init出现错误则会留存一些残余的配置文件，需要kubeadm reset才可以再次init，否则会被第一次的配置文件影响阻碍</p><p><strong>Q4：</strong>ifconfig无法拿到内网ip，没有发现显示内网ip</p><p>A4：由于使用的是vmware模拟两台虚拟机centos，最初猜测是网络模式设置问题.最初猜测是网络利用NAT模式不行，然后换成主桥模式，结果还是不行</p><p>之后从主桥模式换回NAT模式，发现ifconfig又一次出现了ip地址</p><p>猜测原因：长时间的待机可能有一些配置影响到了需要重新切换</p><p><strong>Q5：</strong>在node节点忘记换源折腾了半小时</p><p>A5：由于国内墙直接访问到dockerhub，速度非常的慢。我开始没有意识到，因为我在master换了源但是node没换，然后想在node打包时候就发现慢了</p><p><strong>Q6</strong>发现yml文件连不上githubsercontent</p><p>A6：最开始我尝试了挂梯子，然后我发现梯子由于采用的是role模式代理没有让我的虚拟机访问外网加速</p><p>然后我之后尝试去映射，直接找到ip，然后发现就通过了访问</p><p>在hosts设置映射，然后就可以连上了</p><p><strong>Q7：</strong>在master部署好了helo_world镜像发现，pod位于node1的全报错，位于master就可以running</p><p>A7：在k8s中要部署hello_world，Node需要hello_world镜像才可以部署，master的hello_world镜像影响不了node</p><p><strong>Q8：</strong>在k8s安装flannel时候利用换源过的yml文件结果报错了</p><p>A8：由于国内墙的存在无法直接访问到githubercontent那个资源网站</p><p>所以最开始尝试博客上给出的yml，利用的其中呢一些网站被换到了镜像网站</p><p>可是博客文章发表于2022&#x2F;2，在11月的今天再去访问发现爆错了无法访问（这也是我后面才发现的）</p><p>所以我建议以后在k8s安装flannel用原版的yml文件不要用野路子yml</p><p><strong>Q9：</strong>关于kube-flannel,不安装pod网络配置就会一直pending</p><p>A9：最开始一直显示Node1 not ready</p><p>然后我看kubectl get pod -n kube-system</p><p>然后找到对应的pod</p><p>输入命令kubectl describe pod kube-flannel-ds-amd64-6dsmg -n kube-system</p><p>发现问题就是kube-flannel这个镜像有点问题</p><p>仔细一看日志log发现是镜像一直没有拉取，但是奇怪的是在master机上docker images显示这个镜像已经在我本地机上了，然后我一直在弄master中的镜像，删除和重装。经历几次之后发现</p><p>Kubectl get pods -A显示出没有拉取镜像的其实是node1节点</p><p>说明系统是要在node1有那个镜像</p><p>此后在node1单独pull镜像成功之后就好了</p><p><strong>Q10:</strong> k8s部署时coredns出现CrashLoopBackOff的错误</p><p>A10：参考链接：<a href="https://blog.csdn.net/qq_40017011/article/details/116698422">https://blog.csdn.net/qq_40017011/article/details/116698422</a></p><p>通过kubectl get pods -A发现这里是coredns的错误</p><p>vi &#x2F;etc&#x2F;resolv.conf查看配置文件,</p><p>发现里面nameserver那一栏并不是主机master的地址,然后把他修改掉</p><p>192.168.217.132</p><p>192.168.217.1</p><p>vi修改完之后使用命令</p><p># systemctl stop kubelet # systemctl stop docker # iptables –flush # iptables -tnat –flush # systemctl start kubelet # systemctl start docker</p><p><strong>Q11：</strong>重启之后又一次k8s部署时coredns出现CrashLoopBackOff的错误</p><p>A11：我发现每一次重启之后这个配置文件都会重新被修改然后报错，就得自己手动改回去，可能是某种系统配置问题，但是再次手动修改resolv之后又恢复正常</p><p><strong>Q12：</strong>虚拟机在某段时间之后提示Xauortiry，导致ssh连接变慢，且无法获取管理员权限</p><p>A12：首先尝试删除Xauority文件发现不好使</p><p>参考链接：<a href="https://blog.csdn.net/dong_liuqi/article/details/108842873">https://blog.csdn.net/dong_liuqi/article/details/108842873</a></p><p>发现是应为&#x2F;home&#x2F;下没有创建&#x2F;userA&#x2F;文件夹且因为没有给userA对于&#x2F;home&#x2F;userA&#x2F;的写权限，所以导致在连接时无法创建文件.Xauthority</p><p>最后通过以下命令解决</p><p>sudo mkdir &#x2F;home&#x2F;a944613709</p><p>chown a944613709:a944613709 -R &#x2F;home&#x2F;a944613709</p><p>usermod -s &#x2F;bin&#x2F;bash a944613709</p>]]></content>
    
    
    <categories>
      
      <category>面向服务的软件系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向服务的软件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《面向服务的软件系统》实验二：Dubbo环境搭建与服务部署</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%AE%9E%E9%AA%8C%E4%BA%8C-120L021011-%E7%9F%B3%E5%8D%93%E5%87%A1/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%AE%9E%E9%AA%8C%E4%BA%8C-120L021011-%E7%9F%B3%E5%8D%93%E5%87%A1/</url>
    
    <content type="html"><![CDATA[<p>《面向服务的软件系统》实验报告</p><p>——实验二：Dubbo环境搭建与服务部署</p><p>姓名： 石卓凡 学号： 120L021011</p><h3 id="Dubbo框架与Zookeeper框架之间的关系是什么？如何将Zookeeper框架与Dubbo框架进行集成？"><a href="#Dubbo框架与Zookeeper框架之间的关系是什么？如何将Zookeeper框架与Dubbo框架进行集成？" class="headerlink" title="Dubbo框架与Zookeeper框架之间的关系是什么？如何将Zookeeper框架与Dubbo框架进行集成？"></a>Dubbo框架与Zookeeper框架之间的关系是什么？如何将Zookeeper框架与Dubbo框架进行集成？</h3><p><strong>关系：</strong></p><p><strong>关系概括：Dubbo框架中需要的服务注册中心可以由zookeeper来完成</strong></p><p>为了解决微服务遇到的各种问题，产生主流微服务框架Dubbo和Spring Cloud，比如说dubbo是一个远程调用服务的分布式框架，可以实现远程通讯、动态配置、地址路由等等功能</p><table><thead><tr><th>功能</th><th>Dubbo</th><th>SpringCloud</th></tr></thead><tbody><tr><td>服务注册中心</td><td>Zookeeper</td><td>Eureka(主流）、Consul、zookeeper</td></tr><tr><td>服务调用方式</td><td>RPC基于Dubbo协议</td><td>REST API 基于Http协议</td></tr><tr><td>服务监控</td><td>Dubbo-Monitor</td><td>Spring Boot Admin</td></tr><tr><td><strong>…</strong></td><td><strong>…</strong></td><td><strong>…</strong></td></tr></tbody></table><p>关于dubbo的众多功能中的服务注册中心功能，Dubbo目前支持4种注册中心，其中包括Zookeeper注册中心，并且Dubbo建议使用Zookeeper作为服务的注册中心，实现服务注册和发现</p><p><strong>Dubbo使用zookeeper具体来说：</strong></p><p><a href="https://so.csdn.net/so/search?q=dubbo&spm=1001.2101.3001.7020">dubbo</a>有很多服务的提供者和消费者，提供者和消费者需要一个管理中心来管理，这个时候用zookeeper来管理</p><p>如果没有zookeeper作为注册中心，具体流程如下图：</p><p>图1.1</p><table><thead><tr><th>Provider</th><th>暴露服务的服务提供方</th></tr></thead><tbody><tr><td>Consumer</td><td>调用远程服务的服务消费方</td></tr></tbody></table><p>如果使用zookeeper作为注册中心，具体流程</p><ol><li>服务容器负责启动加载，运行Provider。</li><li>Provider在启动时，向注册中心注册自己提供的服务。</li><li>Consumer在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回Provider地址列表给Consumer，如果有变更，注册中心将基于长连接推送变更数据给Consumer。</li><li>Consumer，从Provider地址列表中，基于软负载均衡算法，选一台Provider进行调用，如果调用失败，再选另一台调用。</li></ol><p>如下图：</p><p>图1.2</p><table><thead><tr><th>Provider</th><th>暴露服务的服务提供方</th></tr></thead><tbody><tr><td>Consumer</td><td>调用远程服务的服务消费方</td></tr><tr><td>Zookeeper</td><td>注册中心</td></tr></tbody></table><p><strong>集成过程：</strong></p><ol><li><p>下载zookeeper并且解压</p><p>图1.3</p><p>目录中创建 data、logs 两个目录作为 zookeeper的数据文件夹和日志文件夹</p><p>图1.4</p></li><li><p>下载dubbo-master，使用 maven 命令“mvn install -Dmaven.test.skip&#x3D;true”编译 dubbo-master 项目，使得每一个模块都可以在target文件夹下获取war文件</p><p>图1.5</p></li><li><p>将对应的.war文件放入tomcat的webapps文件夹对应位置</p><ol><li><p>编辑 D:\apache-tomcat-7.0.91\conf\server.xml，在&lt;Host&gt;节点下添加节点 &lt;Context docBase&#x3D;”D:&#x2F;dubbox-master&#x2F;dubbo-admin&#x2F;target&#x2F;dubboadmin-2.8.4” path&#x3D;”” reloadable&#x3D;”false”&#x2F;&gt;</p><p>图1.6</p></li><li><p>重新启动tomcat，等待tomcat的重新执行，此时就可以允许tomcat可以处理dubbo并且发布</p></li></ol></li><li><p>在对应的provider和consumer的xml配置文件中找到dubbo:regegisry标签，将address属性设置为想要设定的注册中心地址</p></li></ol><p>&lt;dubbo:registry address&#x3D;”zookeeper:&#x2F;&#x2F;127.0.0.1:2181”&#x2F;&gt;</p><ol><li>启动zookeeper，tomcat，可以直接访问dubbo 内置管理界面</li></ol><p><strong>集成完毕</strong></p><h3 id="Dubbo框架中的Dubbo-master的作用是什么？"><a href="#Dubbo框架中的Dubbo-master的作用是什么？" class="headerlink" title="Dubbo框架中的Dubbo-master的作用是什么？"></a>Dubbo框架中的Dubbo-master的作用是什么？</h3><p>Dubbo-master的主要作用是，作为dubbo的稳定版本，里面封装了dubbo的文件内容，可以做到mvn编译之后即可开箱即用，供客户简单方便将dubbo与tomcat或者spring集成使用</p><p>Dubbo-master是dubbo在git仓库中的master分支的内容，一般是目前的最稳定的代码版本，master为主分支，也是用于部署生产环境的分支。</p><p>其他分支比如dubbo-2.4.11-dev则是dubbo的2.4.11的dev版本</p><p><strong>Dubbo-master内容，包含了以下几个模块</strong></p><table><thead><tr><th><strong>公共逻辑模块</strong></th><th><strong>dubbo-common</strong></th><th>包括Util类和通用模型</th></tr></thead><tbody><tr><td><strong>远程通信模块</strong></td><td><strong>dubbo-remoting</strong></td><td>相当于dubbo协议的实现，如果RPC使用RRRMI协议则不需要使用此包</td></tr><tr><td><strong>远程调用模块</strong></td><td><strong>dubbo-rpc</strong></td><td>抽象各种协议，以及动态代理，包含一对一的调用，不关心集群的原理。</td></tr><tr><td><strong>集群模块</strong></td><td><strong>dubbo-cluster</strong></td><td>将多个服务提供方伪装成一个提供方,包括负载均衡,容错,路由等,集群的地址列表可以是静态配置的,也可以是注册中心下发的.</td></tr><tr><td><strong>注册中心模块</strong></td><td><strong>dubbo-registry</strong></td><td>基于注册中心下发的集群方式,以及对各种注册中心的抽象</td></tr><tr><td><strong>监控模块</strong></td><td><strong>dubbo-monitor</strong></td><td>统计服务调用次数,调用时间,调用链跟踪的服务</td></tr><tr><td><strong>配置模块</strong></td><td><strong>dubbo-config</strong></td><td>是dubbo对外的api,用户通过config使用dubbo,隐藏dubbo所有细节</td></tr><tr><td><strong>容器模块</strong></td><td><strong>dubbo-container</strong></td><td>是一个standlone的容器,以简单的main加载spring启动,因为服务通常不需要Tomcat&#x2F;Jboss等web容器的特性,没必要用web容器去加载服务.</td></tr></tbody></table><h3 id="Dubbo框架下Service-Provider发布服务的过程，及过程中的关键点。"><a href="#Dubbo框架下Service-Provider发布服务的过程，及过程中的关键点。" class="headerlink" title="Dubbo框架下Service Provider发布服务的过程，及过程中的关键点。"></a>Dubbo框架下Service Provider发布服务的过程，及过程中的关键点。</h3><p><strong>Provider：</strong></p><p>服务提供者，在注册中心注册作为服务提供的一方，发布服务到服务注册中心。本次实验provider模块作为提供者</p><p><strong>发布服务过程：</strong></p><ol><li><p><strong>服务容器负责启动加载，运行Provider。</strong></p><p>BootStrap中的ClassPathXmlApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(“META-INF&#x2F;spring&#x2F;provider.xml”);<br>ctx.start();</p><p>启动了spring的IOC容器，准备读取”META-INF&#x2F;spring&#x2F;provider.xml”文件作为应用程序上下文</p></li><li><p><strong>Provider在启动时，向注册中心注册自己提供的服务</strong>。</p><ol><li>读取provider模块中的”META-INF&#x2F;spring&#x2F;provider.xml”<ol><li>dubbo:application给应用配置基本信息</li><li>dubbo:registry给dubbo配置注册中心zookeeper</li><li>dubbo:protocol定义发布服务用到的dubbo和rest协议</li><li>bean注册spring bean给容器管理</li><li>Dubbo:service以dubbo或者rest协议发布服务去注册中心</li></ol></li><li>运行后完成向注册中心注册自己提供的服务</li></ol></li></ol><p><strong>本次实验，服务提供者代码分析：</strong></p><ol><li>在provider中的java目录下的service中存放实现多个Impl类（实现了api中的接口），比如UserRestServiceImpl，UserServiceImpl等，</li></ol><p>这些类就是后续将通过dubbo的注册中心发布并给消费者订阅</p><p>2.在provider中的resources&#x2F;META-INF&#x2F;spring中的provider.xml文件中，实现了spring和dubbo的衔接，是xml config配置文件，配置提供者相关的spring和dubbo的相关内容</p><p><strong>provider.xml提供者配置具体内容分析如下：</strong></p><p>Dubbo:application标签：本application的信息</p><p>适用于向dubbo控制中心提供本application的信息</p><table><thead><tr><th>name</th><th>当前应用名称，用于注册中心计算应用间依赖关系</th></tr></thead><tbody><tr><td>owner</td><td>应用负责人，用于服务治理</td></tr><tr><td>organization</td><td>组织名称(BU或部门)，用于注册中心区分服务来源</td></tr></tbody></table><p>并且可以在该标签下设置paramter属性比如qos</p><p>&lt;**dubbo:application name&#x3D;”provider” owner&#x3D;”programmer” organization&#x3D;”dubbox”**&gt;</p><p>&lt;**dubbo:parameter key&#x3D;”qos.enable” value&#x3D;”true”**&#x2F;&gt;</p><p>&lt;**dubbo:parameter key&#x3D;”qos.accept.foreign.ip” value&#x3D;”false”**&#x2F;&gt;</p><p>&lt;**dubbo:parameter key&#x3D;”qos.port” value&#x3D;”33333”**&#x2F;&gt;</p><p>&lt;&#x2F;**dubbo:application**&gt;</p><p>dubbo:registry标签：注册中心配置</p><p>其中的address为Provider指定注册中心的地址，使得provider去注册。</p><p>利用多个 &lt;dubbo:registry&gt; 标签，声明同时有多个不同的注册中心并在 &lt;dubbo:service&gt; 或 &lt;dubbo:reference&gt; 的 registry 属性指定使用的注册中心。</p><p><em>&lt;!–zookeeper注册中心, 多地址间用”,”隔开 –&gt;</em></p><p>&lt;**dubbo:registry address&#x3D;”zookeeper:&#x2F;&#x2F;127.0.0.1:2181”**&#x2F;&gt;</p><h1 id="dubbo-protocol标签：服务提供者协议配置"><a href="#dubbo-protocol标签：服务提供者协议配置" class="headerlink" title="dubbo:protocol标签：服务提供者协议配置"></a>dubbo:protocol标签：服务提供者协议配置</h1><p>为本次的provider后续的service发布提供了可选协议属性，比如这里定义了可以使用dubbo和rest协议</p><p><strong>Dubbo协议</strong>采用单一长连接和 NIO 异步通讯，在消费者直接利用注册中心引入并使用ctx.getBean(XXXXX.class)即可使用</p><p><strong>Rest协议</strong>需要消费者利用URL来调用，而本实验中的TestDubboRequest中不支持对于userRestService的getBean</p><p>&lt;**dubbo:protocol name&#x3D;”dubbo” serialization&#x3D;”kryo”optimizer&#x3D;”com.hit.lyx.dubbo.demo.api.common.SerializationOptimizerImpl”**&#x2F;&gt;</p><p>&lt;<strong>dubbo:protocol name&#x3D;”rest” port&#x3D;”8888” threads&#x3D;”500”</strong></p><p><strong>contextpath&#x3D;”services” server&#x3D;”tomcat” accepts&#x3D;”500”</strong></p><p><strong>extension&#x3D;”com.alibaba.dubbo.rpc.protocol.rest.support.LoggingFilter”</strong>&#x2F;&gt;</p><p>&lt;bean&gt;</p><p>spring的bean标签，在XML文件进行配置，让spring容器来生产和管理这些bean，类似于工厂模式管理类的实例</p><p>这里定义的bean被dubbo：service标签可以发布到注册中心</p><p><em>&lt;!–普通的spring bean–&gt;</em></p><p>&lt;**bean id&#x3D;”userService” class&#x3D;”com.hit.lyx.dubbo.demo.service.UserServiceImpl”**&#x2F;&gt;</p><p>&lt;**bean id&#x3D;”userRestService” class&#x3D;”com.hit.lyx.dubbo.demo.service.UserRestServiceImpl”**&gt;</p><p>&lt;**property name&#x3D;”userService” ref&#x3D;”userService”**&#x2F;&gt;</p><p>&lt;&#x2F;**bean**&gt;</p><h1 id="dubbo-service标签-服务提供者暴露服务配置"><a href="#dubbo-service标签-服务提供者暴露服务配置" class="headerlink" title="dubbo:service标签: 服务提供者暴露服务配置"></a>dubbo:service标签: 服务提供者暴露服务配置</h1><p>在这个标签中provider向注册中心发布以指定的协议想发布的服务，</p><table><thead><tr><th>interface</th><th>服务接口名</th></tr></thead><tbody><tr><td>ref</td><td>服务对象实现引用</td></tr><tr><td>protocol</td><td>使用指定的协议暴露服务</td></tr></tbody></table><p>以本实验代码为例：</p><p><strong>第一个dubbo</strong>：service标签，让id为userService，实现接口为com.hit.lyx.dubbo.demo.api.service.UserService的bean，以dubbo协议发布到注册中心.在消费者TestDubboRequest中，可以利用cxf.getBean(userService.class)获取到bean</p><p><em>&lt;!–服务提供者以dubbo协议发布服务–&gt;</em></p><p>&lt;<strong>dubbo:service interface&#x3D;”com.hit.lyx.dubbo.demo.api.service.UserService”</strong></p><p><strong>ref&#x3D;”userService” protocol&#x3D;”dubbo”</strong>&#x2F;&gt;</p><p><em>&lt;!–服务提供者发布rest服务–&gt;</em></p><p>&lt;<strong>dubbo:service interface&#x3D;”com.hit.lyx.dubbo.demo.api.service.UserRestService”</strong></p><p><strong>ref&#x3D;”userRestService” protocol&#x3D;”rest”</strong></p><p><strong>validation&#x3D;”true”</strong>&#x2F;&gt;</p><p><strong>第二个dubbo</strong>：service标签，让id为userRestService，实现接口为com.hit.lyx.dubbo.demo.api.service.userRestService的bean，以rest协议发布到注册中心.</p><p>可以通过访问”<a href="http://127.0.0.1:8888/services/users/1.xml%E2%80%9D%E6%88%96%E8%80%85%E2%80%9Dhttp://127.0.0.1:8888/services/users/1.json%E2%80%9D%E6%9D%A5%E8%AE%BF%E9%97%AEuserRestService">http://127.0.0.1:8888/services/users/1.xml”或者”http://127.0.0.1:8888/services/users/1.json”来访问userRestService</a></p><p><strong>启动类src&#x2F;test&#x2F;java&#x2F;Bootstrap.java分析：</strong></p><p>ClassPathXmlApplicationContext ctx &#x3D; <strong>new</strong> ClassPathXmlApplicationContext(<strong>“META-INF&#x2F;spring&#x2F;provider.xml”</strong>);</p><p>ctx.start();</p><p>创建 Spring 的 IOC 容器，生产管理了对应的bean实例以便于后续交给注册中心，被消费者所使用</p><p><strong>关键点：</strong></p><p><strong>Q1：控制台报错信息Qos started failed，经过推断猜测qos端口与其他端口发生了冲突，导致无法正常启动Qos的服务</strong></p><p>QoS，全称为Quality of Service，在Dubbo中，QoS这个概念被用于动态的对服务进行查询和控制在这类可以通过</p><p>&lt;**dubbo:parameter key&#x3D;”qos.port” value&#x3D;”33333”**&#x2F;&gt;的命令修改dubbo中的qos默认配置从而解决问题</p><p><strong>Q2：userRestService显示没有消费者</strong></p><p><strong>协议问题：</strong></p><p><strong>本次试验中除了userRestService以外其他采取的都是dubbo协议，userRestService是rest协议</strong></p><p><strong>Dubbo协议</strong></p><p>在消费者直接利用注册中心引入</p><p>并使用ctx.getBean(XXXXX.class)即可使用</p><p><strong>Rest协议</strong></p><p>需要消费者利用URL来调用，而本实验中的TestDubboRequest中没有写入对于userRestService的rest调用</p><p>所以dubbo中显示userRestServic没有消费者</p><p>如果强行添加了ctx.getBean(UserRestService.class)会提示报错</p><p><strong>Q3.userRestServiceImpl代码风格问题：</strong></p><p>如果按照dubbo官方文档的推荐写法应该要加入“&#x2F;”,本实验指导书给出的示例代码中缺少斜杠号&#x2F;</p><p>@path(“users”)–应该为–&gt;@path(“&#x2F;users”)</p><p>@path(“{id: \\d+}”)–应该为–&gt;@path(“&#x2F;{id: \\d+}”)</p><p>图3.1</p><p>但是无论是否修改，都可以利用<a href="http://localhost:8080/users/load?id=1001%E6%9D%A5%E8%B0%83%E7%94%A8userRestService">http://localhost:8080/users/load?id=1001来调用userRestService</a></p><h3 id="Dubbo框架下Service-Consumer消费服务的过程，及过程中的关键点。"><a href="#Dubbo框架下Service-Consumer消费服务的过程，及过程中的关键点。" class="headerlink" title="Dubbo框架下Service Consumer消费服务的过程，及过程中的关键点。"></a>Dubbo框架下Service Consumer消费服务的过程，及过程中的关键点。</h3><p><strong>Consumer：</strong></p><p>服务消费者，通过注册中心协调，订阅可用的已注册的服务。</p><p><strong>订阅服务过程：</strong></p><ol><li><p><strong>Consumer向注册中心订阅自己所需的服务。</strong></p><p>读取consumer模块中的”META-INF&#x2F;spring&#x2F;consumer.xml”</p><ol><li>dubbo:application给应用配置基本信息<ol><li>dubbo:registry给dubbo配置注册中心zookeeper</li><li>Dubbo:refernce生成远程服务代理，声明消费者订阅了哪些被提供者发布的服务，允许消费者像使用本地bean一样使用远程服务</li></ol></li></ol></li><li><p><strong>Consumer启动，注册中心返回Provider地址列表给Consumer，如果有变更，注册中心将基于长连接推送变更数据给Consumer。</strong></p><p>TestDubboRequest启动，通过ClassPathXmlApplicationContext ctx&#x3D;newClassPathXmlApplicationContext(“META-INF&#x2F;spring&#x2F;provider.xml”);ctx.start();启动了spring的IOC容器，读取provider.xml的应用程序上下文</p></li><li><p><strong>Consumer，从Provider地址列表中，基于软负载均衡算法，选一台Provider进行调用，如果调用失败，再选另一台调用。</strong></p><p>TestDubboRequest利用ctx对注册中心中被provider发布的服务进行订阅调用，可以直接ctx.getBean(UserService.class)来获取到userService的bean实例</p></li></ol><p><strong>本次实验，消费提供者代码分析：</strong></p><ol><li>在java目录下有个TestDubooRequest的启动类，负责启动消费者</li><li>在provider中的resources&#x2F;META-INF&#x2F;spring中的consumer.xml文件中，实现了spring和dubbo的衔接，是xml config配置文件，配置提供者相关的spring和dubbo的相关内容</li></ol><p><strong>Consumer.xml消费者配置具体内容分析如下：</strong></p><p><strong>同provider的标签</strong></p><p>dubbo:application</p><p>dubbo:registry</p><p><strong>不同标签：</strong></p><p><strong>dubbo:reference标签：</strong> 服务消费者引用服务配置</p><p>生成远程服务代理，可以像使用本地bean一样使用demoService</p><p>消费者订阅的服务, 默认情况下需要先发布服务才能订阅, 通过添加check&#x3D;”false”可以直接订阅任意服务,只是调用时需要注意判断是否可用</p><table><thead><tr><th>id</th><th>服务引用BeanId</th></tr></thead><tbody><tr><td>interface</td><td>服务接口名</td></tr></tbody></table><p>比如第一个标签，指定了BeanId&#x3D;”userRestService” 实现的接口是”com.hit.lyx.dubbo.demo.api.service.UserRestService”的bean被消费者引入</p><p>&lt;**dubbo:reference id&#x3D;”userRestService” interface&#x3D;”com.hit.lyx.dubbo.demo.api.service.UserRestService”**&#x2F;&gt;</p><p><strong>TestDubboRequest消费者启动类具体内容分析如下：</strong></p><p>1.根据路径找到配置上下文，启动spring的IOC容器</p><p>ClassPathXmlApplicationContext ctx &#x3D; <strong>new</strong> ClassPathXmlApplicationContext(<strong>“META-INF&#x2F;spring&#x2F;consumer.xml”</strong>);</p><p>ctx.start();</p><p>2.通过IOC容器和注册中心的共同作用下，利用getBean()方法调用提供者的bean来给消费者进行使用</p><p>比如UserService service &#x3D; ctx.getBean(UserService.class);调用了userSerivce的bean</p><p><strong>关键点：</strong></p><p><strong>指导书展示效果原理分析</strong></p><p>“b) 分别在启动 provider.Bootstrap、consumer. TestDubboRequest 后重新查看服务列表: ”</p><p><strong>现象：出现了UserRestService提示没有消费者</strong></p><p><strong>原因：</strong>在消费者启动类中TestDubboRequest中，没有ctx.getBean(UserRestService)因此没有直接向注册中心调用</p><p>图4.1</p><p><strong>现象：如果在TestDubboRequest中加入UserRestService userRestService &#x3D; ctx.getBean(UserRestService.class);</strong></p><p>提示报错：Error creating bean with name ‘userRestService’: FactoryBean threw exception on object creation;</p><p>图4.2</p><p><strong>原因分析</strong>：在provider中我们发布userRestService是利用的rest协议，想要通过dubbo使用rest协议的服务还需要配置setter等，因此在本试验中不利用getBean直接获取，而得是通过URL获取。</p><p>其他的类由于是通过Dubbo协议发布，所以其他类可以利用getBean</p><p>“c) 在 consumer. TestDubboRequest 控制台中输入任意数字并回车,查看输出;”</p><p>现象：</p><p>控制台就得到</p><p>图4.3</p><p><strong>原因分析：</strong></p><p>在TestDubboRequest中获取System.in作为id参数，然后调用service.getUser(id)</p><p>图4.4</p><p>图4.5</p><p>方法将返回一个new User的toString（），然后这份String就输出在控制台中</p><p>“d) 在 浏 览 器 地 址 栏 输 入</p><p>127.0.0.1:8888&#x2F;services&#x2F;users&#x2F;1.json 、</p><p>127.0.0.1:8888&#x2F;services&#x2F;users&#x2F;1.xml</p><p>查 看 浏 览 器 及 provider.Bootstap 的输出:”</p><p>现象：</p><p>浏览器：</p><p>图4.6浏览器输出json</p><p>图4.7浏览器输出xml</p><p>控制台provider的输出：</p><p>图4.8控制台输出报错</p><p>图4.9控制台输出信息</p><p><strong>问题：</strong>提示没有找到favicon.ico</p><p><strong>原因分析：</strong></p><p>Favicon是与某个网站或<a href="https://baike.baidu.com/item/%E7%BD%91%E9%A1%B5?fromModule=lemma_inlink">网页</a>相关联的<a href="https://baike.baidu.com/item/%E5%9B%BE%E6%A0%87?fromModule=lemma_inlink">图标</a>，</p><p>比如说<img src="/shizhuofan.GitHub.io/media/7c5b99fac1e74e50a2014cda5d8d1744.png">百度的<img src="/shizhuofan.GitHub.io/media/7a9f150968df0e556ed9d9319a443855.png">。</p><p>在本demo中的resources资源目录中没有存放favicon图标，spring在执行过程中发布网页之后自然无法找到。在springboot中可以通过在resources中提供favicon.ico图标即可将图标发布到Web上</p><p><strong>问题：</strong>控制台信息是为什么输出这段内容</p><p><strong>原因分析：</strong></p><p>127.0.0.1:8888&#x2F;services&#x2F;users&#x2F;1.json和127.0.0.1:8888&#x2F;services&#x2F;users&#x2F;1.xml都对应的是provider在dubbo中以rest风格发布的userRestService</p><p>Rest协议就是将这个userRestService服务要实现的功能，提供如下URL，而任何客户端都可以将包含用户信息的JSON字符串POST到以上URL来完成用户注册</p><p>在userRestServiceImpl中：</p><p>图4.9代码</p><p>@Path(“&#x2F;users”)指定访问UserRestService的URL相对路径是&#x2F;users</p><p>@GET指定访问用HTTP GET方法</p><p>@Path(“&#x2F;{id : \\d+}”)根据上面结合分析，访问的URL应当是“<a href="http://localhost:端口/users/">http://localhost:端口/users/</a> + 任意数字”，其中{id : \\d+}使用了正则表达式，要求是id为数字数字</p><p>代表路径为&#x2F;users&#x2F;{id}，method为GET方式</p><p>@Consumes({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})</p><p>指定接收JSON格式和xml格式的数据。REST框架会自动将JSON数据和xml数据，反序列化为User对象</p><p>@Produces({ContentType.APPLICATION_JSON_UTF_8,ContentType.TEXT_XML_UTF_8})</p><p>指定输出JSON格式或者xml格式的数据。框架会自动将User对象序列化为JSON数据或者xml格式。</p><p>因此：访问127.0.0.1:8888&#x2F;services&#x2F;users&#x2F;1.json将传送json格式的数据给后端userRestServiceImpl然后，后端返回json格式数据展示在前端网页</p><h3 id="详细描述你的服务的发布过程和被消费方式。"><a href="#详细描述你的服务的发布过程和被消费方式。" class="headerlink" title="详细描述你的服务的发布过程和被消费方式。"></a>详细描述你的服务的发布过程和被消费方式。</h3><ol><li><p><strong>服务容器负责启动加载，通过BootStrap运行Provider。</strong></p><p>BootStrap中的ClassPathXmlApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(“META-INF&#x2F;spring&#x2F;provider.xml”);<br>ctx.start();</p><p>启动了spring的IOC容器，准备读取”META-INF&#x2F;spring&#x2F;provider.xml”文件作为应用程序上下文</p></li><li><p><strong>Provider在启动时，向注册中心注册自己提供的服务</strong>。</p><ol><li>读取provider模块中的”META-INF&#x2F;spring&#x2F;provider.xml”<ol><li>dubbo:application给应用配置基本信息</li><li>dubbo:registry给dubbo配置注册中心zookeeper</li><li>dubbo:protocol定义发布服务用到的dubbo和rest协议</li><li>bean注册spring bean给容器管理</li><li>Dubbo:service以dubbo或者rest协议发布服务去注册中心</li></ol></li><li>向注册中心注册自己提供的服务:userRestSertvice,userService,hsuse,houseManager,userManager,utilData这几个服务</li></ol></li><li><p><strong>Consumer向注册中心订阅自己所需的服务。</strong></p><ol><li>读取consumer模块中的”META-INF&#x2F;spring&#x2F;consumer.xml”<ol><li>dubbo:application给应用配置基本信息</li><li>dubbo:registry给dubbo配置注册中心zookeeper</li><li>Dubbo:refernce生成远程服务代理，声明消费者订阅了哪些被提供者发布的服务，允许消费者像使用本地bean一样使用远程服务</li><li>读取到userRestSertvice,userService,hsuse,houseManager,userManager,utilData这几个服务</li></ol></li></ol></li><li><p><strong>Consumer启动，注册中心返回Provider地址列表给Consumer，如果有变更，注册中心将基于长连接推送变更数据给Consumer。</strong></p><ol><li>TestDubboRequest启动，通过ClassPathXmlApplicationContext ctx&#x3D;newClassPathXmlApplicationContext(“META-INF&#x2F;spring&#x2F;provider.xml”);ctx.start();启动了spring的IOC容器，读取provider.xml的应用程序上下文</li></ol></li><li><p><strong>Consumer，从Provider地址列表中，基于软负载均衡算法，选一台Provider进行调用，如果调用失败，再选另一台调用。</strong></p><ol><li>TestDubboRequest利用ctx对注册中心中被provider发布的服务进行订阅调用，可以直接ctx.getBean(UserService.class)来获取到userService的bean实例</li></ol></li></ol><p><strong>关键点：</strong></p><p>如果在provider中注释掉某个dubbo：service标签比如UserService，然后启动消费者TestDubboRequest会提示对应的服务没有提供者</p><p>图5.1</p><p>如果只启动提供者的BootStrap而不启动消费者的TestDubboRequest，会提示所有服务都没有消费者</p><p>图5.2</p><p>如果在provider中注释掉某个dubbo：service标签比如UserService，然后不启动消费者TestDubboRequest会在dubbo中，刚才注释的服务不会出现</p><p>图5.3</p><p>如果启动provider的BootStrap，然后仅注释掉消费者中的consumer.xml中的dubbo:reference标签比如userService，启动消费者TestDubboRequest</p><p>会提示找不到注释掉的UserService找不到对应的bean</p><p>图5.4</p><p>如果启动provider的BootStrap，然后仅注释掉消费者中的TestDubboRequest</p><p>中的ctx.getBean()标签比如UtilData，启动消费者TestDubboRequest</p><p>dubbo会提示没有消费者</p>]]></content>
    
    
    <categories>
      
      <category>面向服务的软件系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向服务的软件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《面向服务的软件系统》实验四：微服务综合实验</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%AE%9E%E9%AA%8C%E5%9B%9B-120L021011-%E7%9F%B3%E5%8D%93%E5%87%A1-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E5%AE%9E%E9%AA%8C%E5%9B%9B-120L021011-%E7%9F%B3%E5%8D%93%E5%87%A1-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<p>《面向服务的软件系统》实验报告</p><p>——实验四：微服务综合实验</p><p>姓名： 石卓凡 学号： 120L021011</p><p>目录</p><p><a href="#%E5%A6%82%E6%9E%9C%E4%BD%A0%E8%A6%81%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%9C%80%E7%BB%88%E8%A6%81%E9%83%A8%E7%BD%B2%E5%9C%A8k8s%E7%AE%A1%E7%90%86%E7%9A%84%E9%95%9C%E5%83%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%A0%E8%AE%A4%E4%B8%BA%E5%BA%94%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%B8%8E%E6%9C%AC%E6%AC%A1%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B%E7%9B%B8%E6%AF%94%E5%93%AA%E4%BA%9B%E6%94%B9%E8%BF%9B%E5%8F%AF%E4%BB%A5%E8%AE%A9%E5%BC%80%E5%8F%91%E6%9B%B4%E5%8A%A0%E5%90%88%E7%90%86%E9%AB%98%E6%95%88">1、 如果你要从头开发一个基于微服务架构的项目，项目中的服务最终要部署在k8s管理的镜像环境中，你认为应如何创建项目？与本次实验过程相比，哪些改进可以让开发更加合理高效？ 2</a></p><p><a href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE">创建项目 2</a></p><p><a href="#%E6%94%B9%E8%BF%9B">改进 3</a></p><p><a href="#%E5%A6%82%E4%BD%95%E5%B0%86%E5%AE%9E%E9%AA%8C%E4%B8%AD%E5%A4%9A%E4%B8%AAprovider%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E6%94%B9%E4%B8%BA%E8%BD%AE%E8%AF%A2%E8%B0%83%E7%94%A8%E5%8D%B3%E5%9C%A8%E5%A4%9A%E6%AC%A1%E5%8F%8D%E5%A4%8D%E8%B0%83%E7%94%A8%E6%97%B6%E8%BD%AE%E6%B5%81%E8%B0%83%E7%94%A8%E5%90%84%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B">2、 如何将实验中多个provider服务实例的负载均衡策略改为轮询调用？即在多次反复调用时轮流调用各个服务实例。 5</a></p><p><a href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">3、 实验过程中遇到的主要问题与解决办法。 9</a></p><p><a href="#1%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98">1.服务器内存问题 10</a></p><p><a href="#2%E5%A4%9A%E6%AC%A1%E6%98%BE%E7%A4%BAprovider%E7%9A%84%E5%90%8C%E4%B8%80ip%E9%97%AE%E9%A2%98">2.多次显示provider的同一ip问题 10</a></p><p><a href="#3dubbo-admin%E9%83%A8%E7%BD%B2%E9%97%AE%E9%A2%98">3.Dubbo-admin部署问题 11</a></p><p><a href="#31%E9%83%A8%E7%BD%B2%E6%9C%80%E6%96%B0%E7%89%88dubbo-admin%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98">3.1.部署最新版Dubbo-admin中的问题 11</a></p><p><a href="#32%E9%83%A8%E7%BD%B2%E6%97%A7%E7%89%88dubbo-admin">3.2.部署旧版dubbo-admin 12</a></p><p><a href="#4%E9%83%A8%E7%BD%B2%E6%89%93%E5%8C%85provider%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98">4.部署打包provider中的问题 13</a></p><p><a href="#41api%E5%92%8Cprovider%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E6%89%93%E5%8C%85provider">4.1.Api和provider的依赖关系，导致无法打包provider 13</a></p><p><a href="#42%E6%89%93%E5%8C%85%E4%B8%BAjar%E7%94%B1%E4%BA%8E%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%9C%A8test%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E6%89%BE%E5%88%B0%E5%90%AF%E5%8A%A8%E7%B1%BB">4.2.打包为jar，由于启动类在Test文件夹中无法自动找到启动类 14</a></p><p><a href="#43provider%E6%89%93%E5%8C%85%E5%A5%BD%E7%9A%84%E9%95%9C%E5%83%8F%E7%9A%84docker%E7%9A%84%E5%AE%B9%E5%99%A8%E8%87%AA%E5%8A%A8%E9%80%80%E5%87%BA">4.3.provider打包好的镜像的docker的容器自动退出 16</a></p><p><a href="#44docker%E6%AF%8F%E6%AC%A1%E9%83%BD%E9%9C%80%E8%A6%81%E8%BF%9B%E5%85%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8C%85%E9%95%9C%E5%83%8F%E6%9C%89%E7%82%B9%E9%BA%BB%E7%83%A6%E5%BD%93%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%97%B6%E5%80%99%E6%97%A0%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%B7%A5%E4%BD%9C">4.4.docker每次都需要进入虚拟机进行打包镜像，有点麻烦，当虚拟机无法连接到时候，无法进行工作 16</a></p><p><a href="#5%E5%A6%82%E4%BD%95%E5%9C%A8%E5%90%8E%E7%BB%AD%E6%9F%A5%E7%9C%8Bprovider%E7%9A%84ip">5.如何在后续查看provider的ip 17</a></p><p><a href="#6%E7%AB%AF%E5%8F%A3%E9%97%AE%E9%A2%98">6.端口问题 18</a></p><p><a href="#%E5%AF%B9%E6%95%B4%E9%97%A8%E5%AE%9E%E9%AA%8C%E8%AF%BE%E7%A8%8B%E6%9C%89%E4%BD%95%E6%84%8F%E8%A7%81%E6%88%96%E5%BB%BA%E8%AE%AE">4、 对整门实验课程有何意见或建议。 18</a></p><p><a href="#%E5%9B%9B%E4%B8%AA%E5%AE%9E%E9%AA%8C%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%8C%87%E5%AF%BC%E4%B9%A6%E7%9A%84%E5%BB%BA%E8%AE%AE">1. 四个实验的设计以及对应的实验指导书的建议 18</a></p><p><a href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9">实验内容 18</a></p><p><a href="#%E5%AE%9E%E9%AA%8C%E6%8C%87%E5%AF%BC%E4%B9%A6">实验指导书 19</a></p><p><a href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%9A%84%E9%97%AE%E9%A2%98">2. 前置知识的问题 19</a></p><h1 id="如果你要从头开发一个基于微服务架构的项目，项目中的服务最终要部署在k8s管理的镜像环境中，你认为应如何创建项目？与本次实验过程相比，哪些改进可以让开发更加合理高效？"><a href="#如果你要从头开发一个基于微服务架构的项目，项目中的服务最终要部署在k8s管理的镜像环境中，你认为应如何创建项目？与本次实验过程相比，哪些改进可以让开发更加合理高效？" class="headerlink" title="如果你要从头开发一个基于微服务架构的项目，项目中的服务最终要部署在k8s管理的镜像环境中，你认为应如何创建项目？与本次实验过程相比，哪些改进可以让开发更加合理高效？"></a>如果你要从头开发一个基于微服务架构的项目，项目中的服务最终要部署在k8s管理的镜像环境中，你认为应如何创建项目？与本次实验过程相比，哪些改进可以让开发更加合理高效？</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p><strong>采用以下步骤：</strong></p><ul><li>明确项目的需求和目标，并确定项目中需要包含哪些微服务。</li><li>建立项目的架构，设计每个微服务的功能和接口，并确定微服务之间的交互方式。</li><li>根据项目的架构，分别开发各个微服务。</li><li>将开发的微服务打包成镜像，上传到镜像仓库。</li><li>在k8s管理的镜像环境中部署项目，并测试各个微服务的功能和性能。</li><li>如果发现问题，及时调整项目的架构和代码，并重新部署。</li></ul><p>这些步骤中，最重要的是明确项目的需求和目标，并设计合理的架构。这样才能确保项目的可扩展性和可维护性，并且能够顺利地部署在k8s管理的镜像环境中。</p><p><strong>以springcloud框架，dockerhub镜像仓库为例的具体步骤及注意事项</strong></p><ol><li>明确项目需求，确定springcloud最终划分模块数量及每个模块功能</li><li>构建springcloud项目，分为多个模块。每个模块的端口号要写清楚，方便之后部署暴露对应端口</li><li>使用maven，在maven写好build标签，给每一个模块一个清晰的打包模块名。且maven中利用好parent和child标签，给整个项目有一个root模块可以对所有模块进行管理，并且将公共依赖放入root的pom文件</li><li>每个模块写dockerfile，dockerfile中的端口号要一一对应</li><li>先打包为docker镜像，然后在docker中创建容器，通过容器是否成功运行和是否容器中运行有预期结果来进行判断镜像是否打包成功。</li><li>Docker镜像如果有误，则重新检查代码以及打包过程，如果Docker镜像确定无误后，上传dockerhub</li><li>在k8s服务器中写好deployment,service,volume等yaml文件，根据需求选定service类型，deployment实例个数，volume种类和容量大小，然后使用yaml文件进行部署微服务项目。</li><li>测试k8s中部署项目是否无误，如果发现问题，及时调整项目的架构和代码，并重新部署。</li></ol><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ol><li>我会明确每个微服务项目的端口，写明使用到的端口，这样方便后续k8s的部署，在本次实验中的项目中需要暴露端口8888没有明确单独写出来，而是得去配置文件搜寻。改进点就是直接写明需要暴露哪些端口，防止端口不正确带来的问题</li><li>我会通过maven的root根项目来对所有微服务模块进行maven管理，这样可以同时install和package而不用对每个模块再单独依次打包，且避开了因为父子模块依赖而产生的特定打包顺序问题。</li><li>将公共依赖放入root的pom文件，这样就避免了子模块之间多个重复依赖</li></ol><p>图1.1使用root进行管理整个项目</p><ol><li>选用jenkins自动化部署，可以简化部署流程，也能够使得整个项目的过程更加合理高效</li></ol><p>图1.2使用jenkins的控制台</p><ol><li>可以把dockerhub仓库改为harbor镜像仓库，如果在企业项目不想放入dockerhub中可以自己搭建私有的harbor镜像仓库，保证了项目的私密性和安全性，更加符合实际情况。</li></ol><h1 id="如何将实验中多个provider服务实例的负载均衡策略改为轮询调用？即在多次反复调用时轮流调用各个服务实例。"><a href="#如何将实验中多个provider服务实例的负载均衡策略改为轮询调用？即在多次反复调用时轮流调用各个服务实例。" class="headerlink" title="如何将实验中多个provider服务实例的负载均衡策略改为轮询调用？即在多次反复调用时轮流调用各个服务实例。"></a>如何将实验中多个provider服务实例的负载均衡策略改为轮询调用？即在多次反复调用时轮流调用各个服务实例。</h1><p><strong>思路：</strong></p><p>负载均衡策略可通过 Host 的IPVS（即 K8s 集群节点的IPVS）来实现的</p><p><strong>原理</strong></p><p>service底层实现主要由两个网络模式组成：iptables与IPVS。他们都是有kube-proxy维护</p><p>图service底层概念图</p><p>图service工作流程图</p><p>k8s的service默认是采用iptables为网络模式：且iptables默认的负载均衡是random随机策略</p><p>使用命令可以查看iptables当前的一些规则</p><p>iptables-save</p><p>k8s的service可以改为ipvs模式</p><p>使用命令可以查看ipvs规则</p><p>ipvsadm -L -n</p><p>而IPVS的负载均衡方式如下</p><table><thead><tr><th>负载均衡方法</th><th>描述</th></tr></thead><tbody><tr><td>round-robin</td><td>轮询调度是一种以轮询的方式依次将一个域名解析到多个IP 地址的调度不同服务器的计算方法</td></tr><tr><td>least connection</td><td>最小连接调度（Least-Connection Scheduling）算法是把新的连接请求分配到当前连接数最小的服务器</td></tr><tr><td>source hash</td><td>源地址哈希法是根据请求来源的地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一源地址的请求，当服务器列表不变时，它每次都会映射到同一台服务器进行访问。</td></tr><tr><td>Random（默认）</td><td>随机算法完成负载均衡</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>图查看本实验中的iptable的nat表</p><p>则本实验中想要采用轮询调用</p><p><strong>大致步骤如下：</strong></p><ul><li>service切换为IPVS网络模式</li><li>切换IPVS使用轮询的负载均衡策略</li></ul><ol><li>使用命令在master节点上</li></ol><p>kubectl edit configmap kube-proxy -n kube-system</p><p>图kubeconfig.conf</p><ol><li>更改配置</li></ol><p>然后发现当前我的服务已经默认为ipvs模式（Mode: ipvs）,但是负载均衡模式没有指定（默认为随机random）</p><p>之后修改为</p><p>scheduler: “rr”</p><ol><li>重新应用新配置</li></ol><p>然后需要让kube-proxy重新应用新的配置，这里采用删除等待其自动重建并且应用新的网络模式。</p><p>最后重启之后发现服务实例成功改为了轮询调用rr</p><p>图：成功示例</p><h1 id="实验过程中遇到的主要问题与解决办法。"><a href="#实验过程中遇到的主要问题与解决办法。" class="headerlink" title="实验过程中遇到的主要问题与解决办法。"></a>实验过程中遇到的主要问题与解决办法。</h1><h2 id="1-服务器内存问题"><a href="#1-服务器内存问题" class="headerlink" title="1.服务器内存问题"></a>1.服务器内存问题</h2><p>服务器内存太小了，然后我部署的东西太多了，导致我后来部署provider时候一直自动重启pod，</p><p>导致dubbo无法持续检测到，我还以为是代码问题改了一下午，结果最后反应过来是内存已经不够了。</p><p>并且后续内存不够，会导致服务器无法正常关闭，一直显示关闭中。因此为了以防万一，使用快照是很重要的</p><p><strong>解决方法：</strong></p><ol><li>删除一部分自己的deployment</li><li>取出master的污点，在加入master分担</li><li>给服务器扩容</li></ol><p>图2.1服务器内存和CPU使用率</p><h2 id="2-多次显示provider的同一ip问题"><a href="#2-多次显示provider的同一ip问题" class="headerlink" title="2.多次显示provider的同一ip问题"></a>2.多次显示provider的同一ip问题</h2><p>由于默认选用的是负载均衡，所以多次consumer都是直接对应的第一个provider，只有快速多次连续输入请求之后才会跳转其他provider</p><p><strong>解决方法：</strong>设为轮询访问，或者快速多次输入</p><h2 id="3-Dubbo-admin部署问题"><a href="#3-Dubbo-admin部署问题" class="headerlink" title="3.Dubbo-admin部署问题"></a>3.Dubbo-admin部署问题</h2><h3 id="3-1-部署最新版Dubbo-admin中的问题"><a href="#3-1-部署最新版Dubbo-admin中的问题" class="headerlink" title="3.1.部署最新版Dubbo-admin中的问题"></a>3.1.部署最新版Dubbo-admin中的问题</h3><p>参考官方github链接：</p><p><a href="https://github.com/apache/dubbo-admin/blob/develop/README_ZH.md/#12-%E4%BD%BF%E7%94%A8-Kubernetes-%E6%96%87%E4%BB%B6">https://github.com/apache/dubbo-admin/blob/develop/README_ZH.md\#12-%E4%BD%BF%E7%94%A8-Kubernetes-%E6%96%87%E4%BB%B6</a></p><p>最新的dubbo-admin中已经将tomcat集成在dubbo中不需要额外的tomcat运行，所以最开始尝试新版admin</p><h4 id="3-1-1github访问失败"><a href="#3-1-1github访问失败" class="headerlink" title="3.1.1github访问失败"></a>3.1.1github访问失败</h4><p>图2.2github访问失败</p><p>这个还是因为墙的问题</p><p><strong>解决方法：</strong>服务器上无法使用VPN梯子，因此我选择直接在服务器上借助hosts查找域名ip</p><h4 id="3-1-2无法正常cd进入目标文件夹"><a href="#3-1-2无法正常cd进入目标文件夹" class="headerlink" title="3.1.2无法正常cd进入目标文件夹"></a>3.1.2无法正常cd进入目标文件夹</h4><p>发现官网给出的cd地址还需要加入&#x2F;root前缀，代表用户名</p><p><strong>解决方法：</strong>加入&#x2F;root</p><h4 id="3-1-3最终新版dubbo-admin成功部署，但是root账户权限出错"><a href="#3-1-3最终新版dubbo-admin成功部署，但是root账户权限出错" class="headerlink" title="3.1.3最终新版dubbo-admin成功部署，但是root账户权限出错"></a>3.1.3最终新版dubbo-admin成功部署，但是root账户权限出错</h4><p>图2.4dubbo-admin权限出错</p><p>猜测可能是新版的dubbo-admin不兼容之类的问题</p><p>最终再多次重新部署仍然无法解决之后，我选择放弃新版dubbo</p><p><strong>解决方法：</strong>更换回老版本dubbo</p><h3 id="3-2-部署旧版dubbo-admin"><a href="#3-2-部署旧版dubbo-admin" class="headerlink" title="3.2.部署旧版dubbo-admin"></a>3.2.部署旧版dubbo-admin</h3><p>沿用lab2旧版的dubbo，选用的部署方案是</p><p>服务器k8s部署zookeeper+本机启动tomcat来配合生成dubbo-admin</p><h4 id="3-2-1-单独修改WEB-INF下的properties配置文件发现没有用"><a href="#3-2-1-单独修改WEB-INF下的properties配置文件发现没有用" class="headerlink" title="3.2.1.单独修改WEB-INF下的properties配置文件发现没有用"></a>3.2.1.单独修改WEB-INF下的properties配置文件发现没有用</h4><h4 id><a href="#" class="headerlink" title></a></h4><p>图2.5WEB-INF下的properties</p><p>发现仅仅修改这个无法改变tomcat部署中的zookeeper地址</p><p><strong>原理：</strong>tomcat会自动War包可以放在Tomcat下的webapps或者word目录下，随着tomcat服务器的启动，它可以自动被解压。应该从头开始修改War包</p><p><strong>解决方案：</strong>从dubbo-master开始修改</p><p>图2.6dubbo-master项目</p><p>修改dubbo-master中的zookeeper地址</p><p>去找原来的</p><p>D:\360MoveData\Users\86189\Desktop\Service-orientedtechnology development\lab2\dubbox-master</p><p>然后在dubbox项目中把127.0.0.1:2181换成zookeeper:&#x2F;&#x2F;47.92.244.182:32273</p><p>重新install</p><h2 id="4-部署打包provider中的问题"><a href="#4-部署打包provider中的问题" class="headerlink" title="4.部署打包provider中的问题"></a>4.部署打包provider中的问题</h2><h3 id="4-1-Api和provider的依赖关系，导致无法打包provider"><a href="#4-1-Api和provider的依赖关系，导致无法打包provider" class="headerlink" title="4.1.Api和provider的依赖关系，导致无法打包provider"></a>4.1.Api和provider的依赖关系，导致无法打包provider</h3><p>之前一直使用的是api的package而没有使用install，导致后续打包provider的时候无法找到api的依赖项</p><p><strong>原理：</strong></p><p>Maven 的 install 命令和 package 命令都可以用于构建项目，但是它们的作用略有不同。</p><p>Maven 的 install 命令会将项目的构建结果（如 jar 包）安装到本地仓库中，以供其它项目使用。例如，如果项目 A 依赖于项目 B，那么在构建项目 B 时，可以使用 Maven 的 install 命令将项目 B 的 jar 包安装到本地仓库中，然后在构建项目 A 时，Maven 会自动从本地仓库中查找并加载项目 B 的 jar 包。</p><p>Maven 的 package 命令仅会生成项目的构建结果，但不会将其安装到本地仓库中。例如，如果您使用 Maven 的 package 命令来构建项目 B，那么 Maven 会在项目 B 的 target 目录下生成 jar 包，但不会安装到本地仓库中。如果项目 A 依赖于项目 B，则需要手动将项目 B 的 jar 包复制到项目 A 的依赖路径下，或者使用 Maven 的 install 命令来安装项目 B 的 jar 包。</p><h3 id="4-2-打包为jar，由于启动类在Test文件夹中无法自动找到启动类"><a href="#4-2-打包为jar，由于启动类在Test文件夹中无法自动找到启动类" class="headerlink" title="4.2.打包为jar，由于启动类在Test文件夹中无法自动找到启动类"></a>4.2.打包为jar，由于启动类在Test文件夹中无法自动找到启动类</h3><p>当时使用了两种解决方案，方案1失败，方案2最终成功</p><p><strong>方案1失败</strong></p><p>在IDEA的项目结构中导入现有模块，然后指定启动类，然后点击构建工件jar</p><p>图2.7.1导入现有模块</p><p>图2.7.2构建现有模块</p><p><strong>方案2成功</strong></p><p>修改pom文件，加入build标签内容</p><ol><li>&lt;build&gt;</li><li>&lt;finalName&gt;provider&lt;&#x2F;finalName&gt;<em>&lt;!– 导出jar的名字 –&gt;</em></li><li>&lt;plugins&gt;</li><li>&lt;plugin&gt;</li><li>&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</li><li>&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</li><li>&lt;version&gt;2.1.5.RELEASE&lt;&#x2F;version&gt;</li><li></li><li>&lt;executions&gt;</li><li>&lt;execution&gt;</li><li>&lt;phase&gt;package&lt;&#x2F;phase&gt;</li><li>&lt;goals&gt;</li><li>&lt;goal&gt;repackage&lt;&#x2F;goal&gt;</li><li>&lt;&#x2F;goals&gt;</li><li>&lt;&#x2F;execution&gt;</li><li>&lt;&#x2F;executions&gt;</li><li>&lt;configuration&gt;</li><li>&lt;includeSystemScope&gt;true&lt;&#x2F;includeSystemScope&gt;</li><li>&lt;mainClass&gt;ProviderApplication&lt;&#x2F;mainClass&gt;</li><li>&lt;&#x2F;configuration&gt;</li><li>&lt;&#x2F;plugin&gt;</li><li>&lt;&#x2F;plugins&gt;</li><li>&lt;&#x2F;build&gt;</li></ol><p>然后使用install最终成功</p><h3 id="4-3-provider打包好的镜像的docker的容器自动退出"><a href="#4-3-provider打包好的镜像的docker的容器自动退出" class="headerlink" title="4.3.provider打包好的镜像的docker的容器自动退出"></a>4.3.provider打包好的镜像的docker的容器自动退出</h3><p><strong>原理：</strong></p><p>因为docker中一旦把镜像中的执行完一遍之后就会自动停止，所以容器则会显示退出或者结束</p><p><strong>解决方案：</strong></p><p>修改provider和consumer的启动类代码，加入一段死循环代码防止自动完成</p><p>图2.8修改的代码</p><h3 id="4-4-docker每次都需要进入虚拟机进行打包镜像，有点麻烦，当虚拟机无法连接到时候，无法进行工作"><a href="#4-4-docker每次都需要进入虚拟机进行打包镜像，有点麻烦，当虚拟机无法连接到时候，无法进行工作" class="headerlink" title="4.4.docker每次都需要进入虚拟机进行打包镜像，有点麻烦，当虚拟机无法连接到时候，无法进行工作"></a>4.4.docker每次都需要进入虚拟机进行打包镜像，有点麻烦，当虚拟机无法连接到时候，无法进行工作</h3><p>自己的虚拟机在中期突然发生NAT模式无法访问到网络，同时也无法被SSH连接，于是我的虚拟机打包docker镜像的方法失效</p><p><strong>解决方案：</strong></p><p>安装docker desktop，使用win版的docker</p><p>并且利用IDEA集成docker的功能直接在IDEA完成docker镜像的打包以及上传</p><p>图2.9windows的docker集成</p><h2 id="5-如何在后续查看provider的ip"><a href="#5-如何在后续查看provider的ip" class="headerlink" title="5.如何在后续查看provider的ip"></a>5.如何在后续查看provider的ip</h2><p><strong>解决方案：</strong></p><p>修改provider和consumer的代码</p><p>核心修改处：</p><ol><li>public class UserServiceImpl implements UserService {</li><li></li><li>public User getUser(Long id) {</li><li>InetAddress addr &#x3D; null;</li><li>String add &#x3D;”404”;</li><li>try {</li><li>addr &#x3D; InetAddress.getLocalHost();</li><li>add &#x3D; addr.getHostAddress();</li><li>} catch (UnknownHostException e) {</li><li>e.printStackTrace();</li><li>}</li><li>System.out.println(“add &#x3D; “ + add);</li><li>return new User(id, “当前ip” + add);</li><li>}</li><li>}</li></ol><h2 id="6-端口问题"><a href="#6-端口问题" class="headerlink" title="6.端口问题"></a>6.端口问题</h2><p>由于我在服务器中已经部署jenkins启动了8080端口</p><p><strong>解决方法：</strong>所以我将provider等端口都避开8080端口</p><h1 id="对整门实验课程有何意见或建议。"><a href="#对整门实验课程有何意见或建议。" class="headerlink" title="对整门实验课程有何意见或建议。"></a>对整门实验课程有何意见或建议。</h1><h2 id="四个实验的设计以及对应的实验指导书的建议"><a href="#四个实验的设计以及对应的实验指导书的建议" class="headerlink" title="四个实验的设计以及对应的实验指导书的建议"></a>四个实验的设计以及对应的实验指导书的建议</h2><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><ul><li>lab1中部分的原理和机制，比如说Apache CXF</li></ul><p>因为时间问题可能有些无法适应现在的情况，并且在以后的工作中可能也使用和接触的机会较少。</p><p>而且lab1完成之后，对于tomcat的机制或者说如何去使用tomcat，其实整个流程下来收获并不是很大。</p><p>我认为比如说lab1换成学习和利用tomcat去发布一个helloworld的war包可能会比较合适，能够让同学们接触到tomcat的一些机制及原理。</p><p>以及lab1中的spring+tomcat内容也可以换成springboot，因为现在的大类招生以及通识化教育，软工专业的同学没有很好的JavaWeb基础，在经过lab1之后也未必能了解到spring的内容。我认为如果改为让同学们自行新建一个springboot项目，实现最基础的hello_world或简单的增删改查，收获可能会更大一些。毕竟springboot算比spring更主流，并且更适合入门，尽管科班应该系统性地学习spring，但是可能光凭一次实验或者理论讲解可能有所欠缺</p><ul><li>lab2与lab4内容如果可以的话，我认为可以不用限定dubbo的版本</li></ul><p>lab2指导书提供的是老版的dubbo，安装老版的dubbo以及一些配置是比较繁琐且实际性价比个人感觉较低。或许可以换成让同学们自行参考github中的官网教程来安装dubbo，这样既可以跟上新版本进行接轨，并且还能锻炼从官网自学安装配置的能力</p><h3 id="实验指导书"><a href="#实验指导书" class="headerlink" title="实验指导书"></a>实验指导书</h3><p>lab1，lab2的实验指导书已经有不少因为版本过时问题导致配置出错，实验指导书我认为已经可以定期更新一下，因为很多时候刚入门的同学可能遇上这些问题会花费很多时间去纠结这样一些小问题。</p><p>我在想，能不能鼓励每一届同学们根据自己实验后的经验对指导书留下一些修改建议，然后再由助教老师们收集整理，然后根据这些改动去修改实验指导书，这样就能很方便地一届一届不断更新指导书，也以便于下一届同学收到改进后的实验书。</p><h2 id="前置知识的问题"><a href="#前置知识的问题" class="headerlink" title="前置知识的问题"></a>前置知识的问题</h2><p>因为20届属于大类招生，大一大二对于软工专业课个人感觉太少了，从自己的感受上来看，无论是之前的软件构造还是现在的面向服务的软件系统，如果自己在上课之前没有做过项目或者没有一些基础的Java项目知识springboot等知识，就不能切身体会到一些重点.就个人感受，在自己学习过前后端内容和java之后，写过一些代码之后，再去回看教过的知识，才会发现受益匪浅，而自己在没有学习之前，总是无法理解含义。</p><p>比如说本课程在介绍面向服务的架构，淘宝技术的演进这一节课的内容中，结合了自己从JavaWeb，JDBC一直到springcloud的知识感受很深，觉得理清了自己之前学习的思路，相当于对以前学过的知识做了一次彻底总结。但是如果自己之前从来没有接触过这些知识，也许会一头雾水。</p><p>因此，我希望能够多加入一些前置知识的内容教学，比如说快速上手springboot，springcloud之类的。除了大作业和实验之外，适当的加入一些代码作业任务也是可以的我感觉。</p>]]></content>
    
    
    <categories>
      
      <category>面向服务的软件系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向服务的软件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向服务的软件系统实验一</title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%B8%80%E6%8A%A5%E5%91%8A/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%B8%80%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<p><strong>《面向服务的软件系统》实验报告</strong></p><p><strong>——实验一：服务构件&#x2F;服务系统的设计与实现</strong></p><p>姓名： 石卓凡 学号： 120L021011</p><ul><li>实验1 基于Apache CXF框架的服务开发环境搭建</li></ul><ol><li>项目中的pom.xml中的dependencies是什么？有什么作用？</li></ol><p><strong>是什么</strong></p><p>Pom.xml是项目对象模型，属于Maven项目中的文件，使用xml表示，可以用于管理源代码，配置文件，开发者信息，项目的依赖关系等</p><p>Pom.xml的其中dependencies内部的元素都是项目中需要被引进的依赖，被maven管理，即通过&lt;dependencies&gt;可以给出Maven项目所依赖的第三方类库。而dependencies里面有若干个&lt;dependency&gt;，而dependency标签有含有多个属性比如：</p><p>groupId：公司或者组织的唯一标志，并且配置时生成的路径也是由此生成，</p><p>artifactId本项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的</p><p>type，打包类型，默认jar</p><p>scope，被依赖的Maven构件在classpath中的可访问范围</p><p>optional，当前Maven项目的构件被其他项目依赖，此处被依赖的Maven构件相对于其他项目来说是不必须的</p><p>exclusions，将一个被依赖的Maven构件中的部分类库，从classpath中去掉</p><p>给出一个简单实例:</p><p>&lt;project&gt;</p><p>…</p><p>&lt;dependencies&gt;</p><p>&lt;dependency&gt;</p><p>&lt;!–组织ID–&gt;</p><p>&lt;groupId&gt;&lt;&#x2F;groupId&gt;</p><p>&lt;!–项目ID–&gt;</p><p>&lt;artifactId&gt;&lt;&#x2F;artifactId&gt;</p><p>&lt;!–版本号–&gt;</p><p>&lt;version&gt;&lt;&#x2F;version&gt;</p><p>&lt;!–依赖类型–&gt;</p><p>&lt;type&gt;&lt;&#x2F;type&gt;</p><p>&lt;!–类别（类目）–&gt;</p><p>&lt;classifier&gt;&lt;&#x2F;classifier&gt;</p><p>&lt;!–指定依赖的范围–&gt;</p><p>&lt;scope&gt;&lt;&#x2F;scope&gt;</p><p>&lt;!–指定本地jar路径，和scope一起使用–&gt;</p><p>&lt;systemPath&gt;&lt;&#x2F;systemPath&gt;</p><p>&lt;!–排除依赖列表–&gt;</p><p>&lt;exclusions&gt;</p><p>&lt;exclusion&gt;</p><p>&lt;artifactId&gt;&lt;&#x2F;artifactId&gt;</p><p>&lt;groupId&gt;&lt;&#x2F;groupId&gt;</p><p>&lt;&#x2F;exclusion&gt;</p><p>&lt;&#x2F;exclusions&gt;</p><p>&lt;!–指定是否需要被依赖–&gt;</p><p>&lt;optional&gt;&lt;&#x2F;optional&gt;</p><p>&lt;&#x2F;dependency&gt;</p><p>&lt;&#x2F;dependencies&gt;</p><p>…</p><p>&lt;&#x2F;project&gt;</p><p><strong>作用：</strong></p><p>通过dependecies管理项目对第三方包的依赖，利用元素可以将包的依赖下载到本地仓库并以此给项目进行使用，让项目得到构建和部署</p><p>比如：</p><p>&lt;**dependency**&gt;<br> &lt;**groupId**&gt;com.baomidou&lt;&#x2F;**groupId**&gt;<br> &lt;**artifactId**&gt;mybatis-plus-boot-starter&lt;&#x2F;**artifactId**&gt;<br> &lt;**version**&gt;3.5.2&lt;&#x2F;**version**&gt;<br>&lt;&#x2F;**dependency**&gt;</p><p>会让maven自动去下载mybatis-plus-boot-starter的依赖，其中版本要求为3.5.2，下载之后会自动管理和使用。项目中原本对于mybatis-plus-boot-starter爆红的地方就会解决，变为正常</p><ol><li>服务接口中方法参数中@webparam注解用与不用的实验结果是否会有变化？</li></ol><p><strong>@webparam是什么</strong></p><p>WebParam是webservice里面的注解，表示方法的参数名指定为一个名称</p><p>如果不使用@WebParam的注解，则方法参数的name默认为arg0,arg1,arg2……</p><p>而返回值的name默认为return</p><p>比如：</p><p>&lt; xs:element minOccurs&#x3D;”0” name&#x3D;”arg0” &#x2F;&gt;</p><p>&lt; xs:element minOccurs&#x3D;”0” name&#x3D;”return” &#x2F;&gt;</p><p>如果使用了@WebParam的注解比如@WebParam(name&#x3D;”password”)后，在wsdl中看到的参数名称就成为了password</p><p>比如：</p><p>&lt; xs:element minOccurs&#x3D;”0” name&#x3D;”password” &#x2F;&gt;</p><p><strong>变化：</strong></p><p><strong>1控制台返回结果一致</strong></p><p>加入WebParam注解和不加入WebParam注解均成功运行</p><p>且二者控制台返回结果一致</p><ol><li><strong>wsdl文档中结果不一致</strong></li></ol><p><em>（1）public Reader getReader(String name, String password)</em></p><p>当不加入注解时候可以发现，getReader方法中的参数名叫做arg0,arg1没有实际意义，仅表示参数顺序</p><p><em>（2）</em><strong>public</strong> Reader getReader(@WebParam(name&#x3D;<strong>“name”</strong>) String name, @WebParam(name &#x3D; <strong>“password”</strong>) String password)</p><p>当加入注解时候可以发现，getReader方法中的参数名叫做name,password,为对应的@WebParam中给定的参数名称</p><ol><li>方法实现中@webservice注解中的参数endpointInterface和serviceName分别代表了什么？</li></ol><p>@WebService(endpointInterface &#x3D; <strong>“main.IReaderService”</strong>,serviceName &#x3D; <strong>“readerService”</strong>)</p><p>@WebService注解：作用于具体类，可以通过这个注解利用endpoint发布一个web服务</p><p><strong>endpointInterface：</strong></p><p>用于指定服务的接口类的路径，指定做SEI服务端口接口，如果指定了此限定名，那么会使用该服务端点接口来确定抽象 WSDL 约定</p><p>在Lab1中的endpointInterface &#x3D; <strong>“main.IReaderService”</strong></p><p>“main.IReaderService”代表了指定服务接口是main文件夹下面的IReaderService接口，路径为main.IReaderService</p><p><strong>serviceName：</strong></p><p>指定对外发布的服务名。默认值值为 Java 类的简单名称+Service。</p><p>在Lab1中serviceName &#x3D; <strong>“readerService”</strong></p><p>wsdl对应的显示如下：</p><ul><li>实验2 基于SpringBoot框架的服务开发环境搭建</li></ul><ol><li>注解@RequestParam和@PathVariable分别表示什么？</li></ol><p><strong>@RequestParam：</strong></p><p><strong>作用：</strong></p><p>请求中的指定名称的参数传递给控制器中的形参赋值，接收的参数是请求url的QueryString(HTTP协议中的Request参数)中(不同于@Requestbody接收请求体中的参数）</p><p>举例子：</p><p><a href="http://localhost:8080/user?id=1">http://localhost:8080/user?id=1</a></p><p>对应代码</p><p>@GetMapping(“&#x2F;user”)</p><p>public String testRequestParam(@RequestParam Integer id) {</p><p>System.out.println(“获取到的id为：” + id);</p><p>return “success”;</p><p>}</p><p><strong>语法：</strong></p><p>@RequestParam(value&#x3D;”参数名”,required&#x3D;”true&#x2F;false”,defaultValue&#x3D;””)</p><p>value：参数名</p><p>required：默认为true，表示该请求路径中是否必须包含这个参数</p><p>开启了true之后，如果 value 属性值没有对应上jsp中 name 值则会直接报400错误</p><p>defaultValue：默认参数值，如果没有传该参数，就使用默认值</p><p>举例子：</p><p>(@RequestParam(value&#x3D;”password”,required&#x3D;true,defaultValue&#x3D;”123456”)</p><p><strong>@PathVariable：</strong></p><p><strong>作用：</strong></p><p>接收到参数是来自url变量，获取 url 参数</p><p>可以将URL中占位符参数{x}绑定到处理器类的方法形参中@PathVariable(“x“)</p><p>举例子localhost:8080&#x2F;user&#x2F;1</p><p>@GetMapping(“&#x2F;user&#x2F;{id}”)</p><p>public String testRequestParam(@PathVariable Integer id) {</p><p>System.out.println(“获取到的id为：” + id);</p><p>return “success”;</p><p>}</p><p><strong>语法：</strong>@PathVariable(value&#x3D;”参数名”,required&#x3D;”true&#x2F;false”,name&#x3D;””)</p><p>name-别名名称</p><p>Value要绑定的路径变量名称</p><p>required-指示路径变量是否为必需</p><p><strong>Lab1中：</strong></p><p><strong>原代码为：</strong></p><p>@RequestMapping(value &#x3D; <strong>“&#x2F;hallo&#x2F;{id}”</strong>,method &#x3D; RequestMethod.<strong>GET</strong>)<br><strong>public</strong> TestEntity say1(@RequestParam(value &#x3D; <strong>“qid”</strong>,required &#x3D; <strong>true</strong>) String qid, @PathVariable(<strong>“id”</strong>) String id){<br> <strong>return new</strong> TestEntity(qid, id);<br>}</p><p>@RequestParam接收pid</p><p>@PathVariable接收id</p><p>访问路径<a href="http://localhost:8080/hallo/1?pid=2">http://localhost:8080/hallo/1?pid=2</a></p><p>但是这里的@RequestParam与@PathVariable同时使用，无法读取到@RequestParam想要解释的pid，于是会报400错误，提示pid未接收到</p><p>将qid设定为非必须且给定默认值为1则解决问题可以运行</p><p>@RequestMapping(value &#x3D; <strong>“&#x2F;hallo&#x2F;{id}”</strong>,method &#x3D; RequestMethod.<strong>GET</strong>)<br><strong>public</strong> TestEntity say1(@PathVariable(<strong>“id”</strong>) String id,@RequestParam(value &#x3D; <strong>“qid”</strong>,required &#x3D; <strong>false</strong>) String qid){<br> System.<strong>out</strong>.println(<strong>“qid &#x3D; “</strong> + qid);<br> <strong>return new</strong> TestEntity(<strong>“1”</strong>,id);<br>}</p><ol><li>用以下URL：<a href="http://localhost:8080/hallo/2%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%AE%9E%E9%AA%8C%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%BC%9A%E5%BE%97%E5%88%B0%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%9C%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E9%87%8A%E8%AF%A5%E7%BB%93%E6%9E%9C%EF%BC%9F">http://localhost:8080/hallo/2访问本实验的服务会得到什么结果？如何解释该结果？</a></li></ol><p><strong>结果：</strong></p><p>得到400报错</p><p><strong>原因：</strong></p><p>同上一问，源代码中@RequestParam(value &#x3D; “qid”,required &#x3D; true)要求提供qid的HTTP请求参数，但是未提供，因此报错</p><p><strong>解决方案：</strong></p><p>在去掉@RequestParam之后</p><p>将pid默认”1”</p><p>可以正常显示（测试改端口8888，对结论无影响）</p><ul><li>结合本次实验感受，试分析基于服务的软件系统与你以往做过的软件有何区别？可以从软件结构、开发过程、调试方法等方面阐述。</li></ul><p>区别：</p><p>（1）之前学习和使用的是面向对象和面向接口，如今是面向服务service，用面向服务的方法去管理服务之间的发生的事情。</p><p>直观上来说，之前做的程序，要实现投票系统，关注的是投票人对象，匿名票对象以及对象之间的关系和互相调用互动</p><p>现在面向服务的软件系统，比如如果要实现springboot的web网页，需要划分为entity,mapper,service,controller基本四层，其中要根据业务需求重点考虑好service服务的设计，然后是controller控制层</p><ol><li>之前使用的是基础JAVA语法，如今要启动框架，站在前人的肩膀上来看世界，比如直接使用springboot和springcloud框架，需要了解各自框架的如何使用，其中有哪些注解，框架的格式，框架的配置文件内容等等</li><li>基于服务的软件系统在制作软件的过程中，设计时还需要考虑更加全面的方面，比如说如果使用SOA的体系结构，就要考虑松散耦合，粗粒度服务，标准化接口，在设计uml时候也需要考虑将服务使用者和服务提供者在服务实现和客户如何使用服务方面隔离开来</li><li>对于微服务的知识点，也让我认识到了区别所在，之后需要关注的内容还得关注于高并发问题集群问题，比如之后用springboot写出了一个软件，可以用springcloud变成高性能分布式，还可以用docker打包镜像然后k8s部署到多台云服务器，以此来解决高并发问题。以前设计的软件用户量太小不需要考虑</li></ol>]]></content>
    
    
    <categories>
      
      <category>面向服务的软件系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向服务的软件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E5%90%91%E8%AE%BA%E6%96%87%E4%BD%9C%E8%80%85%E8%A6%81%E4%BB%A3%E7%A0%81/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E5%90%91%E8%AE%BA%E6%96%87%E4%BD%9C%E8%80%85%E8%A6%81%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>Dear Mr.&#x2F;Mrs.: 作者名</p><p>I am a graduate student of 大学名 in China. I major in 专业名. Recently, I found one of your articles, titled 文章名 in 杂志名. I found it may help me achieve my goals in this research field. This would make a really positive contribution to my work.<br>I am wondering if you could kindly send me the source program and the necessary information about it. I promise they will be used only for research purposed.<br>Thank you very much for your kind consideration and I am looking forward to your early reply.</p><p>Sincerely: 你的名字<br>My Email address is:email</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%89%93%E5%8D%B0%E7%9B%AE%E5%BD%95/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E6%89%93%E5%8D%B0%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="第二章开发技术"><a href="#第二章开发技术" class="headerlink" title="第二章开发技术"></a>第二章开发技术</h1><h2 id="1-面向服务开发基础"><a href="#1-面向服务开发基础" class="headerlink" title="1. 面向服务开发基础"></a><strong>1.</strong> <strong>面向服务开发基础</strong></h2><p><strong>1.1 Web</strong>开发基础</p><p>Web系统体系结构 2</p><p>Web容器 3</p><p>1.2 Web开发技术演进</p><p>​HTTP</p><p>​CGI</p><p>​模板引擎</p><p>​JAVAEE</p><p><strong>1.3 Spring Boot</strong>  13</p><h2 id="2-RPC"><a href="#2-RPC" class="headerlink" title="2. RPC"></a><strong>2.</strong> <strong>RPC</strong></h2><p><strong>1.RPC是什么</strong></p><p>​RPC是什么 3</p><p>​RPC分类 4-7</p><p><strong>2.RPC的发展</strong></p><p><strong>3.XML-RPC</strong></p><p><strong>4.JSON-RPC</strong></p><h2 id="3-Web-Service（WSDL、SOAP、UDDI）"><a href="#3-Web-Service（WSDL、SOAP、UDDI）" class="headerlink" title="3. Web Service（WSDL、SOAP、UDDI）"></a><strong>3.</strong> <strong>Web Service</strong>（<strong>WSDL</strong>、<strong>SOAP</strong>、<strong>UDDI</strong>）</h2><p><strong>1.</strong> <strong>什么是WebService</strong> 3</p><p>​WebServicee体系结构 4</p><p>​WebService三种基本元素 7</p><p><strong>2.</strong> <strong>WebService与RPC</strong></p><p><strong>3.</strong> <strong>WSDL</strong></p><p><strong>4.</strong> <strong>UDDI</strong></p><p><strong>5.</strong> <strong>SOAP</strong></p><p><strong>6.</strong> <strong>举例</strong></p><h2 id="4-RESTful-Web-Service"><a href="#4-RESTful-Web-Service" class="headerlink" title="4. RESTful Web Service"></a><strong>4.</strong> <strong>RESTful Web Service</strong></h2><h1 id="第三章SOA"><a href="#第三章SOA" class="headerlink" title="第三章SOA"></a>第三章SOA</h1><h2 id="SOA的基本概念"><a href="#SOA的基本概念" class="headerlink" title="SOA的基本概念"></a>SOA的基本概念</h2><p>SOA解决问题 4</p><p>SOA特性 7</p><p>SOA服务设计原则 9</p><h2 id="SOMA开发方法"><a href="#SOMA开发方法" class="headerlink" title="SOMA开发方法"></a>SOMA开发方法</h2><p>敏捷开发 23</p><p>服务外包和众包 28</p><h2 id="ESB原理与机制"><a href="#ESB原理与机制" class="headerlink" title="ESB原理与机制"></a>ESB原理与机制</h2><p>ESB概念 37</p><p>ESB功能 42</p><p>ESB关键技术 47</p><p>ESB优势 50</p><h2 id="服务组合与BPEL"><a href="#服务组合与BPEL" class="headerlink" title="服务组合与BPEL"></a>服务组合与BPEL</h2><p>服务编制与编排 53</p><p>通过BPEL实现服务组合（编制与编排） 56</p><h3 id="BPEL待学"><a href="#BPEL待学" class="headerlink" title="BPEL待学"></a>BPEL待学</h3><h2 id="Web2-0与Web3-0"><a href="#Web2-0与Web3-0" class="headerlink" title="Web2.0与Web3.0"></a>Web2.0与Web3.0</h2><p>Web2.0 主要技术 95</p><p>Web 3.0 102</p><h2 id="服务Mashup"><a href="#服务Mashup" class="headerlink" title="服务Mashup"></a>服务Mashup</h2><p>Mashup实现技术 107</p><h1 id="第四章分布式"><a href="#第四章分布式" class="headerlink" title="第四章分布式"></a>第四章分布式</h1><h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><p>分布式技术演进 2</p><p>dubbo框架图 10</p><p>springcloud框架图 11</p><p>分布式服务框架特性 13</p><p>分布式服务性能特性 16</p><h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><p>znode树 24</p><p>znode 操作指令，操作原语 29</p><p>zookeeper 的 server-client 31</p><p>zookeeper 的Leader-Follower 32</p><p>Leader功能 33</p><p>Leader 选举 34</p><p>Follower 36</p><p>zookeeper的消息同步watcher 37</p><p>zookeeper的服务注册 43</p><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p>dubbo解决的问题 49</p><p>dubbo 架构图 50</p><p>dubbo 提供者和消费者调用关系 51</p><p>dubbo 特性 52</p><p><strong>Dubbo</strong>与Spring Cloud 53</p><p>dubbo总体架构10层设计图 54</p><p>dubbo的伸缩和扩展 57</p><p>spring的 IOC控制反转 60</p><p>控制反转好处 62</p><p>使用dubbo 的spring xml配置 66</p><h2 id="Netty-76-有资料打印"><a href="#Netty-76-有资料打印" class="headerlink" title="Netty 76   -有资料打印"></a>Netty 76   -有资料打印</h2><p>对比Java NIO, Netty的性能优势 81</p><p>阻塞IO 82</p><p>线程管理的selector的io复用 83</p><p>Netty的io复用 84</p><p>事件处理模型 85</p><p>Reactor 线程模型 86</p><p>Reactors多线程模型88</p><p>Netty主要模块组件89</p><p>Netty工作流程 90</p><p>Netty的性能 94</p><h1 id="第五章微服务"><a href="#第五章微服务" class="headerlink" title="第五章微服务"></a>第五章微服务</h1><h2 id="微服务理论"><a href="#微服务理论" class="headerlink" title="微服务理论"></a>微服务理论</h2><p>为什么要微服务 1</p><p>什么是微服务 4</p><p>微服务需要做到哪些 6</p><p>微服务的复杂来源于哪 8</p><p>微服务与SOA 12</p><p>​SOA关注点</p><p>​微服务关注点</p><p>微服务设计原则 16</p><h2 id="微服务消息机制"><a href="#微服务消息机制" class="headerlink" title="微服务消息机制"></a>微服务消息机制</h2><p>微服务的消息代理 26</p><p>同步消息与异步消息 27 28</p><p>消息中间件 29</p><p>服务定义接口31</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Http Server 33</p><p>Application Server 34</p><p>Soap Engine 35</p><p>什么是LXC 39</p><p>docker和OS对比 40</p><p>docker 特点 43</p><p>docker对比虚拟机存在的缺点 45</p><p>docker引擎 46</p><p>docker架构 47</p><p>docker镜像 48</p><p>docker仓库 50</p><p>docker容器 52</p><h2 id="Docker调度工具"><a href="#Docker调度工具" class="headerlink" title="Docker调度工具"></a>Docker调度工具</h2><p>为什么要调度工具 56</p><p>主流调度工具 57</p><p>k8s 58</p><p>k8s基本组成部分 60</p><p>k8s谓词 优先级 65</p><h2 id="devops"><a href="#devops" class="headerlink" title="devops"></a>devops</h2><p>devops定义 72</p><p>devops 六大原则 73</p><p>CICD 74</p><p>持续集成的最佳实践 76</p><p>持续交付流程 78</p><p>jenkins 81</p><h1 id="第六章服务质量"><a href="#第六章服务质量" class="headerlink" title="第六章服务质量"></a>第六章服务质量</h1><p>什么是服务质量 2</p><p>服务质量的两个方面，四大特征 4</p><p>商务服务质量维度 5</p><p>IT服务系统中的质量评价指标 7</p><p>5GAP服务质量差距 11</p><p>服务等级协议SLA 13</p><p>5个Gap出现的原因15</p><p>服务系统设计要经历的阶段 15</p><p>如何消除Gap 15</p><h1 id="打印网页资料目录"><a href="#打印网页资料目录" class="headerlink" title="打印网页资料目录"></a>打印网页资料目录</h1><p>Bpel</p><p>docker架构设计</p><p>dubbo简介</p><p>SOA和微服务区别</p><p>SOA架构和微服务架构区别</p><p>springcloud和dubbo区别</p><p>Web服务器，Http服务器，应用程序服务器，区别</p><p>zookeeper的watcher</p><p>zookeeper的选举算法</p><p>Netty</p><p>Netty工作流程</p><p>服务编制和编排</p><p>什么是SOA</p><p>什么是负载均衡</p><p>微服务组织架构</p><p>SLA</p><h1 id="实验报告目录"><a href="#实验报告目录" class="headerlink" title="实验报告目录"></a>实验报告目录</h1><h2 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h2><p>1、 项目中的pom.xml中的dependencies是什么？有什么作用？</p><p>1、 服务接口中方法参数中@webparam注解用与不用的实验结果是否会有变化？</p><p>1、 方法实现中@webservice注解中的参数endpointInterface和serviceName分别代表了什么？</p><p>1、 注解@RequestParam和@PathVariable分别表示什么？</p><p>1、 用以下URL：<a href="http://localhost:8080/hallo/2%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%AE%9E%E9%AA%8C%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%BC%9A%E5%BE%97%E5%88%B0%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%9C%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E9%87%8A%E8%AF%A5%E7%BB%93%E6%9E%9C%EF%BC%9F">http://localhost:8080/hallo/2访问本实验的服务会得到什么结果？如何解释该结果？</a></p><p>Ø 结合本次实验感受，试分析基于服务的软件系统与你以往做过的软件有何区别？可以从软件结构、开发过程、调试方法等方面阐述。</p><h2 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h2><p>1、 Dubbo框架与Zookeeper框架之间的关系是什么？如何将Zookeeper框架与Dubbo框架进行集成？</p><p>1、 Dubbo框架中的Dubbo-master的作用是什么？</p><p>1、 Dubbo框架下Service Provider发布服务的过程，及过程中的关键点。</p><p>1、 Dubbo框架下Service Consumer消费服务的过程，及过程中的关键点。</p><p>1、 详细描述你的服务的发布过程和被消费方式。</p><h2 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h2><p>1、 容器虚拟化和传统虚拟化的区别是什么？</p><p>1、 如何实现 Kubernetes 自动化部署？</p><p>1、 Kubernetes有哪些核心组件，其功能是什么？</p><p>1、 Kubernetes搭建过程中遇到的问题，与解决办法。</p><h2 id="实验4"><a href="#实验4" class="headerlink" title="实验4"></a>实验4</h2><p>1、 如果你要从头开发一个基于微服务架构的项目，项目中的服务最终要部署在k8s管理的镜像环境中，你认为应如何创建项目？与本次实验过程相比，哪些改进可以让开发更加合理高效？</p><p>1、 如何将实验中多个provider服务实例的负载均衡策略改为轮询调用？即在多次反复调用时轮流调用各个服务实例。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/</url>
    
    <content type="html"><![CDATA[<h1 id="计网考前一天2-17"><a href="#计网考前一天2-17" class="headerlink" title="计网考前一天2.17"></a>计网考前一天2.17</h1><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20230217170536396.png" alt="image-20230217170536396"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20230217171627539.png" alt="image-20230217171627539"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20230217171637664.png" alt="image-20230217171637664"></p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230212194406109.png" class title="image-20230212194406109"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230212194406109-16766259236602.png" class title="image-20230212194406109"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230217202153762.png" class title="image-20230217202153762"><p>2012年<img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218202159161.png" class title="image-20230218202159161"></p><p>1.看ip分组是否小于的是46而不是64</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218202151756.png" class title="image-20230218202151756"><p>看标识看出是哪个帧</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218202557336.png" class title="image-20230218202557336"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218202853230.png" class title="image-20230218202853230"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218203330057.png" class title="image-20230218203330057"><h2 id="计算问题"><a href="#计算问题" class="headerlink" title="计算问题"></a>计算问题<img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218204330934.png" class title="image-20230218204330934"></h2><p><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218204317260.png" alt="image-20230218204317260"><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218205332891.png" alt="image-20230218205332891"></p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218205505214.png" class title="image-20230218205505214"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218205600477.png" class title="image-20230218205600477"><p>此图中不是数据帧会挑最短路，而是因为求最少时间所以按照最短路计算</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218210810308.png" class title="image-20230218210810308"><p>有笔记</p><p><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218210911370.png" alt="image-20230218210911370"><img src="/shizhuofan.GitHub.io/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218210915026.png" alt="image-20230218210915026"></p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218211041117.png" class title="image-20230218211041117"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218211101690.png" class title="image-20230218211101690"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218211222027.png" class title="image-20230218211222027"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218211427367.png" class title="image-20230218211427367"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218212231716.png" class title="image-20230218212231716"><p>注意KB，拥塞控制阈值 名词</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218212401712.png" class title="image-20230218212401712"><p>（16,1) 拥塞窗口16KB，不影响发送窗口1KB</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218212506458.png" class title="image-20230218212506458"><p>DF是禁止分片，分片时候DF&#x3D;0</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218224418132.png" class title="image-20230218224418132"><p>Cable Modem接入是在混合光纤同轴电缆网（HFC）上实现的宽带接入技术</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218224637158.png" class title="image-20230218224637158"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218224640797.png" class title="image-20230218224640797"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218224711993.png" class title="image-20230218224711993"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230218225034673.png" class title="image-20230218225034673"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%BD%91%E8%80%83%E5%89%8D%E4%B8%80%E5%A4%A92.17/image-20230219105239488.png" class title="image-20230219105239488">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221118151242522.png" class title="image-20221118151242522"><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Users\86189\AppData\Roaming\Typora\typora-user-images\image-20221103101058752.png" alt="image-20221103101058752"></p><h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221110114745464.png" class title="image-20221110114745464"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112143013568.png" class title="image-20221112143013568"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112143024422.png" class title="image-20221112143024422"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112144126212.png" class title="image-20221112144126212"><p>CPI平均指令周期数</p><p>MIPS百万级指令每秒</p><p>CPU的CPI与时钟频率无关</p><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><p>定点数：</p><p>1.纯整数</p><p>2.纯小数</p><p>有符号数：</p><p>原码，不适合加法运算，发现[a+-b]原  ！&#x3D;[a]原+-[b]原</p><p><strong>1,001   &#x3D;&gt; -(1)</strong></p><p>反码</p><p>没有实际意义，只是过渡阶段</p><p>补码,补码适合加减法，发现[a+-b]补 &#x3D;[a]补+-[b]补<br>实际上补码减法也是通过换成加法来的</p><p><strong>1,001 &#x3D;&gt; (-8 + 1) &#x3D; -7</strong></p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112145719565.png" class title="image-20221112145719565"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112145925998.png" class title="image-20221112145925998"><p>.</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112145820440.png" class title="image-20221112145820440"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112144946911.png" class title="image-20221112144946911"><p>因为有2^8&#x3D;256</p><p><strong>原码有正负0，补码没有正负0</strong></p><p>但是+0（0,000 0000）和-0（1,000 0000）多了</p><p>所以256-1</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112150650696.png" class title="image-20221112150650696"><p><strong>移码</strong></p><p>从补码一一对应过来的，用于方便比较数字大小</p><p>补码+2^n &#x3D; 移码</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112150857283.png" class title="image-20221112150857283"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112151626897.png" class title="image-20221112151626897"><h2 id="逻辑移位算术移位"><a href="#逻辑移位算术移位" class="headerlink" title="逻辑移位算术移位"></a>逻辑移位算术移位</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112151956097.png" class title="image-20221112151956097"><p>算数左移不应该改变符号位，符号位不动</p><h2 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h2><p>现代计算机都是用补码加减法</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112204331145.png" class title="image-20221112204331145"><p>溢出的判断：</p><p>双符号位的意义：</p><p>10</p><p>真正的符号是1，本来的符号位是0</p><p>所以是负溢出</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112210601205.png" class title="image-20221112210601205"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221112210829284.png" class title="image-20221112210829284"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221117205251763.png" class title="image-20221117205251763"><h1 id="计算机讲座2"><a href="#计算机讲座2" class="headerlink" title="计算机讲座2"></a>计算机讲座2</h1><p>题目：</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221119102458280.png" class title="image-20221119102458280"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113095200788.png" class title="image-20221113095200788"><p><strong>特权指令：</strong></p><pre><code class="hljs">  1）允许和禁止中断，控制中断禁止屏蔽位  2）在进程间切换处理  3）存取用于主存保护的寄存器  4）执行I/O操作  5）停止一个中央处理器的工作  6）清理内存  7）设置时钟  8）建立存储键  9）加载PSW</code></pre><p><em><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113095339032.png" class title="image-20221113095339032"></em>*</p><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>这里采用特殊寻址方式则指令格式</p><p>操作码OP   寻址特征M   形式地址</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113104839891.png" class title="image-20221113104839891"><p>1.立即寻址</p><p>2直接寻址   间接寻址。。。。</p><p>间接寻址{</p><p>一次间接<img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113095817334.png" class title="image-20221113095817334"></p><p>多次间接<img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113095822807.png" class title="image-20221113095822807"></p><p>多次间接就需要1个标志位</p><p>}</p><p>基址寻址，BX用户不可修改</p><p>变址寻址，IX用户可修改</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113100100026.png" class title="image-20221113100100026"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113100455612.png" class title="image-20221113100455612"><p>相对寻址，是以下一条指令的PC为基准</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113100515317.png" class title="image-20221113100515317"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113101921513.png" class title="image-20221113101921513"><h2 id="指令格式设置"><a href="#指令格式设置" class="headerlink" title="指令格式设置"></a>指令格式设置</h2><p>想要端操作吗和长操作码同时存在于指令系统</p><p>则需要让短操作码不能是长操作码的前缀</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113104141360.png" class title="image-20221113104141360"><p>0000~1110是4位操作码</p><p>1111 0000 ~ 1111 1110是8位操作码</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113104439578.png" class title="image-20221113104439578"><p><strong>短操作码不断变成长操作码</strong></p><p><strong>每次增长必须是多占用一个操作数长度</strong></p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113105415872.png" class title="image-20221113105415872"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113105747167.png" class title="image-20221113105747167"><h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><p>唐书的和csapp不一样</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113105845591.png" class title="image-20221113105845591"><p>唐书说通过取指阶段从存储器取出指令</p><p>执行阶段从存储器取出数据</p><p>由于控制器的控制知道是啥阶段，所以控制器可以区分拿到指令还是数据</p><p>唐叔认为，CPU想要响应中断一定是等到上一条指令结束执行周期</p><p>且唐书认为PC++必须在取指阶段</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113110021261.png" class title="image-20221113110021261"><p><strong>指令周期</strong></p><p><strong>机器周期：比如取指周期</strong></p><p><strong>时钟周期；比如T0</strong></p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113111005703.png" class title="image-20221113111005703"><p>指令周期{</p><p> 机器周期1-取指周期：{</p><p>  时钟周期1-T0</p><p>  时钟周期2-T1</p><p>}</p><p>机器周期2-间址周期：</p><p>{</p><p>}</p><p>}</p><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113114819271.png" class title="image-20221113114819271"><h3 id="结构相关"><a href="#结构相关" class="headerlink" title="结构相关"></a>结构相关</h3><p>有两个想要同时使用访存主存（但只能同一时间允许最高一个）</p><p>暂停</p><p>指令和数据分开储存</p><h3 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h3><p>先写后读</p><p>旁路技术</p><h3 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h3><p>跳转所以会使得流水线不能按照原先预想的那样流水</p><p>所以流水线（一直按照PC+1流水的顺序）会错</p><p>暂停+分支预测</p><h3 id="流水线性能指标"><a href="#流水线性能指标" class="headerlink" title="流水线性能指标"></a>流水线性能指标</h3><p>直接做题理解</p><p>看天勤P222</p><h2 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h2><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221113155658907.png" class title="image-20221113155658907"><p>天勤206</p><h1 id="理解流程"><a href="#理解流程" class="headerlink" title="理解流程"></a>理解流程</h1><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221117210937166.png" class title="image-20221117210937166"><h1 id="速成"><a href="#速成" class="headerlink" title="速成"></a>速成</h1><p>P9</p><p>1.DMA是每传送完一个数据块就中断一次作为后处理，中断过程不包括穿字节</p><p>每一份数据块就有预处理数据传输后处理</p><p>​    程序中断是每次通过一次中断来传送一字节，中断过程包括穿字节包括数据传输</p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221118105218932.png" class title="image-20221118105218932"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221118105744561.png" class title="image-20221118105744561"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221118110058881.png" class title="image-20221118110058881"><p>首选位扩展</p><p>1KB&#x3D;1024B</p><h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221120172013370.png" class title="image-20221120172013370"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20221120195755215.png" class title="image-20221120195755215">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017193826030.png" alt="image-20221017193826030"></p><h2 id="面向连接服务"><a href="#面向连接服务" class="headerlink" title="面向连接服务"></a>面向连接服务</h2><p>​TCP，双方必须建立连接，传输结束之后释放连接和所占的资源</p><h2 id="无连接服务"><a href="#无连接服务" class="headerlink" title="无连接服务"></a>无连接服务</h2><p>  UDP，通信双方无需建立连接</p><h2 id="数据交换的类型"><a href="#数据交换的类型" class="headerlink" title="数据交换的类型"></a>数据交换的类型</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081447025.png" alt="image-20220826081447025"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081535366.png" alt="image-20220826081535366"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081542641.png" alt="image-20220826081542641"></p><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081606479.png" alt="image-20220826081606479"></p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081617033.png" alt="image-20220826081617033"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081635487.png" alt="image-20220826081635487"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081644959.png" alt="image-20220826081644959"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081717591.png" alt="image-20220826081717591"></p><p><img src="/shizhuofan.GitHub.io/image-20220826143348409.png" alt="image-20220826143348409"></p><p>1B&#x3D;8bit</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826143414579.png" alt="image-20220826143414579"></p><h2 id="速率bit-rate"><a href="#速率bit-rate" class="headerlink" title="速率bit rate"></a>速率bit rate</h2><p>1Kbit&#x3D;1000bit</p><p>1Mbit&#x3D;1000Kbit</p><p>Kbit&#x3D;Kb</p><p>1Mb&#x2F;s&#x3D;1000Kb&#x2F;s</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826081901619.png" alt="image-20220826081901619"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826082118131.png" alt="image-20220826082118131"></p><h2 id="时延："><a href="#时延：" class="headerlink" title="时延："></a>时延：</h2><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826083135963.png">数据从网络的一段出纳送到另一端所需要的总时间叫做时延，分为四部分，传输时延，传播时延，处理时延，排队时延</p><h3 id="分组延迟"><a href="#分组延迟" class="headerlink" title="分组延迟"></a>分组延迟</h3><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826082615781.png" alt="image-20220826082615781"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826083348973.png" alt="image-20220826083348973"></p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>可以看作把这条链路塞满bit，一共最多可以容纳多少bit</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826083757680.png" alt="image-20220826083757680"></p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826084127896.png" alt="image-20220826084127896"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826084323159.png" alt="image-20220826084323159"></p><h2 id="五层因特网协议"><a href="#五层因特网协议" class="headerlink" title="五层因特网协议"></a>五层因特网协议</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>​运输层给应用程序不同端口（进程）之间传输应用层报文</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><h1 id="第二章应用层"><a href="#第二章应用层" class="headerlink" title="第二章应用层"></a>第二章应用层</h1><h2 id="网络应用程序体系结构："><a href="#网络应用程序体系结构：" class="headerlink" title="网络应用程序体系结构："></a>网络应用程序体系结构：</h2><h3 id="CS客户服务器体系结构"><a href="#CS客户服务器体系结构" class="headerlink" title="CS客户服务器体系结构"></a>CS客户服务器体系结构</h3><p>Web浏览器网站</p><h3 id="P2P体系结构"><a href="#P2P体系结构" class="headerlink" title="P2P体系结构"></a>P2P体系结构</h3><p>文件共享，文件传输，网络电话</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220826150509882.png" alt="image-20220826150509882"></p><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>不同系统之间互相通信的是进程（运行中的程序）</p><p>​通过交换报文而互相通信</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829164144803.png" alt="image-20220829164144803"></p><h3 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h3><p>​通过IP地址找到对应主机</p><p>​通过端口找到对应进程对应目的</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829165014641.png" alt="image-20220829165014641"></p><h2 id="因特网的运输层协议（TCP和UDP）"><a href="#因特网的运输层协议（TCP和UDP）" class="headerlink" title="因特网的运输层协议（TCP和UDP）"></a>因特网的运输层协议（TCP和UDP）</h2><p>发送端的应用程序通过套接字socket发送报文，然后通过运输层协议（tcp&#x2F;tdp)使得报文进入到接收进程的套接字</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829165627560.png" alt="image-20220829165627560"></p><h3 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h3><h2 id="Web应用层协议：HTTP（超文本传输协议）"><a href="#Web应用层协议：HTTP（超文本传输协议）" class="headerlink" title="Web应用层协议：HTTP（超文本传输协议）"></a>Web应用层协议：HTTP（超文本传输协议）</h2><p>HTTP是一个无状态协议，并不会保存客户信息</p><p>HTTP会建立TCP链接：客户进程-TCP-服务器进程</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829193401814.png" alt="image-20220829193401814"></p><h3 id="HTTP的非持续连接和持续连接"><a href="#HTTP的非持续连接和持续连接" class="headerlink" title="HTTP的非持续连接和持续连接"></a>HTTP的非持续连接和持续连接</h3><h4 id="非持久性"><a href="#非持久性" class="headerlink" title="非持久性"></a>非持久性</h4><p>往返时间RTT</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829193910675.png" alt="image-20220829193910675"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829193621621.png" alt="image-20220829193621621"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829193710523.png" alt="image-20220829193710523"></p><h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829143954709.png" alt="image-20220829143954709"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829144057512.png" alt="image-20220829144057512"></p><h2 id="上传输入的方法：Get，Post"><a href="#上传输入的方法：Get，Post" class="headerlink" title="上传输入的方法：Get，Post"></a>上传输入的方法：Get，Post</h2><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829145719797.png" alt="image-20220829145719797"></p><p>GET利用的request的URL，请求体为空</p><p>POST利用请求体</p><h2 id="响应消息："><a href="#响应消息：" class="headerlink" title="响应消息："></a>响应消息：</h2><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829150006488.png" alt="image-20220829150006488"></p><h2 id="cookie技术"><a href="#cookie技术" class="headerlink" title="cookie技术"></a>cookie技术</h2><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829150630853.png" alt="image-20220829150630853"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829150657308.png" alt="image-20220829150657308"></p><p>session 是基于 cookie 实现的，session 存储在服务器端，sessionID 会被存储到客户端的 cookie 中</p><p>服务端执行session机制时候会生成 sessionID 值，这个ID值会发送给客户端，客户端每次请求都会把这个ID值放到HTTP请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用。</p><h3 id="Cookie和Session认证流程"><a href="#Cookie和Session认证流程" class="headerlink" title="Cookie和Session认证流程"></a>Cookie和Session认证流程</h3><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829151458917.png" alt="image-20220829151458917"></p><h3 id="Cookie和Session区别"><a href="#Cookie和Session区别" class="headerlink" title="Cookie和Session区别"></a>Cookie和Session区别</h3><p>Cookie（内含SessionID）存在客户端，Session存在服务器端</p><p>Cookie长时间保存，Session短时间保存</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829151533358.png" alt="image-20220829151533358"></p><h2 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">可以不需要访问服务器就可以满足HTTP请求拿到东西看见网页内容<br></code></pre></td></tr></table></figure><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829151724321.png" alt="image-20220829151724321"></p><h3 id="机制："><a href="#机制：" class="headerlink" title="机制："></a>机制：</h3><p>web缓存器也叫代理服务器技术</p><p>请求先查看代理服务器（缓存）中是否有需要的</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829152100903.png" alt="image-20220829152100903"></p><h3 id="通过条件性GET方法"><a href="#通过条件性GET方法" class="headerlink" title="通过条件性GET方法"></a>通过条件性GET方法</h3><p>来，使用缓存或者服务器之中的最新版本</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829162853400.png" alt="image-20220829162853400"></p><h2 id="Email应用"><a href="#Email应用" class="headerlink" title="Email应用"></a>Email应用</h2><h3 id="Email的应用构成"><a href="#Email的应用构成" class="headerlink" title="Email的应用构成"></a>Email的应用构成</h3><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829163437569.png" alt="image-20220829163437569"></p><p>HTTP：请求，响应</p><p>SMTP：命令，响应</p><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829194150337.png" alt="image-20220829194150337"></p><h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h3><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220829200901508.png" alt="image-20220829200901508"></p><h3 id="邮件访问协议："><a href="#邮件访问协议：" class="headerlink" title="邮件访问协议："></a>邮件访问协议：</h3><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830143957515.png" alt="image-20220830143957515"></p><h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><h4 id="IMAP3"><a href="#IMAP3" class="headerlink" title="IMAP3"></a>IMAP3</h4><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>识别主机需要主机名（cnn.com)或者IP地址</p><h3 id="DNS域名解析系统，"><a href="#DNS域名解析系统，" class="headerlink" title="DNS域名解析系统，"></a>DNS域名解析系统，</h3><p>1.可以用已知（好记又方便）主机名得到IP地址</p><p>2.主机别名</p><p>3.邮件服务器别名</p><p>4.负载均衡</p><h3 id="DNS服务器采用分布式"><a href="#DNS服务器采用分布式" class="headerlink" title="DNS服务器采用分布式"></a>DNS服务器采用分布式</h3><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830150841742.png" alt="image-20220830150841742"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830145423384.png" alt="image-20220830145423384"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830145920183.png" alt="image-20220830145920183"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830151052936.png" alt="image-20220830151052936"></p><h3 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h3><h4 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h4><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830151817618.png" alt="image-20220830151817618"></p><h4 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询<img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830151830814.png" alt="image-20220830151830814"></h4><h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220830152021284.png" alt="image-20220830152021284"></p><h1 id="第三章，应用层-下"><a href="#第三章，应用层-下" class="headerlink" title="第三章，应用层-下"></a>第三章，应用层-下</h1><h2 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h2><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904134251513.png" alt="image-20220904134251513"></p><h3 id="P2P应用1-文件分发："><a href="#P2P应用1-文件分发：" class="headerlink" title="P2P应用1-文件分发："></a>P2P应用1-文件分发：</h3><h4 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS<img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904134345111.png" alt="image-20220904134345111"></h4><p>最短完成时间，是等到同步开始的上传和下载都得完成</p><h4 id="P2P-1"><a href="#P2P-1" class="headerlink" title="P2P"></a>P2P</h4><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904134936557.png" alt="image-20220904134936557"></p><h4 id="对比图"><a href="#对比图" class="headerlink" title="对比图"></a>对比图</h4><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904134924526.png" alt="image-20220904134924526"></p><h3 id="文件分发具体例子："><a href="#文件分发具体例子：" class="headerlink" title="文件分发具体例子："></a>文件分发具体例子：</h3><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904135244821.png" alt="image-20220904135244821"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904135259784.png" alt="image-20220904135259784"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904135340832.png" alt="image-20220904135340832"></p><p>一边下载一边上传发送给别人</p><h3 id="P2P应用2-索引"><a href="#P2P应用2-索引" class="headerlink" title="P2P应用2-索引"></a>P2P应用2-索引</h3><h4 id="索引的作用"><a href="#索引的作用" class="headerlink" title="索引的作用"></a>索引的作用</h4><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904135806678.png" alt="image-20220904135806678"></p><p>集中式索引</p><p>洪泛式查询</p><p>层次式覆盖网络</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904135939292.png" alt="image-20220904135939292"></p><h2 id="套接字socket编程"><a href="#套接字socket编程" class="headerlink" title="套接字socket编程"></a>套接字socket编程</h2><ul><li>socket：应用层、传输层之间的。**&#x3D;&#x3D;属于传输层&#x3D;&#x3D;**</li><li>通信段点对外：IP+端口号</li><li>内对：套接字描述符</li></ul><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904140248033.png" alt="image-20220904140248033"></p><h3 id="套接字描述符："><a href="#套接字描述符：" class="headerlink" title="套接字描述符："></a>套接字描述符：</h3><p>创建套接字时候返回套接字描述符</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904140912573.png" alt="image-20220904140912573"></p><h3 id="SOcket-API"><a href="#SOcket-API" class="headerlink" title="SOcket API"></a>SOcket API</h3><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904110205377.png" alt="image-20220904110205377"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904111702789.png" alt="image-20220904111702789"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904111714801.png" alt="image-20220904111714801"><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904111758165.png" alt="image-20220904111758165"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904111839346.png" alt="image-20220904111839346"></p><p>生成新套接字</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904112045577.png" alt="image-20220904112045577"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904112225360.png" alt="image-20220904112225360"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904112547914.png" alt="image-20220904112547914"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904112552719.png" alt="image-20220904112552719"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904112607715.png" alt="image-20220904112607715"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904113310213.png" alt="image-20220904113310213"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904113331169.png" alt="image-20220904113331169"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904113357749.png" alt="image-20220904113357749"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904113545996.png" alt="image-20220904113545996"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904113849517.png" alt="image-20220904113849517"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220904113931816.png" alt="image-20220904113931816"></p><p>4种</p><h1 id="第四章，传输层"><a href="#第四章，传输层" class="headerlink" title="第四章，传输层"></a>第四章，传输层</h1><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20220912203606030.png" alt="image-20220912203606030"></p><h1 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h1><p>DF&#x3D;0允许分组</p><p>MF&#x3D;0代表这是最后一个分组</p><p>127.0.0.1本机地址（我自己知道我的IP是135.2xxxxxxxxx这个是代称</p><p>0.0.0.0代表本机地址，（我不知道我的IP地址，还没被分配，）</p><p>DHCP服务器是给用户分配【IP地址、子网掩码、默认网关地址、DNS服务器名称与IP地址】 </p><p>片偏移地址（offset&#x3D;1，代表8B，以8B为一个单位）</p><p>最大分片数据必须8的整数倍向下取整</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017151738350.png" alt="image-20221017151738350"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017152317844.png" alt="image-20221017152317844"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017153653809.png" alt="image-20221017153653809"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017160750946.png" alt="image-20221017160750946"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c3d98fa93f7a9d7371185e578de0dcb5.png" alt="OSI模型通信过程1"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221017165740786.png" alt="image-20221017165740786"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221018185619436.png" alt="image-20221018185619436"></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221018185638412.png" alt="image-20221018185638412"></p><p>1.主机有域名DNS缓存</p><p>2.本地域名服务器也有DNS缓存</p><p>3.权限下面还可以有多个权限域名服务器！！！！！！！！！！！</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221018185831617.png" alt=""></p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221018185930281.png" alt="image-20221018185930281"></p><p>权限下面还可以有多个权限域名服务器！！！！！！！！！！！</p><p><img src="/shizhuofan.GitHub.io/2023/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Users/86189/AppData/Roaming/Typora/typora-user-images/image-20221018201016403.png" alt="image-20221018201016403"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
